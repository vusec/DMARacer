diff --git a/Makefile b/Makefile
index 78c897c53713..a687c9a0646c 100644
--- a/Makefile
+++ b/Makefile
@@ -1090,9 +1090,6 @@ KBUILD_CFLAGS   += $(call cc-option,-Werror=incompatible-pointer-types)
 # Require designated initializers for all marked structures
 KBUILD_CFLAGS   += $(call cc-option,-Werror=designated-init)
 
-# Prevent loop unrolling to reduce the number of address-to-line collisions
-KBUILD_CFLAGS   += -fno-unroll-loops
-
 # change __FILE__ to the relative path from the srctree
 KBUILD_CPPFLAGS += $(call cc-option,-fmacro-prefix-map=$(srctree)/=)
 
@@ -1105,7 +1102,6 @@ include-$(CONFIG_KMSAN)		+= scripts/Makefile.kmsan
 include-$(CONFIG_UBSAN)		+= scripts/Makefile.ubsan
 include-$(CONFIG_KCOV)		+= scripts/Makefile.kcov
 include-$(CONFIG_RANDSTRUCT)	+= scripts/Makefile.randstruct
-include-$(CONFIG_KDFSAN)	+= scripts/Makefile.kdfsan
 include-$(CONFIG_GCC_PLUGINS)	+= scripts/Makefile.gcc-plugins
 
 include $(addprefix $(srctree)/, $(include-y))
@@ -1119,7 +1115,6 @@ KBUILD_CPPFLAGS += $(KCPPFLAGS)
 KBUILD_AFLAGS   += $(KAFLAGS)
 KBUILD_CFLAGS   += $(KCFLAGS)
 KBUILD_RUSTFLAGS += $(KRUSTFLAGS)
-KBUILD_LDFLAGS += -error-limit=0
 
 KBUILD_LDFLAGS_MODULE += --build-id=sha1
 LDFLAGS_vmlinux += --build-id=sha1
diff --git a/arch/Kconfig b/arch/Kconfig
index 86c26b7c18d5..aff2746c8af2 100644
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -1238,7 +1238,6 @@ config VMAP_STACK
 	default y
 	bool "Use a virtually-mapped stack"
 	depends on HAVE_ARCH_VMAP_STACK
-	depends on !KDFSAN
 	depends on !KASAN || KASAN_HW_TAGS || KASAN_VMALLOC
 	help
 	  Enable this if you want the use virtually-mapped kernel stacks
diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index 241464a5debd..73085b30b309 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -166,11 +166,11 @@ config ARM64
 	select HAVE_ARCH_KASAN_HW_TAGS if (HAVE_ARCH_KASAN && ARM64_MTE)
 	# Some instrumentation may be unsound, hence EXPERT
 	select HAVE_ARCH_KCSAN if EXPERT
-	select HAVE_ARCH_KDFSAN
 	select HAVE_ARCH_KFENCE
 	select HAVE_ARCH_KGDB
 	select HAVE_ARCH_MMAP_RND_BITS
 	select HAVE_ARCH_MMAP_RND_COMPAT_BITS if COMPAT
+	select HAVE_ARCH_PREL32_RELOCATIONS
 	select HAVE_ARCH_RANDOMIZE_KSTACK_OFFSET
 	select HAVE_ARCH_SECCOMP_FILTER
 	select HAVE_ARCH_STACKLEAK
diff --git a/arch/arm64/include/asm/page.h b/arch/arm64/include/asm/page.h
index a66285096bab..2312e6ee595f 100644
--- a/arch/arm64/include/asm/page.h
+++ b/arch/arm64/include/asm/page.h
@@ -14,25 +14,13 @@
 
 #include <linux/personality.h> /* for READ_IMPLIES_EXEC */
 #include <linux/types.h> /* for gfp_t */
-#include <linux/kdfsan.h>
 #include <asm/pgtable-types.h>
 
 struct page;
 struct vm_area_struct;
 
-extern void copy_page_orig(void *to, const void *from);
-static inline void copy_page(void *to, void *from)
-{
-	copy_page_orig(to, from);
-	dfsan_mem_transfer(to, from, PAGE_SIZE, dfsan_get_label((long)to), dfsan_get_label((long)from), 0);
-}
-
-extern void clear_page_orig(void *to);
-static inline void clear_page(void *to)
-{
-	clear_page_orig(to);
-	dfsan_set_label(0, to, PAGE_SIZE);
-}
+extern void copy_page(void *to, const void *from);
+extern void clear_page(void *to);
 
 void copy_user_highpage(struct page *to, struct page *from,
 			unsigned long vaddr, struct vm_area_struct *vma);
diff --git a/arch/arm64/include/asm/string.h b/arch/arm64/include/asm/string.h
index f075713e6ae5..3a3264ff47b9 100644
--- a/arch/arm64/include/asm/string.h
+++ b/arch/arm64/include/asm/string.h
@@ -5,7 +5,6 @@
 #ifndef __ASM_STRING_H
 #define __ASM_STRING_H
 
-#if !(defined(CONFIG_KDFSAN))
 #if !(defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS))
 #define __HAVE_ARCH_STRRCHR
 extern char *strrchr(const char *, int c);
@@ -34,16 +33,14 @@ extern void *memchr(const void *, int, __kernel_size_t);
 
 #define __HAVE_ARCH_MEMCPY
 extern void *memcpy(void *, const void *, __kernel_size_t);
+extern void *__memcpy(void *, const void *, __kernel_size_t);
 
 #define __HAVE_ARCH_MEMMOVE
 extern void *memmove(void *, const void *, __kernel_size_t);
+extern void *__memmove(void *, const void *, __kernel_size_t);
 
 #define __HAVE_ARCH_MEMSET
 extern void *memset(void *, int, __kernel_size_t);
-#endif
-
-extern void *__memcpy(void *, const void *, __kernel_size_t);
-extern void *__memmove(void *, const void *, __kernel_size_t);
 extern void *__memset(void *, int, __kernel_size_t);
 
 #ifdef CONFIG_ARCH_HAS_UACCESS_FLUSHCACHE
diff --git a/arch/arm64/include/asm/syscall_wrapper.h b/arch/arm64/include/asm/syscall_wrapper.h
index a32ae1387965..17f687510c48 100644
--- a/arch/arm64/include/asm/syscall_wrapper.h
+++ b/arch/arm64/include/asm/syscall_wrapper.h
@@ -61,9 +61,7 @@
 	}									\
 	static long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))		\
 	{									\
-		long ret;						\
-		__MAPN(x,__SC_KDF_TAINT,__VA_ARGS__);			\
-		ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));	\
+		long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));	\
 		__MAP(x,__SC_TEST,__VA_ARGS__);					\
 		__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));		\
 		return ret;							\
diff --git a/arch/arm64/include/asm/uaccess.h b/arch/arm64/include/asm/uaccess.h
index d460caaf6e6e..14be5000c5a0 100644
--- a/arch/arm64/include/asm/uaccess.h
+++ b/arch/arm64/include/asm/uaccess.h
@@ -17,7 +17,6 @@
 #include <linux/bitops.h>
 #include <linux/kasan-checks.h>
 #include <linux/string.h>
-#include <linux/kdfsan.h>
 
 #include <asm/asm-extable.h>
 #include <asm/cpufeature.h>
@@ -240,7 +239,6 @@ do {									\
 	if (access_ok(__p, sizeof(*__p))) {				\
 		__p = uaccess_mask_ptr(__p);				\
 		__raw_get_user((x), __p, (err));			\
-		dfsan_mem_transfer((void *)&(x), (__p), sizeof(*(__p)), 0, dfsan_get_label((long) (__p)), 0);	\
 	} else {							\
 		(x) = (__force __typeof__(x))0; (err) = -EFAULT;	\
 	}								\
@@ -369,7 +367,6 @@ extern unsigned long __must_check __arch_copy_from_user(void *to, const void __u
 	__acfu_ret = __arch_copy_from_user((to),			\
 				      __uaccess_mask_ptr(from), (n));	\
 	uaccess_ttbr0_disable();					\
-	dfsan_mem_transfer((to), (from), ((n) - __acfu_ret), dfsan_get_label((long) to), dfsan_get_label((long) from), dfsan_get_label((long) n));	\
 	__acfu_ret;							\
 })
 
diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
index b9a2f9cebccd..d95b3d6b471a 100644
--- a/arch/arm64/kernel/Makefile
+++ b/arch/arm64/kernel/Makefile
@@ -25,8 +25,6 @@ KASAN_SANITIZE_stacktrace.o := n
 KCOV_INSTRUMENT_entry-common.o := n
 KCOV_INSTRUMENT_idle.o := n
 
-KDFSAN_SANITIZE_setup.o += n
-
 # Object file lists.
 obj-y			:= debug-monitors.o entry.o irq.o fpsimd.o		\
 			   entry-common.o entry-fpsimd.o process.o ptrace.o	\
diff --git a/arch/arm64/kernel/image-vars.h b/arch/arm64/kernel/image-vars.h
index a5b7267246fa..35f3c7959513 100644
--- a/arch/arm64/kernel/image-vars.h
+++ b/arch/arm64/kernel/image-vars.h
@@ -83,8 +83,8 @@ KVM_NVHE_ALIAS(kvm_arm_pmu_available);
 #endif
 
 /* Position-independent library routines */
-KVM_NVHE_ALIAS_HYP(clear_page_orig, __pi_clear_page_orig);
-KVM_NVHE_ALIAS_HYP(copy_page_orig, __pi_copy_page_orig);
+KVM_NVHE_ALIAS_HYP(clear_page, __pi_clear_page);
+KVM_NVHE_ALIAS_HYP(copy_page, __pi_copy_page);
 KVM_NVHE_ALIAS_HYP(memcpy, __pi_memcpy);
 KVM_NVHE_ALIAS_HYP(memset, __pi_memset);
 
diff --git a/arch/arm64/kernel/vdso/Makefile b/arch/arm64/kernel/vdso/Makefile
index f2f2173fda02..fe7a53c6781f 100644
--- a/arch/arm64/kernel/vdso/Makefile
+++ b/arch/arm64/kernel/vdso/Makefile
@@ -42,7 +42,6 @@ CFLAGS_REMOVE_vgettimeofday.o = $(CC_FLAGS_FTRACE) -Os $(CC_FLAGS_SCS) \
 				-Wmissing-prototypes -Wmissing-declarations
 KASAN_SANITIZE			:= n
 KCSAN_SANITIZE			:= n
-KDFSAN_SANITIZE			:= n
 UBSAN_SANITIZE			:= n
 OBJECT_FILES_NON_STANDARD	:= y
 KCOV_INSTRUMENT			:= n
diff --git a/arch/arm64/kvm/hyp/nvhe/Makefile b/arch/arm64/kvm/hyp/nvhe/Makefile
index e6e543fd54bb..9ddc025e4b86 100644
--- a/arch/arm64/kvm/hyp/nvhe/Makefile
+++ b/arch/arm64/kvm/hyp/nvhe/Makefile
@@ -104,7 +104,6 @@ KBUILD_CFLAGS += -fno-asynchronous-unwind-tables -fno-unwind-tables
 GCOV_PROFILE	:= n
 KASAN_SANITIZE	:= n
 KCSAN_SANITIZE	:= n
-KDFSAN_SANITIZE	:= n
 UBSAN_SANITIZE	:= n
 KCOV_INSTRUMENT	:= n
 
diff --git a/arch/arm64/lib/clear_page.S b/arch/arm64/lib/clear_page.S
index 5f059e2072e8..ebde40e7fa2b 100644
--- a/arch/arm64/lib/clear_page.S
+++ b/arch/arm64/lib/clear_page.S
@@ -36,6 +36,5 @@ SYM_FUNC_START(__pi_clear_page)
 	b.ne	2b
 	ret
 SYM_FUNC_END(__pi_clear_page)
-SYM_FUNC_ALIAS(clear_page_orig, __pi_clear_page)
-EXPORT_SYMBOL(clear_page_orig)
-
+SYM_FUNC_ALIAS(clear_page, __pi_clear_page)
+EXPORT_SYMBOL(clear_page)
diff --git a/arch/arm64/lib/copy_page.S b/arch/arm64/lib/copy_page.S
index 7f9188ca54d0..c336d2ffdec5 100644
--- a/arch/arm64/lib/copy_page.S
+++ b/arch/arm64/lib/copy_page.S
@@ -76,5 +76,5 @@ alternative_else_nop_endif
 
 	ret
 SYM_FUNC_END(__pi_copy_page)
-SYM_FUNC_ALIAS(copy_page_orig, __pi_copy_page)
-EXPORT_SYMBOL(copy_page_orig)
+SYM_FUNC_ALIAS(copy_page, __pi_copy_page)
+EXPORT_SYMBOL(copy_page)
diff --git a/arch/arm64/mm/Makefile b/arch/arm64/mm/Makefile
index e77575513ae4..dbd1bc95967d 100644
--- a/arch/arm64/mm/Makefile
+++ b/arch/arm64/mm/Makefile
@@ -14,7 +14,3 @@ KASAN_SANITIZE_physaddr.o	+= n
 
 obj-$(CONFIG_KASAN)		+= kasan_init.o
 KASAN_SANITIZE_kasan_init.o	:= n
-
-KDFSAN_SANITIZE_init.o		+= n
-KDFSAN_SANITIZE_mmu.o		+= n
-KDFSAN_SANITIZE_physaddr.o	+= n
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 5bc5a1a7112a..68ce4f786dcd 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -175,13 +175,13 @@ config X86
 	select HAVE_ARCH_JUMP_LABEL_RELATIVE
 	select HAVE_ARCH_KASAN			if X86_64
 	select HAVE_ARCH_KASAN_VMALLOC		if X86_64
-	select HAVE_ARCH_KDFSAN		        if X86_64
 	select HAVE_ARCH_KFENCE
 	select HAVE_ARCH_KMSAN			if X86_64
 	select HAVE_ARCH_KGDB
 	select HAVE_ARCH_MMAP_RND_BITS		if MMU
 	select HAVE_ARCH_MMAP_RND_COMPAT_BITS	if MMU && COMPAT
 	select HAVE_ARCH_COMPAT_MMAP_BASES	if MMU && COMPAT
+	select HAVE_ARCH_PREL32_RELOCATIONS
 	select HAVE_ARCH_SECCOMP_FILTER
 	select HAVE_ARCH_THREAD_STRUCT_WHITELIST
 	select HAVE_ARCH_STACKLEAK
@@ -266,8 +266,8 @@ config X86
 	select HAVE_SOFTIRQ_ON_OWN_STACK
 	select HAVE_STACKPROTECTOR		if CC_HAS_SANE_STACKPROTECTOR
 	select HAVE_STACK_VALIDATION		if HAVE_OBJTOOL
-	#select HAVE_STATIC_CALL
-	#select HAVE_STATIC_CALL_INLINE		if HAVE_OBJTOOL
+	select HAVE_STATIC_CALL
+	select HAVE_STATIC_CALL_INLINE		if HAVE_OBJTOOL
 	select HAVE_PREEMPT_DYNAMIC_CALL
 	select HAVE_RSEQ
 	select HAVE_RUST			if X86_64
@@ -344,7 +344,7 @@ config GENERIC_ISA_DMA
 
 config GENERIC_CSUM
 	bool
-	default y if KMSAN || KASAN || KDFSAN
+	default y if KMSAN || KASAN
 
 config GENERIC_BUG
 	def_bool y
diff --git a/arch/x86/Makefile b/arch/x86/Makefile
index e9dbe1b229b5..fdc2e3abd615 100644
--- a/arch/x86/Makefile
+++ b/arch/x86/Makefile
@@ -188,8 +188,7 @@ endif
 # Workaround for a gcc prelease that unfortunately was shipped in a suse release
 KBUILD_CFLAGS += -Wno-sign-compare
 #
-KBUILD_CFLAGS += -fno-asynchronous-unwind-tables -fno-unwind-tables
-KBUILD_AFLAGS += -fno-asynchronous-unwind-tables -fno-unwind-tables
+KBUILD_CFLAGS += -fno-asynchronous-unwind-tables
 
 # Avoid indirect branches in kernel to deal with Spectre
 ifdef CONFIG_RETPOLINE
diff --git a/arch/x86/boot/Makefile b/arch/x86/boot/Makefile
index bf6c106f7baf..f33e45ed1437 100644
--- a/arch/x86/boot/Makefile
+++ b/arch/x86/boot/Makefile
@@ -13,8 +13,6 @@
 KASAN_SANITIZE			:= n
 KCSAN_SANITIZE			:= n
 KMSAN_SANITIZE			:= n
-KDFSAN_SANITIZE			:= n
-KDFSAN_NO_RUNTIME_main.o	:= y
 OBJECT_FILES_NON_STANDARD	:= y
 
 # Kernel does not boot with kcov instrumentation here.
diff --git a/arch/x86/boot/compressed/Makefile b/arch/x86/boot/compressed/Makefile
index 68f9240639bd..40d2ff503079 100644
--- a/arch/x86/boot/compressed/Makefile
+++ b/arch/x86/boot/compressed/Makefile
@@ -21,8 +21,6 @@
 KASAN_SANITIZE			:= n
 KCSAN_SANITIZE			:= n
 KMSAN_SANITIZE			:= n
-KDFSAN_SANITIZE			:= n
-KDFSAN_NO_RUNTIME_misc.o	:= y
 OBJECT_FILES_NON_STANDARD	:= y
 
 # Prevents link failures: __sanitizer_cov_trace_pc() is not linked in.
diff --git a/arch/x86/entry/common.c b/arch/x86/entry/common.c
index e1a776dbeea8..6c2826417b33 100644
--- a/arch/x86/entry/common.c
+++ b/arch/x86/entry/common.c
@@ -50,11 +50,6 @@ static __always_inline bool do_syscall_x64(struct pt_regs *regs, int nr)
 		regs->ax = sys_call_table[unr](regs);
 		return true;
 	}
-	else if (nr >= 600 && nr < 1200) {
-		unr = array_index_nospec(unr - 600, NR_syscalls);
-		regs->ax = sys_call_table[unr](regs);
-		return true;
-	}
 	return false;
 }
 
diff --git a/arch/x86/entry/vdso/Makefile b/arch/x86/entry/vdso/Makefile
index e2c67096cdf0..6a1821bd7d5e 100644
--- a/arch/x86/entry/vdso/Makefile
+++ b/arch/x86/entry/vdso/Makefile
@@ -10,8 +10,7 @@ include $(srctree)/lib/vdso/Makefile
 KASAN_SANITIZE			:= n
 KMSAN_SANITIZE_vclock_gettime.o := n
 KMSAN_SANITIZE_vgetcpu.o	:= n
-KDFSAN_SANITIZE_vclock_gettime.o := n
-KDFSAN_SANITIZE_vgetcpu.o	:= n
+
 UBSAN_SANITIZE			:= n
 KCSAN_SANITIZE			:= n
 OBJECT_FILES_NON_STANDARD	:= y
diff --git a/arch/x86/include/asm/io.h b/arch/x86/include/asm/io.h
index efd30a24fe9a..e9025640f634 100644
--- a/arch/x86/include/asm/io.h
+++ b/arch/x86/include/asm/io.h
@@ -41,35 +41,21 @@
 #include <linux/string.h>
 #include <linux/compiler.h>
 #include <linux/cc_platform.h>
-#include <linux/kdfsan.h>
 #include <asm/page.h>
 #include <asm/early_ioremap.h>
 #include <asm/pgtable_types.h>
 #include <asm/shared/io.h>
 
-#ifdef CONFIG_KDFSAN
-
 #define build_mmio_read(name, size, type, reg, barrier) \
-type name(const volatile void __iomem *addr);
-
-#define build_mmio_write(name, size, type, reg, barrier) \
-void name(type val, volatile void __iomem *addr);
-
-#else
-
-#define build_mmio_read(name, size, type, reg, barrier) \
-static __always_inline type name(const volatile void __iomem *addr) \
+static inline type name(const volatile void __iomem *addr) \
 { type ret; asm volatile("mov" size " %1,%0":reg (ret) \
-:"m" (*(volatile type __force *)addr) barrier); \
-return ret; }
+:"m" (*(volatile type __force *)addr) barrier); return ret; }
 
 #define build_mmio_write(name, size, type, reg, barrier) \
-static __always_inline void name(type val, volatile void __iomem *addr) \
+static inline void name(type val, volatile void __iomem *addr) \
 { asm volatile("mov" size " %0,%1": :reg (val), \
 "m" (*(volatile type __force *)addr) barrier); }
 
-#endif
-
 build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
 build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
 build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
@@ -262,20 +248,20 @@ static inline void slow_down_io(void)
 #endif
 
 #define BUILDIO(bwl, bw, type)						\
-static __always_inline void out##bwl##_p(type value, u16 port)		\
+static inline void out##bwl##_p(type value, u16 port)			\
 {									\
 	out##bwl(value, port);						\
 	slow_down_io();							\
 }									\
 									\
-static __always_inline type in##bwl##_p(u16 port)			\
+static inline type in##bwl##_p(u16 port)				\
 {									\
 	type value = in##bwl(port);					\
 	slow_down_io();							\
 	return value;							\
 }									\
 									\
-static __always_inline void outs##bwl(u16 port, const void *addr, unsigned long count) \
+static inline void outs##bwl(u16 port, const void *addr, unsigned long count) \
 {									\
 	if (cc_platform_has(CC_ATTR_GUEST_UNROLL_STRING_IO)) {		\
 		type *value = (type *)addr;				\
@@ -285,16 +271,13 @@ static __always_inline void outs##bwl(u16 port, const void *addr, unsigned long
 			count--;					\
 		}							\
 	} else {							\
-		const void *orig_addr = addr;				\
-		const unsigned long orig_count = count;			\
 		asm volatile("rep; outs" #bwl				\
 			     : "+S"(addr), "+c"(count)			\
 			     : "d"(port) : "memory");			\
-		kdfsan_pmio_out((void*)orig_addr, port, orig_count, dfsan_get_label((long)orig_addr), dfsan_get_label(port), dfsan_get_label(orig_count)); \
 	}								\
 }									\
 									\
-static __always_inline void ins##bwl(u16 port, void *addr, unsigned long count)	\
+static inline void ins##bwl(u16 port, void *addr, unsigned long count)	\
 {									\
 	if (cc_platform_has(CC_ATTR_GUEST_UNROLL_STRING_IO)) {		\
 		type *value = (type *)addr;				\
@@ -304,12 +287,9 @@ static __always_inline void ins##bwl(u16 port, void *addr, unsigned long count)
 			count--;					\
 		}							\
 	} else {							\
-		const void *orig_addr = addr;				\
-		const unsigned long orig_count = count;			\
 		asm volatile("rep; ins" #bwl				\
 			     : "+D"(addr), "+c"(count)			\
 			     : "d"(port) : "memory");			\
-		kdfsan_pmio_in(port, orig_count, (void*)orig_addr, dfsan_get_label(port), dfsan_get_label(orig_count), dfsan_get_label((long)orig_addr));	\
 	}								\
 }
 
diff --git a/arch/x86/include/asm/page_64.h b/arch/x86/include/asm/page_64.h
index 3f397c2d8bf3..cc6b8e087192 100644
--- a/arch/x86/include/asm/page_64.h
+++ b/arch/x86/include/asm/page_64.h
@@ -7,7 +7,6 @@
 #ifndef __ASSEMBLY__
 #include <asm/cpufeatures.h>
 #include <asm/alternative.h>
-#include <linux/kdfsan.h>
 
 #include <linux/kmsan-checks.h>
 
@@ -51,7 +50,6 @@ static inline void clear_page(void *page)
 	 * below clobbers @page, so we perform unpoisoning before it.
 	 */
 	kmsan_unpoison_memory(page, PAGE_SIZE);
-	dfsan_set_label(0, page, PAGE_SIZE);
 	alternative_call_2(clear_page_orig,
 			   clear_page_rep, X86_FEATURE_REP_GOOD,
 			   clear_page_erms, X86_FEATURE_ERMS,
@@ -60,13 +58,7 @@ static inline void clear_page(void *page)
 			   : "cc", "memory", "rax", "rcx");
 }
 
-void copy_page_orig(void *to, void *from);
-
-static inline void copy_page(void *to, void *from)
-{
-	copy_page_orig(to, from);
-	dfsan_mem_transfer(to, from, PAGE_SIZE, dfsan_get_label((long)to), dfsan_get_label((long)from), 0);
-}
+void copy_page(void *to, void *from);
 
 #ifdef CONFIG_X86_5LEVEL
 /*
diff --git a/arch/x86/include/asm/page_64_types.h b/arch/x86/include/asm/page_64_types.h
index c736115de3bb..06ef25411d62 100644
--- a/arch/x86/include/asm/page_64_types.h
+++ b/arch/x86/include/asm/page_64_types.h
@@ -11,19 +11,14 @@
 #else
 #define KASAN_STACK_ORDER 0
 #endif
-#ifdef CONFIG_KDFSAN
-#define KDFSAN_STACK_ORDER 2
-#else
-#define KDFSAN_STACK_ORDER 0
-#endif
 
-#define THREAD_SIZE_ORDER	(2 + KASAN_STACK_ORDER + KDFSAN_STACK_ORDER)
+#define THREAD_SIZE_ORDER	(2 + KASAN_STACK_ORDER)
 #define THREAD_SIZE  (PAGE_SIZE << THREAD_SIZE_ORDER)
 
-#define EXCEPTION_STACK_ORDER (1 + KASAN_STACK_ORDER + KDFSAN_STACK_ORDER)
+#define EXCEPTION_STACK_ORDER (1 + KASAN_STACK_ORDER)
 #define EXCEPTION_STKSZ (PAGE_SIZE << EXCEPTION_STACK_ORDER)
 
-#define IRQ_STACK_ORDER (2 + KASAN_STACK_ORDER + KDFSAN_STACK_ORDER)
+#define IRQ_STACK_ORDER (2 + KASAN_STACK_ORDER)
 #define IRQ_STACK_SIZE (PAGE_SIZE << IRQ_STACK_ORDER)
 
 /*
diff --git a/arch/x86/include/asm/shared/io.h b/arch/x86/include/asm/shared/io.h
index 92b352b4372c..8009d781c2f9 100644
--- a/arch/x86/include/asm/shared/io.h
+++ b/arch/x86/include/asm/shared/io.h
@@ -3,21 +3,12 @@
 #define _ASM_X86_SHARED_IO_H
 
 #include <linux/types.h>
-#include <linux/kdfsan.h>
 
 #define BUILDIO(bwl, bw, type)						\
 static __always_inline void __out##bwl(type value, u16 port)		\
 {									\
 	asm volatile("out" #bwl " %" #bw "0, %w1"			\
 		     : : "a"(value), "Nd"(port));			\
-	kdfsan_pmio_out(&value, port, sizeof(type), dfsan_get_label(value), dfsan_get_label(port), 0);	\
-}									\
-									\
-static __always_inline void __out##bwl##_ret(type value, u16 port)	\
-{									\
-	asm volatile("out" #bwl " %" #bw "0, %w1"			\
-		     : : "a"(value), "Nd"(port));			\
-	kdfsan_pmio_out_with_rip(&value, port, sizeof(type), dfsan_get_label(value), dfsan_get_label(port), 0, __builtin_return_address(0));	\
 }									\
 									\
 static __always_inline type __in##bwl(u16 port)				\
@@ -25,16 +16,6 @@ static __always_inline type __in##bwl(u16 port)				\
 	type value;							\
 	asm volatile("in" #bwl " %w1, %" #bw "0"			\
 		     : "=a"(value) : "Nd"(port));			\
-	kdfsan_pmio_in(port, sizeof(type), &value, dfsan_get_label(port), 0, 0);	\
-	return value;							\
-}									\
-									\
-static __always_inline type __in##bwl##_ret(u16 port)			\
-{									\
-	type value;							\
-	asm volatile("in" #bwl " %w1, %" #bw "0"			\
-		     : "=a"(value) : "Nd"(port));			\
-	kdfsan_pmio_in_with_rip(port, sizeof(type), &value, dfsan_get_label(port), 0, 0, __builtin_return_address(0));	\
 	return value;							\
 }
 
diff --git a/arch/x86/include/asm/string_64.h b/arch/x86/include/asm/string_64.h
index 28d964e76e42..857d364b9888 100644
--- a/arch/x86/include/asm/string_64.h
+++ b/arch/x86/include/asm/string_64.h
@@ -16,15 +16,17 @@
 
 #define __HAVE_ARCH_MEMCPY 1
 extern void *memcpy(void *to, const void *from, size_t len);
+extern void *__memcpy(void *to, const void *from, size_t len);
 
 #define __HAVE_ARCH_MEMSET
 void *memset(void *s, int c, size_t n);
+void *__memset(void *s, int c, size_t n);
 
 /*
  * KMSAN needs to instrument as much code as possible. Use C versions of
  * memsetXX() from lib/string.c under KMSAN.
  */
-#if !defined(CONFIG_KDFSAN) && !defined(CONFIG_KMSAN)
+#if !defined(CONFIG_KMSAN)
 #define __HAVE_ARCH_MEMSET16
 static inline void *memset16(uint16_t *s, uint16_t v, size_t n)
 {
@@ -64,9 +66,6 @@ static inline void *memset64(uint64_t *s, uint64_t v, size_t n)
 
 #define __HAVE_ARCH_MEMMOVE
 void *memmove(void *dest, const void *src, size_t count);
-
-extern void *__memcpy(void *to, const void *from, size_t len);
-void *__memset(void *s, int c, size_t n);
 void *__memmove(void *dest, const void *src, size_t count);
 
 int memcmp(const void *cs, const void *ct, size_t count);
diff --git a/arch/x86/include/asm/syscall_wrapper.h b/arch/x86/include/asm/syscall_wrapper.h
index 79295b26ac92..fd2669b1cb2d 100644
--- a/arch/x86/include/asm/syscall_wrapper.h
+++ b/arch/x86/include/asm/syscall_wrapper.h
@@ -232,9 +232,7 @@ extern long __ia32_sys_ni_syscall(const struct pt_regs *regs);
 	__IA32_SYS_STUBx(x, name, __VA_ARGS__)				\
 	static long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))	\
 	{								\
-		long ret;						\
-		__MAPN(x,__SC_KDF_TAINT,__VA_ARGS__);			\
-		ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));	\
+		long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\
 		__MAP(x,__SC_TEST,__VA_ARGS__);				\
 		__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));	\
 		return ret;						\
diff --git a/arch/x86/include/asm/thread_info.h b/arch/x86/include/asm/thread_info.h
index b48d8908ece0..d63b02940747 100644
--- a/arch/x86/include/asm/thread_info.h
+++ b/arch/x86/include/asm/thread_info.h
@@ -168,7 +168,7 @@ struct thread_info {
  * pointers may not have their KMSAN shadow set up properly, which may result
  * in false positive reports. Disable instrumentation to avoid those.
  */
-__no_kmsan_checks __no_kdfsan_taint
+__no_kmsan_checks
 static inline int arch_within_stack_frames(const void * const stack,
 					   const void * const stackend,
 					   const void *obj, unsigned long len)
diff --git a/arch/x86/include/asm/uaccess.h b/arch/x86/include/asm/uaccess.h
index a41fa0ffd8e2..8bae40a66282 100644
--- a/arch/x86/include/asm/uaccess.h
+++ b/arch/x86/include/asm/uaccess.h
@@ -10,7 +10,6 @@
 #include <linux/mm_types.h>
 #include <linux/string.h>
 #include <linux/mmap_lock.h>
-#include <linux/kdfsan.h>
 #include <asm/asm.h>
 #include <asm/page.h>
 #include <asm/smap.h>
@@ -77,7 +76,6 @@ extern int __get_user_bad(void);
 #define do_get_user_call(fn,x,ptr)					\
 ({									\
 	int __ret_gu;							\
-	__typeof__(*(ptr)) __user *__p = (ptr);				\
 	register __inttype(*(ptr)) __val_gu asm("%"_ASM_DX);		\
 	__chk_user_ptr(ptr);						\
 	asm volatile("call __" #fn "_%P4"				\
@@ -86,7 +84,6 @@ extern int __get_user_bad(void);
 		     : "0" (ptr), "i" (sizeof(*(ptr))));		\
 	instrument_get_user(__val_gu);					\
 	(x) = (__force __typeof__(*(ptr))) __val_gu;			\
-	dfsan_mem_transfer((void *)&(x), (__p), sizeof(*(ptr)), 0, dfsan_get_label((long) (__p)), 0);	\
 	__builtin_expect(__ret_gu, 0);					\
 })
 
@@ -188,7 +185,6 @@ extern void __put_user_nocheck_8(void);
 		       [size] "i" (sizeof(*(ptr)))			\
 		     :"ebx");						\
 	instrument_put_user(__x, __ptr, sizeof(*(ptr)));		\
-	dfsan_mem_transfer((__ptr), (const void *)&(__x), sizeof(*(ptr)), dfsan_get_label((long) (__ptr)), 0, 0);	\
 	__builtin_expect(__ret_pu, 0);					\
 })
 
@@ -299,16 +295,12 @@ do {									\
 } while (0)
 
 #define __get_user_asm(x, addr, itype, ltype, label)			\
-do {									\
-	__typeof__(*(addr)) __user *__p = (addr);			\
 	asm_volatile_goto("\n"						\
 		     "1:	mov"itype" %[umem],%[output]\n"		\
 		     _ASM_EXTABLE_UA(1b, %l2)				\
 		     : [output] ltype(x)				\
 		     : [umem] "m" (__m(addr))				\
-		     : : label);					\
-	dfsan_mem_transfer((void *)&(x), (__p), sizeof(*(addr)), 0, dfsan_get_label((long) (__p)), 0);	\
-} while (0)
+		     : : label)
 
 #else // !CONFIG_CC_HAS_ASM_GOTO_OUTPUT
 
@@ -485,16 +477,11 @@ struct __large_struct { unsigned long buf[100]; };
  * aliasing issues.
  */
 #define __put_user_goto(x, addr, itype, ltype, label)			\
-do {									\
-	__typeof__(*(addr)) ___x = (x);					\
-	__typeof__(addr) ___ptr = (addr);				\
 	asm_volatile_goto("\n"						\
 		"1:	mov"itype" %0,%1\n"				\
 		_ASM_EXTABLE_UA(1b, %l2)				\
 		: : ltype(x), "m" (__m(addr))				\
-		: : label);						\
-	dfsan_mem_transfer((___ptr), (const void *)&(___x), sizeof(*(addr)), dfsan_get_label((long) (___ptr)), 0, 0);	\
-} while (0)
+		: : label)
 
 extern unsigned long
 copy_from_user_nmi(void *to, const void __user *from, unsigned long n);
diff --git a/arch/x86/include/asm/uaccess_64.h b/arch/x86/include/asm/uaccess_64.h
index 13c5d5964204..f2c02e4469cc 100644
--- a/arch/x86/include/asm/uaccess_64.h
+++ b/arch/x86/include/asm/uaccess_64.h
@@ -7,7 +7,6 @@
  */
 #include <linux/compiler.h>
 #include <linux/lockdep.h>
-#include <linux/kdfsan.h>
 #include <linux/kasan-checks.h>
 #include <asm/alternative.h>
 #include <asm/cpufeatures.h>
@@ -122,26 +121,16 @@ copy_user_generic(void *to, const void *from, unsigned long len)
 	return len;
 }
 
-static __always_inline __must_check unsigned long
-raw_copy_from_user_wrapped(void *dst, const void __user *src, unsigned long size)
-{
-	return copy_user_generic(dst, (__force void *)src, size);
-}
-
 static __always_inline __must_check unsigned long
 raw_copy_from_user(void *dst, const void __user *src, unsigned long size)
 {
-	unsigned long ret = raw_copy_from_user_wrapped(dst, src, size);
-	dfsan_mem_transfer_with_rip(dst, src, size - ret, dfsan_get_label((long) dst), dfsan_get_label((long) src), dfsan_get_label(size), __builtin_return_address(0));
-	return ret;
+	return copy_user_generic(dst, (__force void *)src, size);
 }
 
 static __always_inline __must_check unsigned long
 raw_copy_to_user(void __user *dst, const void *src, unsigned long size)
 {
-	unsigned long ret = copy_user_generic((__force void *)dst, src, size);
-	dfsan_mem_transfer_with_rip(dst, src, size - ret, dfsan_get_label((long) dst), dfsan_get_label((long) src), dfsan_get_label(size), __builtin_return_address(0));
-	return ret;
+	return copy_user_generic((__force void *)dst, src, size);
 }
 
 extern long __copy_user_nocache(void *dst, const void __user *src, unsigned size);
diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
index 83e4277a7964..4070a01c11b7 100644
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@ -32,8 +32,6 @@ KASAN_SANITIZE_sev.o					:= n
 KCSAN_SANITIZE := n
 KMSAN_SANITIZE_head$(BITS).o				:= n
 KMSAN_SANITIZE_nmi.o					:= n
-KDFSAN_SANITIZE_head$(BITS).o				:= n
-KDFSAN_SANITIZE_nmi.o					:= n
 
 # If instrumentation of this dir is enabled, boot hangs during first second.
 # Probably could be more selective here, but note that files related to irqs,
diff --git a/arch/x86/kernel/cpu/Makefile b/arch/x86/kernel/cpu/Makefile
index 35f1915e61f7..4350f6bfc064 100644
--- a/arch/x86/kernel/cpu/Makefile
+++ b/arch/x86/kernel/cpu/Makefile
@@ -13,7 +13,6 @@ endif
 KCOV_INSTRUMENT_common.o := n
 KCOV_INSTRUMENT_perf_event.o := n
 KMSAN_SANITIZE_common.o := n
-KDFSAN_SANITIZE_common.o := n
 
 # As above, instrumenting secondary CPU boot code causes boot hangs.
 KCSAN_SANITIZE_common.o := n
diff --git a/arch/x86/kernel/dumpstack.c b/arch/x86/kernel/dumpstack.c
index 951c88d6e32f..f18ca44c904b 100644
--- a/arch/x86/kernel/dumpstack.c
+++ b/arch/x86/kernel/dumpstack.c
@@ -69,9 +69,7 @@ static void printk_stack_address(unsigned long address, int reliable,
 				 const char *log_lvl)
 {
 	touch_nmi_watchdog();
-
-        if (reliable)
-            printk("%s %s%pB\n", log_lvl, reliable ? "" : "? ", (void *)address);
+	printk("%s %s%pBb\n", log_lvl, reliable ? "" : "? ", (void *)address);
 }
 
 static int copy_code(struct pt_regs *regs, u8 *buf, unsigned long src,
@@ -184,7 +182,7 @@ static void show_regs_if_on_stack(struct stack_info *info, struct pt_regs *regs,
  * pointers may not have their KMSAN shadow set up properly, which may result
  * in false positive reports. Disable instrumentation to avoid those.
  */
-__no_kmsan_checks __no_kdfsan_taint
+__no_kmsan_checks
 static void show_trace_log_lvl(struct task_struct *task, struct pt_regs *regs,
 			unsigned long *stack, const char *log_lvl)
 {
diff --git a/arch/x86/kernel/dumpstack_64.c b/arch/x86/kernel/dumpstack_64.c
index 97c1e73814e7..f05339fee778 100644
--- a/arch/x86/kernel/dumpstack_64.c
+++ b/arch/x86/kernel/dumpstack_64.c
@@ -72,7 +72,7 @@ struct estack_pages {
 	[PFN_DOWN(CEA_ESTACK_OFFS(st)) ...				\
 	 PFN_DOWN(CEA_ESTACK_OFFS(st) + CEA_ESTACK_SIZE(st) - 1)] = {	\
 		.offs	= CEA_ESTACK_OFFS(st),				\
-		.size	= (u16)CEA_ESTACK_SIZE(st),				\
+		.size	= CEA_ESTACK_SIZE(st),				\
 		.type	= STACK_TYPE_EXCEPTION + ESTACK_ ##st, }
 
 /*
diff --git a/arch/x86/kernel/process.c b/arch/x86/kernel/process.c
index ebd56ec3a6ff..72015dba72ab 100644
--- a/arch/x86/kernel/process.c
+++ b/arch/x86/kernel/process.c
@@ -151,7 +151,6 @@ __visible void ret_from_fork(struct task_struct *prev, struct pt_regs *regs,
 		regs->ax = 0;
 	}
 
-	kdfsan_domain_enter();
 	syscall_exit_to_user_mode(regs);
 }
 
diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c
index 2dd9a792b2be..3d181c16a2f6 100644
--- a/arch/x86/kernel/process_64.c
+++ b/arch/x86/kernel/process_64.c
@@ -554,7 +554,7 @@ void compat_start_thread(struct pt_regs *regs, u32 new_ip, u32 new_sp, bool x32)
  * Kprobes not supported here. Set the probe on schedule instead.
  * Function graph tracer not supported too.
  */
-__no_kmsan_checks __no_kdfsan_taint
+__no_kmsan_checks
 __visible __notrace_funcgraph struct task_struct *
 __switch_to(struct task_struct *prev_p, struct task_struct *next_p)
 {
diff --git a/arch/x86/kernel/unwind_frame.c b/arch/x86/kernel/unwind_frame.c
index 2fff9eb64e47..d8ba93778ae3 100644
--- a/arch/x86/kernel/unwind_frame.c
+++ b/arch/x86/kernel/unwind_frame.c
@@ -192,7 +192,7 @@ static struct pt_regs *decode_frame_pointer(unsigned long *bp)
  * we mark the functions scanning the stack (here and below) with
  * __no_kmsan_checks.
  */
-__no_kmsan_checks __no_kdfsan_taint
+__no_kmsan_checks
 static bool update_stack_state(struct unwind_state *state,
 			       unsigned long *next_bp)
 {
@@ -260,7 +260,7 @@ static bool update_stack_state(struct unwind_state *state,
 	return true;
 }
 
-__no_kmsan_checks __no_kdfsan_taint
+__no_kmsan_checks
 bool unwind_next_frame(struct unwind_state *state)
 {
 	struct pt_regs *regs;
diff --git a/arch/x86/kernel/vmlinux.lds.S b/arch/x86/kernel/vmlinux.lds.S
index 4636b5f03972..f15fb71f280e 100644
--- a/arch/x86/kernel/vmlinux.lds.S
+++ b/arch/x86/kernel/vmlinux.lds.S
@@ -497,7 +497,6 @@ SECTIONS
 		*(.rela.*) *(.rela_*)
 	}
 	ASSERT(SIZEOF(.rela.dyn) == 0, "Unexpected run-time relocations (.rela) detected!")
- 
 }
 
 /*
diff --git a/arch/x86/lib/copy_page_64.S b/arch/x86/lib/copy_page_64.S
index fe180ceecfb1..30ea644bf446 100644
--- a/arch/x86/lib/copy_page_64.S
+++ b/arch/x86/lib/copy_page_64.S
@@ -13,14 +13,13 @@
  * prefetch distance based on SMP/UP.
  */
 	ALIGN
-SYM_FUNC_START(copy_page_orig)
+SYM_FUNC_START(copy_page)
 	ALTERNATIVE "jmp copy_page_regs", "", X86_FEATURE_REP_GOOD
 	movl	$4096/8, %ecx
 	rep	movsq
 	RET
-	ret
-SYM_FUNC_END(copy_page_orig)
-EXPORT_SYMBOL(copy_page_orig)
+SYM_FUNC_END(copy_page)
+EXPORT_SYMBOL(copy_page)
 
 SYM_FUNC_START_LOCAL(copy_page_regs)
 	subq	$2*8,	%rsp
diff --git a/arch/x86/lib/iomem.c b/arch/x86/lib/iomem.c
index 8c9838e950ed..e0411a3774d4 100644
--- a/arch/x86/lib/iomem.c
+++ b/arch/x86/lib/iomem.c
@@ -25,10 +25,6 @@ static __always_inline void rep_movs(void *to, const void *from, size_t n)
 
 static void string_memcpy_fromio(void *to, const volatile void __iomem *from, size_t n)
 {
-	const void *orig_to = to;
-	const volatile void __iomem *orig_from = from;
-	const size_t orig_n = n;
-
 	if (unlikely(!n))
 		return;
 
@@ -44,15 +40,10 @@ static void string_memcpy_fromio(void *to, const volatile void __iomem *from, si
 	rep_movs(to, (const void *)from, n);
 	/* KMSAN must treat values read from devices as initialized. */
 	kmsan_unpoison_memory(to, n);
-	dfsan_mem_transfer_with_rip((void*)orig_to, (const void *)orig_from, orig_n, dfsan_get_label((long)orig_to), dfsan_get_label((long)orig_from), dfsan_get_label(orig_n), __builtin_return_address(0));
 }
 
 static void string_memcpy_toio(volatile void __iomem *to, const void *from, size_t n)
 {
-	const volatile void __iomem *orig_to = to;
-	const void *orig_from = from;
-	const size_t orig_n = n;
-
 	if (unlikely(!n))
 		return;
 
@@ -68,7 +59,6 @@ static void string_memcpy_toio(volatile void __iomem *to, const void *from, size
 		n-=2;
 	}
 	rep_movs((void *)to, (const void *) from, n);
-	dfsan_mem_transfer_with_rip((void*)orig_to, (const void *)orig_from, orig_n, dfsan_get_label((long)orig_to), dfsan_get_label((long)orig_from), dfsan_get_label(orig_n), __builtin_return_address(0));
 }
 
 static void unrolled_memcpy_fromio(void *to, const volatile void __iomem *from, size_t n)
diff --git a/arch/x86/mm/Makefile b/arch/x86/mm/Makefile
index 280da8fbf20a..c80febc44cd2 100644
--- a/arch/x86/mm/Makefile
+++ b/arch/x86/mm/Makefile
@@ -14,9 +14,8 @@ KASAN_SANITIZE_pgprot.o		:= n
 # Disable KCSAN entirely, because otherwise we get warnings that some functions
 # reference __initdata sections.
 KCSAN_SANITIZE := n
-# Avoid recursion by not calling KMSAN/KDFSAN hooks for CEA code.
+# Avoid recursion by not calling KMSAN hooks for CEA code.
 KMSAN_SANITIZE_cpu_entry_area.o := n
-KDFSAN_SANITIZE_cpu_entry_area.o := n
 
 ifdef CONFIG_FUNCTION_TRACER
 CFLAGS_REMOVE_mem_encrypt.o		= -pg
diff --git a/arch/x86/mm/ioremap.c b/arch/x86/mm/ioremap.c
index 0b63759964aa..aa7d279321ea 100644
--- a/arch/x86/mm/ioremap.c
+++ b/arch/x86/mm/ioremap.c
@@ -18,7 +18,6 @@
 #include <linux/efi.h>
 #include <linux/pgtable.h>
 #include <linux/kmsan.h>
-#include <linux/kdfsan.h>
 
 #include <asm/set_memory.h>
 #include <asm/e820/api.h>
@@ -304,7 +303,6 @@ __ioremap_caller(resource_size_t phys_addr, unsigned long size,
 
 	ret_addr = (void __iomem *) (vaddr + offset);
 	mmiotrace_ioremap(unaligned_phys_addr, unaligned_size, ret_addr);
-	kdfsan_ioremap(phys_addr, ret_addr, (size_t)size);
 
 	/*
 	 * Check if the request spans more than any BAR in the iomem resource
@@ -476,7 +474,6 @@ void iounmap(volatile void __iomem *addr)
 	}
 
 	mmiotrace_iounmap(addr);
-	kdfsan_iounmap((void *)addr);
 
 	addr = (volatile void __iomem *)
 		(PAGE_MASK & (unsigned long __force)addr);
diff --git a/arch/x86/purgatory/Makefile b/arch/x86/purgatory/Makefile
index fcc6c29bce35..08aa0f25f12a 100644
--- a/arch/x86/purgatory/Makefile
+++ b/arch/x86/purgatory/Makefile
@@ -36,7 +36,6 @@ KASAN_SANITIZE	:= n
 UBSAN_SANITIZE	:= n
 KCSAN_SANITIZE	:= n
 KMSAN_SANITIZE	:= n
-KDFSAN_SANITIZE	:= n
 KCOV_INSTRUMENT := n
 
 # These are adjustments to the compiler flags used for objects that
diff --git a/arch/x86/realmode/rm/Makefile b/arch/x86/realmode/rm/Makefile
index b315605c05e6..f614009d3e4e 100644
--- a/arch/x86/realmode/rm/Makefile
+++ b/arch/x86/realmode/rm/Makefile
@@ -11,8 +11,6 @@
 KASAN_SANITIZE			:= n
 KCSAN_SANITIZE			:= n
 KMSAN_SANITIZE			:= n
-KDFSAN_SANITIZE			:= n
-KDFSAN_NO_RUNTIME_wakemain.o	:= y
 OBJECT_FILES_NON_STANDARD	:= y
 
 # Prevents link failures: __sanitizer_cov_trace_pc() is not linked in.
diff --git a/drivers/acpi/acpica/utcksum.c b/drivers/acpi/acpica/utcksum.c
index b0491485164e..b483894c3629 100644
--- a/drivers/acpi/acpica/utcksum.c
+++ b/drivers/acpi/acpica/utcksum.c
@@ -157,7 +157,6 @@ u8 acpi_ut_generate_checksum(void *table, u32 length, u8 original_checksum)
  *
  ******************************************************************************/
 
-__no_kdfsan_taint
 u8 acpi_ut_checksum(u8 *buffer, u32 length)
 {
 	u8 sum = 0;
diff --git a/drivers/firmware/efi/libstub/Makefile b/drivers/firmware/efi/libstub/Makefile
index 8d941c4b2b54..16d64a34d1e1 100644
--- a/drivers/firmware/efi/libstub/Makefile
+++ b/drivers/firmware/efi/libstub/Makefile
@@ -62,7 +62,6 @@ KASAN_SANITIZE			:= n
 KCSAN_SANITIZE			:= n
 KMSAN_SANITIZE			:= n
 UBSAN_SANITIZE			:= n
-KDFSAN_SANITIZE			:= n
 OBJECT_FILES_NON_STANDARD	:= y
 
 # Prevents link failures: __sanitizer_cov_trace_pc() is not linked in.
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index bdff171b0a57..5df370482521 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1269,8 +1269,7 @@ enum xhci_setup_dev {
 
 /* bits 16:23 are the virtual function ID */
 /* bits 24:31 are the slot ID */
-//#define TRB_TO_SLOT_ID(p)	(((p) & (0xff<<24)) >> 24)
-__no_opt static inline u32 TRB_TO_SLOT_ID(u32 p) { return (((p) & (0xff<<24)) >> 24); }
+#define TRB_TO_SLOT_ID(p)	(((p) & (0xff<<24)) >> 24)
 #define SLOT_ID_FOR_TRB(p)	(((p) & 0xff) << 24)
 
 /* Stop Endpoint TRB - ep_index to endpoint ID for this TRB */
diff --git a/include/asm-generic/bug.h b/include/asm-generic/bug.h
index 8f2f6f8835d5..6e794420bd39 100644
--- a/include/asm-generic/bug.h
+++ b/include/asm-generic/bug.h
@@ -5,7 +5,6 @@
 #include <linux/compiler.h>
 #include <linux/instrumentation.h>
 #include <linux/once_lite.h>
-#include <linux/kdfsan.h>
 
 #define CUT_HERE		"------------[ cut here ]------------\n"
 
@@ -69,7 +68,7 @@ struct bug_entry {
 #endif
 
 #ifndef HAVE_ARCH_BUG_ON
-#define BUG_ON(condition) do { long cond = (long)(condition); kdfsan_bugon(dfsan_get_label(cond)); if (unlikely(cond)) BUG(); } while (0)
+#define BUG_ON(condition) do { if (unlikely(condition)) BUG(); } while (0)
 #endif
 
 /*
diff --git a/include/asm-generic/vmlinux.lds.h b/include/asm-generic/vmlinux.lds.h
index 2ca43b649cbc..9c59409104f6 100644
--- a/include/asm-generic/vmlinux.lds.h
+++ b/include/asm-generic/vmlinux.lds.h
@@ -997,7 +997,7 @@
 #else
 #define DISCARD_EH_FRAME	*(.eh_frame)
 #endif
-#if defined(CONFIG_GCOV_KERNEL) || defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KCSAN) || defined(CONFIG_KDFSAN)
+#if defined(CONFIG_GCOV_KERNEL) || defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KCSAN)
 # ifdef CONFIG_CONSTRUCTORS
 #  define SANITIZER_DISCARDS						\
 	DISCARD_EH_FRAME
diff --git a/include/linux/compiler-clang.h b/include/linux/compiler-clang.h
index 17c68d7aae1a..9b673fefcef8 100644
--- a/include/linux/compiler-clang.h
+++ b/include/linux/compiler-clang.h
@@ -14,8 +14,6 @@
 #undef __cleanup
 #define __cleanup(func) __maybe_unused __attribute__((__cleanup__(func)))
 
-#define __no_opt __attribute__((optnone))
-
 /* same as gcc, this was present in clang-2.6 so we can assume it works
  * with any version that can compile the kernel
  */
@@ -85,18 +83,6 @@
 #define __no_kmsan_checks
 #endif
 
-#if __has_feature(dataflow_sanitizer)
-/*
- * The __no_kdfsan_taint attribute ensures that a function does not produce
- * false positive reports by:
- *  - clearing taint of function args, memory loads/stores, and return value;
- *  - not emitting callbacks (which typically implement a taint sink).
- */
-#define __no_kdfsan_taint __attribute__((no_sanitize("dataflow")))
-#else
-#define __no_kdfsan_taint
-#endif
-
 /*
  * Support for __has_feature(coverage_sanitizer) was added in Clang 13 together
  * with no_sanitize("coverage"). Prior versions of Clang support coverage
diff --git a/include/linux/compiler-gcc.h b/include/linux/compiler-gcc.h
index af9f31f0a78b..7af9e34ec261 100644
--- a/include/linux/compiler-gcc.h
+++ b/include/linux/compiler-gcc.h
@@ -45,8 +45,6 @@
 #define __latent_entropy __attribute__((latent_entropy))
 #endif
 
-#define __no_opt __attribute__((optimize(0)))
-
 /*
  * calling noreturn functions, __builtin_unreachable() and __builtin_trap()
  * confuse the stack allocation in gcc, leading to overly large stack
@@ -112,11 +110,10 @@
 #endif
 
 /*
- * GCC does not support KMSAN or KDFSAN.
+ * GCC does not support KMSAN.
  */
 #define __no_sanitize_memory
 #define __no_kmsan_checks
-#define __no_kdfsan_checks
 
 /*
  * Turn individual warnings and errors on and off locally, depending
diff --git a/include/linux/file.h b/include/linux/file.h
index fb627fb0e2c9..6e9099d29343 100644
--- a/include/linux/file.h
+++ b/include/linux/file.h
@@ -11,7 +11,6 @@
 #include <linux/posix_types.h>
 #include <linux/errno.h>
 #include <linux/cleanup.h>
-#include <linux/kdfsan.h>
 
 struct file;
 
@@ -62,7 +61,6 @@ static inline struct fd __to_fd(unsigned long v)
 
 static inline struct fd fdget(unsigned int fd)
 {
-	dfsan_set_label(0, &fd, sizeof(fd));
 	return __to_fd(__fdget(fd));
 }
 
diff --git a/include/linux/gfp_types.h b/include/linux/gfp_types.h
index b3c061418fa2..6583a58670c5 100644
--- a/include/linux/gfp_types.h
+++ b/include/linux/gfp_types.h
@@ -58,13 +58,6 @@ typedef unsigned int __bitwise gfp_t;
 #else
 #define ___GFP_NOLOCKDEP	0
 #endif
-#ifdef CONFIG_KDFSAN
-// Watch out, CONFIG_KASAN_HW_TAGS uses the same shadow value as this.
-#define ___GFP_NO_KDFSAN_SHADOW 0x1000000u
-#else
-#define ___GFP_NO_KDFSAN_SHADOW 0
-#endif
-
 /* If the above are modified, __GFP_BITS_SHIFT may need updating */
 
 /*
@@ -249,7 +242,6 @@ typedef unsigned int __bitwise gfp_t;
 #define __GFP_COMP	((__force gfp_t)___GFP_COMP)
 #define __GFP_ZERO	((__force gfp_t)___GFP_ZERO)
 #define __GFP_ZEROTAGS	((__force gfp_t)___GFP_ZEROTAGS)
-#define __GFP_NO_KDFSAN_SHADOW  ((__force gfp_t)___GFP_NO_KDFSAN_SHADOW)
 #define __GFP_SKIP_ZERO ((__force gfp_t)___GFP_SKIP_ZERO)
 #define __GFP_SKIP_KASAN ((__force gfp_t)___GFP_SKIP_KASAN)
 
@@ -257,14 +249,7 @@ typedef unsigned int __bitwise gfp_t;
 #define __GFP_NOLOCKDEP ((__force gfp_t)___GFP_NOLOCKDEP)
 
 /* Room for N __GFP_FOO bits */
-//#define __GFP_BITS_SHIFT (26 + IS_ENABLED(CONFIG_LOCKDEP))
-#ifdef CONFIG_KDFSAN
-#define __GFP_BITS_SHIFT 28
-#elif defined(CONFIG_LOCKDEP)
-#define __GFP_BITS_SHIFT 27
-#else
-#define __GFP_BITS_SHIFT 26
-#endif
+#define __GFP_BITS_SHIFT (26 + IS_ENABLED(CONFIG_LOCKDEP))
 #define __GFP_BITS_MASK ((__force gfp_t)((1 << __GFP_BITS_SHIFT) - 1))
 
 /**
diff --git a/include/linux/kdfsan.h b/include/linux/kdfsan.h
deleted file mode 100644
index a6c3b31a02bb..000000000000
--- a/include/linux/kdfsan.h
+++ /dev/null
@@ -1,105 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#ifndef LINUX_KDFSAN_H
-#define LINUX_KDFSAN_H
-
-#include <linux/types.h>
-#include <linux/init.h>
-
-struct page;
-typedef unsigned long uptr;
-typedef u16 dfsan_label;
-struct device;
-struct scatterlist;
-struct task_struct;
-#define KDF_DESC_LEN 150
-
-#if !defined(KDFSAN_NO_RUNTIME) && defined(CONFIG_KDFSAN)
-int kdfsan_alloc_page(struct page *page, unsigned int order, gfp_t flags, int node);
-void kdfsan_free_page(struct page *page, unsigned int order);
-void kdfsan_split_page(struct page *page, unsigned int order);
-void kdfsan_copy_page_shadow(struct page *dst, struct page *src);
-void __init kdfsan_init_shadow(void);
-void __init kdfsan_init_runtime(void);
-void kdfsan_task_create(struct task_struct *task);
-void __dfsan_mem_transfer(void *dest, const void *src, uptr size, dfsan_label dest_label, dfsan_label src_label, dfsan_label size_label);
-void __dfsan_mem_transfer_with_rip(void *dest, const void *src, uptr size, dfsan_label dest_label, dfsan_label src_label, dfsan_label size_label, void * rip);
-void dfsan_set_label(dfsan_label label, void *addr, uptr size);
-void dfsan_add_label(dfsan_label label_src, void *addr, uptr size);
-dfsan_label dfsan_create_label(const char *desc, void *userdata);
-int dfsan_has_label(dfsan_label label, dfsan_label elem);
-dfsan_label dfsan_has_label_with_desc(dfsan_label label, const char *desc);
-dfsan_label dfsan_get_label_with_desc(const char *desc);
-size_t dfsan_get_label_descs(dfsan_label label, char descs_arr[][KDF_DESC_LEN], size_t descs_arr_size);
-dfsan_label dfsan_get_label_count(void);
-dfsan_label dfsan_read_label(const void *addr, uptr size);
-dfsan_label dfsan_union(dfsan_label l1, dfsan_label l2);
-dfsan_label dfsan_get_label(long data);
-void kdfsan_syscall_arg(void * arg, size_t s, int arg_num);
-void kdfsan_domain_enter(void);
-void kdfsan_domain_exit(void);
-#else
-static inline int kdfsan_alloc_page(struct page *page, unsigned int order, gfp_t flags, int node) { return 0; }
-static inline void kdfsan_free_page(struct page *page, unsigned int order) { }
-static inline void kdfsan_split_page(struct page *page, unsigned int order) { }
-static inline void kdfsan_copy_page_shadow(struct page *dst, struct page *src) { }
-static inline void __init kdfsan_init_shadow(void) { }
-static inline void __init kdfsan_init_runtime(void) {}
-static inline void kdfsan_task_create(struct task_struct *task) {}
-static inline void __dfsan_mem_transfer(void *dest, const void *src, uptr size, dfsan_label dest_label, dfsan_label src_label, dfsan_label size_label) { }
-static inline void __dfsan_mem_transfer_with_rip(void *dest, const void *src, uptr size, dfsan_label dest_label, dfsan_label src_label, dfsan_label size_label, void * rip) { }
-static inline void dfsan_set_label(dfsan_label label, void *addr, uptr size) { }
-static inline void dfsan_add_label(dfsan_label label_src, void *addr, uptr size) { }
-static inline dfsan_label dfsan_create_label(const char *desc, void *userdata) { return 0; }
-static inline int dfsan_has_label(dfsan_label label, dfsan_label elem) { return 0; }
-static inline dfsan_label dfsan_has_label_with_desc(dfsan_label label, const char *desc) { return 0; }
-static inline dfsan_label dfsan_get_label_with_desc(const char *desc) { return 0; }
-static inline size_t dfsan_get_label_descs(dfsan_label label, char descs_arr[][KDF_DESC_LEN], size_t descs_arr_size) { return 0; }
-static inline dfsan_label dfsan_get_label_count(void) { return 0; }
-static inline dfsan_label dfsan_read_label(const void *addr, uptr size) { return 0; }
-static inline dfsan_label dfsan_union(dfsan_label l1, dfsan_label l2) { return 0; }
-static inline dfsan_label dfsan_get_label(long data) { return 0; }
-static inline void kdfsan_syscall_arg(void * arg, size_t s, int arg_num) { }
-static inline void kdfsan_domain_enter(void) { }
-static inline void kdfsan_domain_exit(void) { }
-#endif
-
-#ifdef KDFSAN_CLEARTAINT
-static __always_inline void dfsan_mem_transfer(void *dest, const void *src, uptr size, dfsan_label dest_label, dfsan_label src_label, dfsan_label size_label) { dfsan_set_label(0, dest, size); }
-static __always_inline void dfsan_mem_transfer_with_rip(void *dest, const void *src, uptr size, dfsan_label dest_label, dfsan_label src_label, dfsan_label size_label, void * rip) { dfsan_set_label(0, dest, size); }
-#else
-static __always_inline void dfsan_mem_transfer(void *dest, const void *src, uptr size, dfsan_label dest_label, dfsan_label src_label, dfsan_label size_label) { __dfsan_mem_transfer(dest, src, size, dest_label, src_label, size_label); }
-static __always_inline void dfsan_mem_transfer_with_rip(void *dest, const void *src, uptr size, dfsan_label dest_label, dfsan_label src_label, dfsan_label size_label, void * rip) { __dfsan_mem_transfer_with_rip(dest, src, size, dest_label, src_label, size_label, rip); }
-#endif
-
-#if !defined(KDFSAN_NO_RUNTIME) && defined(CONFIG_KDFSAN_DOUBLEFETCH_POLICIES)
-void kdfsan_dma_alloc(struct device *dev, dma_addr_t bus_addr, void * cpu_addr, size_t s, bool is_streaming_dma);
-void kdfsan_dma_free(struct device *dev, dma_addr_t bus_addr);
-void kdfsan_dma_alloc_sg(struct device *dev, struct scatterlist *sg, int ents);
-void kdfsan_dma_free_sg(struct device *dev, struct scatterlist *sg, int nents);
-void kdfsan_dma_sync(struct device *dev, dma_addr_t addr, size_t size, bool is_for_cpu);
-void kdfsan_dma_sync_sg(struct device *dev, struct scatterlist *sg, int nelems, bool is_for_cpu);
-void kdfsan_ioremap(resource_size_t bus_addr, void __iomem *cpu_addr, size_t size);
-void kdfsan_iounmap(void __iomem *cpu_addr);
-void kdfsan_pmio_out(void *src, u16 port, size_t size, dfsan_label src_label, dfsan_label port_label, dfsan_label size_label);
-void kdfsan_pmio_out_with_rip(void *src, u16 port, size_t size, dfsan_label src_label, dfsan_label port_label, dfsan_label size_label, void * caller_rip);
-void kdfsan_pmio_in(u16 port, size_t size, void *dest, dfsan_label port_label, dfsan_label size_label, dfsan_label dest_label);
-void kdfsan_pmio_in_with_rip(u16 port, size_t size, void *dest, dfsan_label port_label, dfsan_label size_label, dfsan_label dest_label, void * caller_rip);
-void kdfsan_bugon(dfsan_label label);
-#else
-static inline void kdfsan_dma_alloc(struct device *dev, dma_addr_t bus_addr, void * cpu_addr, size_t s, bool is_streaming_dma) { }
-static inline void kdfsan_dma_free(struct device *dev, dma_addr_t bus_addr) { }
-static inline void kdfsan_dma_alloc_sg(struct device *dev, struct scatterlist *sg, int ents) { }
-static inline void kdfsan_dma_free_sg(struct device *dev, struct scatterlist *sg, int nents) { }
-static inline void kdfsan_dma_sync(struct device *dev, dma_addr_t addr, size_t size, bool is_for_cpu) { }
-static inline void kdfsan_dma_sync_sg(struct device *dev, struct scatterlist *sg, int nelems, bool is_for_cpu) { }
-static inline void kdfsan_ioremap(resource_size_t bus_addr, void __iomem *cpu_addr, size_t size) { }
-static inline void kdfsan_iounmap(void __iomem *cpu_addr) { }
-static inline void kdfsan_pmio_out(void *src, u16 port, size_t size, dfsan_label src_label, dfsan_label port_label, dfsan_label size_label) { }
-static inline void kdfsan_pmio_out_with_rip(void *src, u16 port, size_t size, dfsan_label src_label, dfsan_label port_label, dfsan_label size_label, void * caller_rip) { }
-static inline void kdfsan_pmio_in(u16 port, size_t size, void *dest, dfsan_label port_label, dfsan_label size_label, dfsan_label dest_label) { }
-static inline void kdfsan_pmio_in_with_rip(u16 port, size_t size, void *dest, dfsan_label port_label, dfsan_label size_label, dfsan_label dest_label, void * caller_rip) { }
-static inline void kdfsan_bugon(dfsan_label label) { }
-#endif
-
-#endif /* LINUX_KDFSAN_H */
diff --git a/include/linux/kdfsan_types.h b/include/linux/kdfsan_types.h
deleted file mode 100644
index 3bfcaac3f2cf..000000000000
--- a/include/linux/kdfsan_types.h
+++ /dev/null
@@ -1,42 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#ifndef LINUX_KDFSAN_TYPES_H
-#define LINUX_KDFSAN_TYPES_H
-
-#include <linux/kdfsan.h>
-#include <linux/maple_tree.h>
-
-static const uptr INTERNAL_LABEL_LOG_BIT_WIDTH = 3; // {0,1,2,3,4} <--- CHANGE THIS TO ADJUST SHADOW MEM SIZE
-static const uptr INTERNAL_LABEL_BIT_WIDTH = (1 << INTERNAL_LABEL_LOG_BIT_WIDTH); // {1,2,4,8,16}
-static const uptr NUM_LABELS = (1 << INTERNAL_LABEL_BIT_WIDTH); // {0x2,0x4,0x10,0x100,0x10000}
-static const uptr INTERNAL_LABEL_ADDR_MASK = (INTERNAL_LABEL_LOG_BIT_WIDTH < 4) ? (1<<(3-INTERNAL_LABEL_LOG_BIT_WIDTH))-1 : 0; // {0x7,0x3,0x1,0x0,0x0}
-static const uptr INTERNAL_LABEL_MASK = (NUM_LABELS - 1); // {0x1,0x3,0xf,0xff,0xffff}
-
-// TODO: Set these based on the policy specified by the KDFSAN pass. For now, just use the default settings.
-static const bool PROPAGATE_STORE_PTR = false;
-static const bool PROPAGATE_LOAD_PTR = true;
-
-/* KDFSAN argument and retval context structs. */
-#define KDFSAN_PARAM_SIZE 64
-
-struct kdfsan_context_state {
-  dfsan_label __dfsan_retval_tls;
-  dfsan_label __dfsan_arg_tls[KDFSAN_PARAM_SIZE];
-};
-
-static const uptr MAX_TOTAL_REPORTS = NUM_LABELS * 32; // This is arbitrary...
-struct kdfsan_policies_state {
-  bool initialized;
-  struct maple_tree fetches;
-  struct maple_tree fetch_ptrs; // Janky way of tracking pointers in the fetches tree, so we can just free all of them when exiting the domain
-  bool reports_covered[MAX_TOTAL_REPORTS];
-};
-
-struct kdfsan_ctx {
-  struct kdfsan_context_state cstate;
-  int kdfsan_in_runtime;
-  bool allow_reporting; // TODO for future use
-  struct kdfsan_policies_state pstate;
-};
-
-#endif /* LINUX_KDFSAN_TYPES_H */
diff --git a/include/linux/linkage.h b/include/linux/linkage.h
index f9674069fc86..5c8865bb59d9 100644
--- a/include/linux/linkage.h
+++ b/include/linux/linkage.h
@@ -23,13 +23,17 @@
 #endif
 
 #ifndef cond_syscall
-#define cond_syscall(x)	\
-  long x(void) __attribute__((weak, alias(__stringify(sys_ni_syscall))))
+#define cond_syscall(x)	asm(				\
+	".weak " __stringify(x) "\n\t"			\
+	".set  " __stringify(x) ","			\
+		 __stringify(sys_ni_syscall))
 #endif
 
 #ifndef SYSCALL_ALIAS
-#define SYSCALL_ALIAS(aka, name) \
-  long aka(void) __attribute__((alias(__stringify(name))))
+#define SYSCALL_ALIAS(alias, name) asm(			\
+	".globl " __stringify(alias) "\n\t"		\
+	".set   " __stringify(alias) ","		\
+		  __stringify(name))
 #endif
 
 #define __page_aligned_data	__section(".data..page_aligned") __aligned(PAGE_SIZE)
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index b69df66feb6f..7d30dc4ff0ff 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -224,9 +224,6 @@ struct page {
 	struct page *kmsan_shadow;
 	struct page *kmsan_origin;
 #endif
-#ifdef CONFIG_KDFSAN
-        struct page *shadow;
-#endif
 
 #ifdef LAST_CPUPID_NOT_IN_PAGE_FLAGS
 	int _last_cpupid;
diff --git a/include/linux/sched.h b/include/linux/sched.h
index ec282d26c5bf..609bde814cb0 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -15,7 +15,6 @@
 #include <linux/sem.h>
 #include <linux/shm.h>
 #include <linux/kmsan_types.h>
-#include <linux/kdfsan_types.h>
 #include <linux/mutex.h>
 #include <linux/plist.h>
 #include <linux/hrtimer.h>
@@ -1372,10 +1371,6 @@ struct task_struct {
 	struct kmsan_ctx		kmsan_ctx;
 #endif
 
-#ifdef CONFIG_KDFSAN
-	struct kdfsan_ctx		kdfsan_ctx;
-#endif
-
 #if IS_ENABLED(CONFIG_KUNIT)
 	struct kunit			*kunit_test;
 #endif
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index c16110b0dd70..03e3d0121d5e 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -128,21 +128,6 @@ struct cachestat;
 #define __SC_ARGS(t, a)	a
 #define __SC_TEST(t, a) (void)BUILD_BUG_ON_ZERO(!__TYPE_IS_LL(t) && sizeof(t) > sizeof(long))
 
-#define __MAPN0(n,m,...)
-#define __MAPN1(n,m,t,a,...) m(t,a,n-1)
-#define __MAPN2(n,m,t,a,...) m(t,a,n-2), __MAPN1(n,m,__VA_ARGS__)
-#define __MAPN3(n,m,t,a,...) m(t,a,n-3), __MAPN2(n,m,__VA_ARGS__)
-#define __MAPN4(n,m,t,a,...) m(t,a,n-4), __MAPN3(n,m,__VA_ARGS__)
-#define __MAPN5(n,m,t,a,...) m(t,a,n-5), __MAPN4(n,m,__VA_ARGS__)
-#define __MAPN6(n,m,t,a,...) m(t,a,n-6), __MAPN5(n,m,__VA_ARGS__)
-#define __MAPN(n,...) __MAPN##n(n,__VA_ARGS__)
-#ifdef CONFIG_KDFSAN
-#include <linux/kdfsan.h>
-#define __SC_KDF_TAINT(t,a,n) kdfsan_syscall_arg((void*)&a,sizeof(t),n)
-#else
-#define __SC_KDF_TAINT(t,a,n) (void)0
-#endif
-
 #ifdef CONFIG_FTRACE_SYSCALLS
 #define __SC_STR_ADECL(t, a)	#a
 #define __SC_STR_TDECL(t, a)	#t
diff --git a/init/main.c b/init/main.c
index 5e836d228a93..ad920fac325c 100644
--- a/init/main.c
+++ b/init/main.c
@@ -796,7 +796,6 @@ static inline void initcall_debug_enable(void)
 #endif
 
 #ifdef CONFIG_RANDOMIZE_KSTACK_OFFSET
-
 DEFINE_STATIC_KEY_MAYBE_RO(CONFIG_RANDOMIZE_KSTACK_OFFSET_DEFAULT,
 			   randomize_kstack_offset);
 DEFINE_PER_CPU(u32, kstack_offset);
diff --git a/ipc/sem.c b/ipc/sem.c
index bf6695ec9dcc..00f88aa01ac5 100644
--- a/ipc/sem.c
+++ b/ipc/sem.c
@@ -87,7 +87,6 @@
 #include <linux/sched/wake_q.h>
 #include <linux/nospec.h>
 #include <linux/rhashtable.h>
-#include <linux/kdfsan.h>
 
 #include <linux/uaccess.h>
 #include "util.h"
@@ -478,7 +477,6 @@ static inline void sem_unlock(struct sem_array *sma, int locknum)
  */
 static inline struct sem_array *sem_obtain_object(struct ipc_namespace *ns, int id)
 {
-	dfsan_set_label(0, &id, sizeof(id));
 	struct kern_ipc_perm *ipcp = ipc_obtain_object_idr(&sem_ids(ns), id);
 
 	if (IS_ERR(ipcp))
@@ -490,7 +488,6 @@ static inline struct sem_array *sem_obtain_object(struct ipc_namespace *ns, int
 static inline struct sem_array *sem_obtain_object_check(struct ipc_namespace *ns,
 							int id)
 {
-	dfsan_set_label(0, &id, sizeof(id));
 	struct kern_ipc_perm *ipcp = ipc_obtain_object_check(&sem_ids(ns), id);
 
 	if (IS_ERR(ipcp))
diff --git a/kernel/Makefile b/kernel/Makefile
index 8bb155a8748a..3947122d618b 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -39,7 +39,6 @@ KASAN_SANITIZE_kcov.o := n
 KCSAN_SANITIZE_kcov.o := n
 UBSAN_SANITIZE_kcov.o := n
 KMSAN_SANITIZE_kcov.o := n
-KDFSAN_SANITIZE_kcov.o := n
 CFLAGS_kcov.o := $(call cc-option, -fno-conserve-stack) -fno-stack-protector
 
 obj-y += sched/
diff --git a/kernel/dma/mapping.c b/kernel/dma/mapping.c
index 09d244f37658..9a4db5cce600 100644
--- a/kernel/dma/mapping.c
+++ b/kernel/dma/mapping.c
@@ -14,7 +14,6 @@
 #include <linux/of_device.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
-#include <linux/kdfsan.h>
 #include "debug.h"
 #include "direct.h"
 
@@ -164,7 +163,6 @@ dma_addr_t dma_map_page_attrs(struct device *dev, struct page *page,
 		addr = ops->map_page(dev, page, offset, size, dir, attrs);
 	kmsan_handle_dma(page, offset, size, dir);
 	debug_dma_map_page(dev, page, offset, size, dir, addr, attrs);
-	kdfsan_dma_alloc(dev, addr, page_to_virt(page)+offset, size, true);
 
 	return addr;
 }
@@ -173,7 +171,6 @@ EXPORT_SYMBOL(dma_map_page_attrs);
 void dma_unmap_page_attrs(struct device *dev, dma_addr_t addr, size_t size,
 		enum dma_data_direction dir, unsigned long attrs)
 {
-	kdfsan_dma_free(dev, addr);
 	const struct dma_map_ops *ops = get_dma_ops(dev);
 
 	BUG_ON(!valid_dma_direction(dir));
@@ -206,7 +203,6 @@ static int __dma_map_sg_attrs(struct device *dev, struct scatterlist *sg,
 	if (ents > 0) {
 		kmsan_handle_dma_sg(sg, nents, dir);
 		debug_dma_map_sg(dev, sg, nents, ents, dir, attrs);
-		kdfsan_dma_alloc_sg(dev, sg, ents);
 	} else if (WARN_ON_ONCE(ents != -EINVAL && ents != -ENOMEM &&
 				ents != -EIO && ents != -EREMOTEIO)) {
 		return -EIO;
@@ -288,7 +284,6 @@ void dma_unmap_sg_attrs(struct device *dev, struct scatterlist *sg,
 				      int nents, enum dma_data_direction dir,
 				      unsigned long attrs)
 {
-	kdfsan_dma_free_sg(dev, sg, nents);
 	const struct dma_map_ops *ops = get_dma_ops(dev);
 
 	BUG_ON(!valid_dma_direction(dir));
@@ -345,7 +340,6 @@ void dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr, size_t size,
 	else if (ops->sync_single_for_cpu)
 		ops->sync_single_for_cpu(dev, addr, size, dir);
 	debug_dma_sync_single_for_cpu(dev, addr, size, dir);
-	kdfsan_dma_sync(dev, addr, size, true);
 }
 EXPORT_SYMBOL(dma_sync_single_for_cpu);
 
@@ -360,7 +354,6 @@ void dma_sync_single_for_device(struct device *dev, dma_addr_t addr,
 	else if (ops->sync_single_for_device)
 		ops->sync_single_for_device(dev, addr, size, dir);
 	debug_dma_sync_single_for_device(dev, addr, size, dir);
-	kdfsan_dma_sync(dev, addr, size, false);
 }
 EXPORT_SYMBOL(dma_sync_single_for_device);
 
@@ -375,7 +368,6 @@ void dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,
 	else if (ops->sync_sg_for_cpu)
 		ops->sync_sg_for_cpu(dev, sg, nelems, dir);
 	debug_dma_sync_sg_for_cpu(dev, sg, nelems, dir);
-	kdfsan_dma_sync_sg(dev, sg, nelems, true);
 }
 EXPORT_SYMBOL(dma_sync_sg_for_cpu);
 
@@ -390,7 +382,6 @@ void dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,
 	else if (ops->sync_sg_for_device)
 		ops->sync_sg_for_device(dev, sg, nelems, dir);
 	debug_dma_sync_sg_for_device(dev, sg, nelems, dir);
-	kdfsan_dma_sync_sg(dev, sg, nelems, false);
 }
 EXPORT_SYMBOL(dma_sync_sg_for_device);
 
@@ -533,7 +524,6 @@ void *dma_alloc_attrs(struct device *dev, size_t size, dma_addr_t *dma_handle,
 		return NULL;
 
 	debug_dma_alloc_coherent(dev, size, *dma_handle, cpu_addr, attrs);
-	kdfsan_dma_alloc(dev, *dma_handle, cpu_addr, size, false);
 	return cpu_addr;
 }
 EXPORT_SYMBOL(dma_alloc_attrs);
@@ -541,7 +531,6 @@ EXPORT_SYMBOL(dma_alloc_attrs);
 void dma_free_attrs(struct device *dev, size_t size, void *cpu_addr,
 		dma_addr_t dma_handle, unsigned long attrs)
 {
-	kdfsan_dma_free(dev, dma_handle);
 	const struct dma_map_ops *ops = get_dma_ops(dev);
 
 	if (dma_release_from_dev_coherent(dev, get_order(size), cpu_addr))
diff --git a/kernel/entry/common.c b/kernel/entry/common.c
index a59e2af26e29..be61332c66b5 100644
--- a/kernel/entry/common.c
+++ b/kernel/entry/common.c
@@ -6,7 +6,6 @@
 #include <linux/highmem.h>
 #include <linux/jump_label.h>
 #include <linux/kmsan.h>
-#include <linux/kdfsan.h>
 #include <linux/livepatch.h>
 #include <linux/audit.h>
 #include <linux/tick.h>
@@ -27,7 +26,6 @@ static __always_inline void __enter_from_user_mode(struct pt_regs *regs)
 
 	instrumentation_begin();
 	kmsan_unpoison_entry_regs(regs);
-	kdfsan_domain_enter();
 	trace_hardirqs_off_finish();
 	instrumentation_end();
 }
@@ -129,7 +127,6 @@ noinstr void syscall_enter_from_user_mode_prepare(struct pt_regs *regs)
 static __always_inline void __exit_to_user_mode(void)
 {
 	instrumentation_begin();
-	kdfsan_domain_exit();
 	trace_hardirqs_on_prepare();
 	lockdep_hardirqs_on_prepare();
 	instrumentation_end();
diff --git a/kernel/fork.c b/kernel/fork.c
index c3b5453f0cb0..f81149739eb9 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -38,7 +38,6 @@
 #include <linux/iocontext.h>
 #include <linux/key.h>
 #include <linux/kmsan.h>
-#include <linux/kdfsan.h>
 #include <linux/binfmts.h>
 #include <linux/mman.h>
 #include <linux/mmu_notifier.h>
@@ -1172,7 +1171,6 @@ static struct task_struct *dup_task_struct(struct task_struct *orig, int node)
 
 	kcov_task_init(tsk);
 	kmsan_task_create(tsk);
-	kdfsan_task_create(tsk);
 	kmap_local_fork(tsk);
 
 #ifdef CONFIG_FAULT_INJECTION
diff --git a/kernel/pid.c b/kernel/pid.c
index 645df6c54dc1..fee14a4486a3 100644
--- a/kernel/pid.c
+++ b/kernel/pid.c
@@ -42,7 +42,6 @@
 #include <linux/sched/signal.h>
 #include <linux/sched/task.h>
 #include <linux/idr.h>
-#include <linux/kdfsan.h>
 #include <net/sock.h>
 #include <uapi/linux/pidfd.h>
 
@@ -423,7 +422,6 @@ struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)
 
 struct task_struct *find_task_by_vpid(pid_t vnr)
 {
-	dfsan_set_label(0, &vnr, sizeof(vnr));
 	return find_task_by_pid_ns(vnr, task_active_pid_ns(current));
 }
 
diff --git a/kernel/printk/internal.h b/kernel/printk/internal.h
index 38ab2f0d5cb8..7d4979d5c3ce 100644
--- a/kernel/printk/internal.h
+++ b/kernel/printk/internal.h
@@ -24,10 +24,10 @@ int devkmsg_sysctl_set_loglvl(struct ctl_table *table, int write,
  * the maximum size of a formatted record (i.e. with prefix added
  * per line and dropped messages or in extended message format)
  */
-#define PRINTK_MESSAGE_MAX	131071
+#define PRINTK_MESSAGE_MAX	2048
 
 /* the maximum size allowed to be reserved for a record */
-#define PRINTKRB_RECORD_MAX	65535
+#define PRINTKRB_RECORD_MAX	1024
 
 /* Flags for a single printk record. */
 enum printk_info_flags {
diff --git a/kernel/softirq.c b/kernel/softirq.c
index e1462485a066..807b34ccd797 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -595,7 +595,6 @@ void irq_enter_rcu(void)
 		tick_irq_enter();
 
 	account_hardirq_enter(current);
-	kdfsan_domain_enter();
 }
 
 /**
@@ -622,7 +621,6 @@ static inline void tick_irq_exit(void)
 
 static inline void __irq_exit_rcu(void)
 {
-	kdfsan_domain_exit();
 #ifndef __ARCH_IRQ_EXIT_IRQS_DISABLED
 	local_irq_disable();
 #else
diff --git a/kernel/time/Makefile b/kernel/time/Makefile
index 9b5e8c296f69..7e875e63ff3b 100644
--- a/kernel/time/Makefile
+++ b/kernel/time/Makefile
@@ -23,5 +23,3 @@ obj-$(CONFIG_TEST_UDELAY)			+= test_udelay.o
 obj-$(CONFIG_TIME_NS)				+= namespace.o
 obj-$(CONFIG_TEST_CLOCKSOURCE_WATCHDOG)		+= clocksource-wdtest.o
 obj-$(CONFIG_TIME_KUNIT_TEST)			+= time_test.o
-
-KDFSAN_CLEARTAINT := y
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index 87f7c1214565..d6798513a8c2 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -960,7 +960,6 @@ config DEBUG_STACKOVERFLOW
 source "lib/Kconfig.kasan"
 source "lib/Kconfig.kfence"
 source "lib/Kconfig.kmsan"
-source "lib/Kconfig.kdfsan"
 
 endmenu # "Memory Debugging"
 
diff --git a/lib/Kconfig.kdfsan b/lib/Kconfig.kdfsan
deleted file mode 100644
index 011205ac89e2..000000000000
--- a/lib/Kconfig.kdfsan
+++ /dev/null
@@ -1,23 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-
-config HAVE_ARCH_KDFSAN
-  bool
-
-config KDFSAN
-  bool "DataFlowSanitizer : generalised dynamic data flow analysis"
-  default n
-  depends on HAVE_ARCH_KDFSAN
-  select STACKDEPOT
-  select STACKDEPOT_ALWAYS_INIT
-
-if KDFSAN
-
-config KDFSAN_USERSPACE_POLICIES
-  bool "DataFlowSanitizer : trigger to enable userspace tainting policies"
-  default n
-
-config KDFSAN_DOUBLEFETCH_POLICIES
-  bool "DataFlowSanitizer : trigger to enable double-fetch tainting policies"
-  default n
-
-endif
diff --git a/lib/Kconfig.kmsan b/lib/Kconfig.kmsan
index ef2c8f256c57..b65676b638f4 100644
--- a/lib/Kconfig.kmsan
+++ b/lib/Kconfig.kmsan
@@ -5,14 +5,15 @@ config HAVE_ARCH_KMSAN
 config HAVE_KMSAN_COMPILER
 	# Clang versions <14.0.0 also support -fsanitize=kernel-memory, but not
 	# all the features necessary to build the kernel with KMSAN.
-	depends on CC_IS_CLANG && CLANG_VERSION >= 140000
-	def_bool $(cc-option,-fsanitize=kernel-memory -mllvm -msan-disable-checks=1)
+	default y
+  def_bool $(cc-option,-fsanitize=kernel-memory -mllvm -msan-disable-checks=1)
 
 config KMSAN
 	bool "KMSAN: detector of uninitialized values use"
-	depends on HAVE_ARCH_KMSAN && HAVE_KMSAN_COMPILER
-	depends on SLUB && DEBUG_KERNEL && !KASAN && !KCSAN
-	depends on !PREEMPT_RT
+  default y
+  depends on HAVE_ARCH_KMSAN && HAVE_KMSAN_COMPILER
+  depends on SLUB && !KASAN && !KCSAN
+  depends on !PREEMPT_RT
 	select STACKDEPOT
 	select STACKDEPOT_ALWAYS_INIT
 	help
diff --git a/lib/Makefile b/lib/Makefile
index 86b7791add80..1ffae65bb7ee 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -69,11 +69,6 @@ obj-$(CONFIG_TEST_IDA) += test_ida.o
 obj-$(CONFIG_TEST_UBSAN) += test_ubsan.o
 CFLAGS_test_ubsan.o += $(call cc-disable-warning, vla)
 UBSAN_SANITIZE_test_ubsan.o := y
-obj-$(CONFIG_KDFSAN) += test_kdfsan_base.o test_kdfsan_policies.o
-KASAN_SANITIZE_test_kdfsan_base.o := n
-KASAN_SANITIZE_test_kdfsan_policies.o := n
-CFLAGS_test_kdfsan_base.o = -O0  -Wframe-larger-than=4096 -Wno-everything
-CFLAGS_test_kdfsan_policies.o = -O2  -Wframe-larger-than=4096 
 obj-$(CONFIG_TEST_KSTRTOX) += test-kstrtox.o
 obj-$(CONFIG_TEST_LIST_SORT) += test_list_sort.o
 obj-$(CONFIG_TEST_MIN_HEAP) += test_min_heap.o
@@ -293,10 +288,6 @@ KASAN_SANITIZE_stackdepot.o := n
 # recursion.
 KMSAN_SANITIZE_stackdepot.o := n
 KCOV_INSTRUMENT_stackdepot.o := n
-KDFSAN_SANITIZE_stackdepot.o := n
-
-KCOV_INSTRUMENT_maple_tree.o := n
-KDFSAN_SANITIZE_maple_tree.o := n
 
 obj-$(CONFIG_REF_TRACKER) += ref_tracker.o
 
diff --git a/lib/iomap.c b/lib/iomap.c
index 3ff230c68e21..4f8b31baa575 100644
--- a/lib/iomap.c
+++ b/lib/iomap.c
@@ -10,111 +10,6 @@
 
 #include <linux/export.h>
 
-#ifdef CONFIG_KDFSAN
-
-#undef build_mmio_read
-#undef build_mmio_write
-
-#define build_mmio_read(name, size, type, reg, barrier) \
-noinline type name(const volatile void __iomem *addr) \
-{ type ret; asm volatile("mov" size " %1,%0":reg (ret) \
-:"m" (*(volatile type __force *)addr) barrier); \
-dfsan_mem_transfer_with_rip(&ret, (void*)addr, sizeof(type), 0, dfsan_get_label((long)addr), 0,  __builtin_return_address(0)); \
-return ret; } \
-\
-noinline type name##_ret(const volatile void __iomem *addr) \
-{ type ret; asm volatile("mov" size " %1,%0":reg (ret) \
-:"m" (*(volatile type __force *)addr) barrier); \
-dfsan_mem_transfer_with_rip(&ret, (void*)addr, sizeof(type), 0, dfsan_get_label((long)addr), 0,  __builtin_return_address(1)); \
-return ret; }
-
-#define build_mmio_write(name, size, type, reg, barrier) \
-noinline void name(type val, volatile void __iomem *addr) \
-{ asm volatile("mov" size " %0,%1": :reg (val), \
-"m" (*(volatile type __force *)addr) barrier); \
-dfsan_mem_transfer_with_rip((void*)addr, &val, sizeof(type), dfsan_get_label((long)addr), 0, 0,  __builtin_return_address(0)); } \
-\
-noinline void name##_ret(type val, volatile void __iomem *addr) \
-{ asm volatile("mov" size " %0,%1": :reg (val), \
-"m" (*(volatile type __force *)addr) barrier); \
-dfsan_mem_transfer_with_rip((void*)addr, &val, sizeof(type), dfsan_get_label((long)addr), 0, 0,  __builtin_return_address(1)); }
-
-build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
-build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
-build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
-
-build_mmio_read(__readb, "b", unsigned char, "=q", )
-build_mmio_read(__readw, "w", unsigned short, "=r", )
-build_mmio_read(__readl, "l", unsigned int, "=r", )
-
-build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
-build_mmio_write(writew, "w", unsigned short, "r", :"memory")
-build_mmio_write(writel, "l", unsigned int, "r", :"memory")
-
-build_mmio_write(__writeb, "b", unsigned char, "q", )
-build_mmio_write(__writew, "w", unsigned short, "r", )
-build_mmio_write(__writel, "l", unsigned int, "r", )
-
-build_mmio_read(readq, "q", u64, "=r", :"memory")
-build_mmio_read(__readq, "q", u64, "=r", )
-build_mmio_write(writeq, "q", u64, "r", :"memory")
-build_mmio_write(__writeq, "q", u64, "r", )
-
-#undef readb
-#undef readw
-#undef readl
-#undef readb_relaxed
-#undef readw_relaxed
-#undef readl_relaxed
-#undef __raw_readb
-#undef __raw_readw
-#undef __raw_readl
-#define readb readb_ret
-#define readw readw_ret
-#define readl readl_ret
-#define readb_relaxed(a) __readb_ret(a)
-#define readw_relaxed(a) __readw_ret(a)
-#define readl_relaxed(a) __readl_ret(a)
-#define __raw_readb __readb_ret
-#define __raw_readw __readw_ret
-#define __raw_readl __readl_ret
-
-#undef writeb
-#undef writew
-#undef writel
-#undef writeb_relaxed
-#undef writew_relaxed
-#undef writel_relaxed
-#undef __raw_writeb
-#undef __raw_writew
-#undef __raw_writel
-#define writeb writeb_ret
-#define writew writew_ret
-#define writel writel_ret
-#define writeb_relaxed(v, a) __writeb_ret(v, a)
-#define writew_relaxed(v, a) __writew_ret(v, a)
-#define writel_relaxed(v, a) __writel_ret(v, a)
-#define __raw_writeb __writeb_ret
-#define __raw_writew __writew_ret
-#define __raw_writel __writel_ret
-
-#undef readq_relaxed
-#undef writeq_relaxed
-#undef __raw_readq
-#undef __raw_writeq
-#undef readq
-#undef writeq
-#define readq_relaxed(a)	__readq_ret(a)
-#define writeq_relaxed(v, a)	__writeq_ret(v, a)
-#define __raw_readq		__readq_ret
-#define __raw_writeq		__writeq_ret
-#define readq			readq_ret
-#define writeq			writeq_ret
-
-// TODO: Add '_ret' for PMIO in/out?
-
-#endif
-
 /*
  * Read/write from/to an (offsettable) iomem cookie. It might be a PIO
  * access or a MMIO access, these functions don't care. The info is
diff --git a/lib/test_kdfsan_base.c b/lib/test_kdfsan_base.c
deleted file mode 100644
index f09891bb5416..000000000000
--- a/lib/test_kdfsan_base.c
+++ /dev/null
@@ -1,675 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#include <linux/kdfsan.h>
-#include <linux/string.h>
-#include <linux/printk.h>
-#include <linux/mman.h>
-#include <linux/slab.h>
-
-static bool kdf_tests_fail = false;
-
-#define TEST_PANIC_ON(cond, ...) \
-do { \
-  if(cond) { \
-    panic(__VA_ARGS__); \
-  } \
-} while(0)
-
-#define ASSERT(x) \
-do {    if (x) break; \
-        printk(KERN_EMERG "### ASSERTION FAILED %s: %s: %d: %s\n", \
-               __FILE__, __func__, __LINE__, #x); \
-        kdf_tests_fail = true;  \
-} while (0)
-
-static bool check_mem(char * arr, size_t size, char x) {
-  for(int i = 0; i < size; i++) {
-    if(arr[i] != x)
-      return false;
-  }
-  return true;
-}
-
-static void clear_mem(char * arr, size_t size) {
-  memset(arr, 0, size);
-  dfsan_set_label(0, arr, size);
-  ASSERT(check_mem(arr, size, 0));
-  ASSERT(dfsan_read_label(arr, size) == 0);
-}
-
-/****************/
-
-static void testbase_init(void) {
-  printk("    KDFSan: Running init test...\n");
-  int a;
-
-  int a_read_label = dfsan_read_label(&a, sizeof(a));
-  //printk("read_uninit_label (%d) == 0?\n",a_read_label);
-  ASSERT(a_read_label == 0);
-
-  a = -1; // gets rid of uninit usage warning
-
-  int a_this_label = dfsan_get_label(a);
-  //printk("this_uninit_label (%d) == 0?\n",a_this_label);
-  ASSERT(a_this_label == 0);
-}
-
-/****************/
-
-static void testbase_shadow_at(int* ptr) {
-  //printk("ptr = %px\n",ptr);
-  ASSERT(dfsan_get_label(*ptr) == 0);
-
-  dfsan_label this_label = dfsan_create_label("a1", 0);
-  ASSERT(this_label != 0);
-  dfsan_set_label(this_label, ptr, sizeof(*ptr));
-
-  dfsan_label new_this_label = dfsan_get_label(*ptr);
-  //printk("this_label (%d) == new_this_label (%d)?\n",this_label,new_this_label);
-  ASSERT(this_label == new_this_label);
-
-  dfsan_label read_this_label = dfsan_read_label(ptr, sizeof(*ptr));
-  //printk("this_label (%d) == read_this_label (%d)?\n",this_label,read_this_label);
-  ASSERT(this_label == read_this_label);
-}
-
-int b = 1;
-static void testbase_shadow(void) {
-  printk("    KDFSan: Running shadow test for stack...\n");
-  int i = 1;
-  testbase_shadow_at(&i);
-
-  printk("    KDFSan: Running shadow test for heap...\n");
-  int* a_p = kzalloc(sizeof(int),GFP_KERNEL);
-  *a_p = 1;
-  testbase_shadow_at(a_p);
-  kfree(a_p);
-
-  printk("    KDFSan: Running shadow test for .data section...\n");
-  testbase_shadow_at(&b);
-}
-
-/****************/
-
-static void testbase_basic(void) {
-  printk("    KDFSan: Running basic test...\n");
-
-  int i = 1;
-  dfsan_label i_label = dfsan_create_label("i2", 0);
-  ASSERT(i_label != 0);
-  dfsan_set_label(i_label, &i, sizeof(i));
-
-  dfsan_label new_label = dfsan_get_label(i);
-  //printk("i_label (%d) == new_label (%d)?\n",i_label,new_label);
-  ASSERT(i_label == new_label);
-
-  dfsan_label read_label = dfsan_read_label(&i, sizeof(i));
-  //printk("i_label (%d) == read_label (%d)?\n",i_label,read_label);
-  ASSERT(i_label == read_label);
-
-  // Union tests
-  dfsan_label j_label = dfsan_create_label("j2", 0);
-  ASSERT(j_label != 0);
-  dfsan_add_label(j_label, &i, sizeof(i));
-
-  read_label = dfsan_read_label(&i, sizeof(i));
-  //printk("read_label (%d) has i_label (%d)?\n",read_label,i_label);
-  ASSERT(dfsan_has_label(read_label, i_label));
-  //printk("read_label (%d) has j_label (%d)?\n",read_label,j_label);
-  ASSERT(dfsan_has_label(read_label, j_label));
-}
-
-/****************/
-
-static int testbase_fn_callee(int x) {
-  int j = 2;
-  dfsan_label j_label = dfsan_create_label("j3", 0);
-  ASSERT(j_label != 0);
-  dfsan_set_label(j_label, &j, sizeof(j));
-  int ret = x + j;
-  return ret;
-}
-
-static void testbase_fn_caller(void) {
-  printk("    KDFSan: Running function call test...\n");
-  int i = 1;
-  dfsan_label i_label = dfsan_create_label("i3", 0);
-  ASSERT(i_label != 0);
-  dfsan_set_label(i_label, &i, sizeof(i));
-
-  dfsan_label ij_label = dfsan_get_label(testbase_fn_callee(i));
-  ASSERT(dfsan_has_label(ij_label, i_label));
-  ASSERT(dfsan_has_label_with_desc(ij_label, "j3"));
-  ASSERT(dfsan_has_label_with_desc(ij_label, "i3"));
-  ASSERT(!dfsan_has_label_with_desc(ij_label, "foo3"));
-}
-
-/****************/
-
-static void testbase_ref_callee(int * pi, int j) {
-  *pi = j;
-}
-
-static void testbase_ref_caller(void) {
-  printk("    KDFSan: Running pass by reference test...\n");
-  int i = 1, j = 2;
-  dfsan_label i_label = dfsan_create_label("i4", 0);
-  ASSERT(i_label != 0);
-  dfsan_label j_label = dfsan_create_label("j4", 0);
-  ASSERT(j_label != 0);
-  dfsan_set_label(i_label, &i, sizeof(i));
-  dfsan_set_label(j_label, &j, sizeof(j));
-
-  testbase_ref_callee(&i,j);
-
-  ASSERT(dfsan_get_label(i) == j_label);
-  ASSERT(dfsan_read_label(&i, sizeof(i)) == j_label);
-}
-
-/****************/
-
-static void testbase_load(void) {
-  printk("    KDFSan: Running load test...\n");
-  int x[4] = {1,2,3,4}, i = 3, j;
-  dfsan_label x_label = dfsan_create_label("x5", 0);
-  ASSERT(x_label != 0);
-  dfsan_label i_label = dfsan_create_label("i5", 0);
-  ASSERT(i_label != 0);
-  dfsan_set_label(x_label, x, sizeof(x));
-  dfsan_set_label(i_label, &i, sizeof(i));
-
-  j = x[i];
-
-  // Checking loads combine the label of the pointer and the data
-  dfsan_label j_label = dfsan_read_label(&j, sizeof(j));
-  ASSERT(j_label != 0);
-  ASSERT(j_label != i_label);
-  ASSERT(j_label != x_label);
-  ASSERT(dfsan_has_label(j_label, i_label));
-  ASSERT(dfsan_has_label(j_label, x_label));
-}
-
-/****************/
-
-static int add(int a, int b) {
-  return a + b;
-}
-
-static int mul(int a, int b) {
-  return a * b;
-}
-
-char desc[201] = {0};
-static void testbase_label_count(void) {
-  printk("    KDFSan: Running label count test...\n");
-  size_t old_label_count, current_label_count;
-
-  // No labels allocated yet.
-  old_label_count = dfsan_get_label_count();
-
-  int i = 1;
-  dfsan_label i_label = dfsan_create_label("i6", 0);
-  dfsan_set_label(i_label, &i, sizeof(i));
-
-  // One label allocated for i.
-  current_label_count = dfsan_get_label_count();
-  ASSERT(current_label_count == old_label_count + 1);
-
-  int j = 2;
-  dfsan_label j_label = dfsan_create_label("j6", 0);
-  dfsan_set_label(j_label, &j, sizeof(j));
-
-  // Check that a new label was allocated for j.
-  current_label_count = dfsan_get_label_count();
-  ASSERT(current_label_count == old_label_count + 2);
-
-  // Create a value that combines i and j.
-  int i_plus_j = add(i, j);
-
-  // Check that a label was created for the union of i and j.
-  current_label_count = dfsan_get_label_count();
-  ASSERT(current_label_count == old_label_count + 3);
-
-  // Combine i and j in a different way.  Check that the existing label is
-  // reused, and a new label is not created.
-  int j_times_i = mul(j, i);
-  current_label_count = dfsan_get_label_count();
-  ASSERT(current_label_count == old_label_count + 3);
-  ASSERT(dfsan_get_label(i_plus_j) == dfsan_get_label(j_times_i));
-
-  // TODO we get some invalid label here, check issue
-  //dfsan_label getter = dfsan_get_label(j_times_i);
-  //printk("Label info %d\n", getter);
-  //dfsan_copy_label_info(getter, desc, 200);
-  //printk("Label info %s\n", desc);
-}
-
-/****************/
-
-static void testbase_label_desc(void) {
-  printk("    KDFSan: Running label desc test...\n");
-
-  dfsan_label a_label = dfsan_create_label("A-VERY-UNIQUE-LABEL-NAME", 0);
-  ASSERT(dfsan_get_label_with_desc("A-VERY-UNIQUE-LABEL-NAME") == a_label);
-
-  // If multiple labels have the same desc, dfsan_get_label_with_desc() returns the lowest matching label (i.e., a_label, NOT b_label)
-  dfsan_label b_label = dfsan_create_label("A-VERY-UNIQUE-LABEL-NAME", 0); // Same desc as a_label
-  ASSERT(dfsan_get_label_with_desc("A-VERY-UNIQUE-LABEL-NAME") == a_label);
-
-  // If no labels have the desc, dfsan_get_label_with_desc() returns 0
-  ASSERT(dfsan_get_label_with_desc("A-NONEXISTENT-UNIQUE-LABEL-NAME") == 0);
-}
-
-/****************/
-
-static void testbase_propagate(void) {
-  printk("    KDFSan: Running propagate test...\n");
-  ASSERT(dfsan_union(0, 0) == 0);
-
-  int i = 1;
-  dfsan_label i_label = dfsan_create_label("i7", 0);
-  dfsan_set_label(i_label, &i, sizeof(i));
-
-  int j = 2;
-  dfsan_label j_label = dfsan_create_label("j7", 0);
-  dfsan_set_label(j_label, &j, sizeof(j));
-
-  int k = 3;
-  dfsan_label k_label = dfsan_create_label("k7", 0);
-  dfsan_set_label(k_label, &k, sizeof(k));
-
-  int k2 = 4;
-  dfsan_set_label(k_label, &k2, sizeof(k2));
-
-  dfsan_label ij_label = dfsan_get_label(i + j);
-  ASSERT(dfsan_has_label(ij_label, i_label));
-  ASSERT(dfsan_has_label(ij_label, j_label));
-  ASSERT(!dfsan_has_label(ij_label, k_label));
-  // Test uniquing.
-  ASSERT(dfsan_union(i_label, j_label) == ij_label);
-  ASSERT(dfsan_union(j_label, i_label) == ij_label);
-
-  dfsan_label ijk_label = dfsan_get_label(i + j + k);
-  ASSERT(dfsan_has_label(ijk_label, i_label));
-  ASSERT(dfsan_has_label(ijk_label, j_label));
-  ASSERT(dfsan_has_label(ijk_label, k_label));
-
-  ASSERT(dfsan_get_label(k + k2) == k_label);
-
-  struct { int i, j; } s = { i, j };
-  ASSERT(dfsan_read_label(&s, sizeof(s)) == ij_label);
-
-  ASSERT(dfsan_get_label(((i + j) + k) + i) == ijk_label);
-  ASSERT(dfsan_get_label((((i + j) + k) + i) + j) == ijk_label);
-  ASSERT(dfsan_get_label(((((i + j) + k) + i) + j) + k) == ijk_label);
-}
-
-/****************/
-
-static void testbase_memtransfer(void) {
-  printk("    KDFSan: Running shadow memtransfer test... (TODO: get reliable compilation into llvm instrinsics)\n");
-
-  char test_str[16] = "aaaabbbbcccc";
-  dfsan_label a_label = dfsan_create_label("a", 0);
-  dfsan_set_label(a_label, &test_str[0], 4);
-  dfsan_label b_label = dfsan_create_label("b", 0);
-  dfsan_set_label(b_label, &test_str[4], 4);
-  dfsan_label c_label = dfsan_create_label("c", 0);
-  dfsan_set_label(c_label, &test_str[8], 4);
-
-  // Sanity checks
-  ASSERT(a_label != 0 && b_label != 0 && c_label != 0); // every label is initialized
-  ASSERT(a_label != b_label && b_label != c_label && a_label != c_label); // labels are unique
-
-  // KDFSAN's memmove and memcpy handlers are the same, because the LLVM instructions seem to have the same semantics
-  char memmove_str[16];
-
-  // Test forward overlapping
-  strcpy(memmove_str, test_str);
-  ASSERT(memmove_str[0] == 'a');
-  ASSERT(memmove_str[4] == 'b');
-  ASSERT(memmove_str[8] == 'c');
-  ASSERT(dfsan_read_label(&memmove_str[0], 4) == a_label);
-  ASSERT(dfsan_read_label(&memmove_str[4], 4) == b_label);
-  ASSERT(dfsan_read_label(&memmove_str[8], 4) == c_label);
-  // After this, memmove_str should be "aaaaaaaabbbb"
-  __builtin_memmove((memmove_str+4), memmove_str, 8);
-  ASSERT(dfsan_read_label(&memmove_str[0], 4) == a_label);
-  ASSERT(dfsan_read_label(&memmove_str[4], 4) == a_label);
-  ASSERT(dfsan_read_label(&memmove_str[8], 4) == b_label);
-  ASSERT(memmove_str[0] == 'a');
-  ASSERT(memmove_str[4] == 'a');
-  ASSERT(memmove_str[8] == 'b');
-
-  // Test backward overlapping
-  strcpy(memmove_str, test_str);
-  ASSERT(memmove_str[0] == 'a');
-  ASSERT(memmove_str[4] == 'b');
-  ASSERT(memmove_str[8] == 'c');
-  ASSERT(dfsan_read_label(&memmove_str[0], 4) == a_label);
-  ASSERT(dfsan_read_label(&memmove_str[4], 4) == b_label);
-  ASSERT(dfsan_read_label(&memmove_str[8], 4) == c_label);
-  // After this, memmove_str should be "bbbbcccccccc"
-  __builtin_memmove(memmove_str, (memmove_str+4), 8);
-  ASSERT(dfsan_read_label(&memmove_str[0], 4) == b_label);
-  ASSERT(dfsan_read_label(&memmove_str[4], 4) == c_label);
-  ASSERT(dfsan_read_label(&memmove_str[8], 4) == c_label);
-  ASSERT(memmove_str[0] == 'b');
-  ASSERT(memmove_str[4] == 'c');
-  ASSERT(memmove_str[8] == 'c');
-}
-
-/****************/
-
-static void testbase_pointers(void) {
-  printk("    KDFSan: Running pointer test...\n");
-
-  int i = 3;
-  int arr[10] = {0,1,2,3,4,5,6,7,8,9};
-
-  dfsan_label i_label = dfsan_create_label("i8", 0);
-  dfsan_set_label(i_label, &i, sizeof(i));
-  ASSERT(dfsan_get_label(i) != 0 && dfsan_get_label(i) == i_label); // sanity check
-
-  // A value read via a tainted pointer should be tainted (however, this is configurable from the KDFSan pass)
-  ASSERT(dfsan_get_label(arr[i]) == dfsan_get_label(i) && dfsan_get_label(arr[i]) != 0);
-
-  // However, the data itself shouldn't be tainted
-  ASSERT(dfsan_get_label(arr[3]) == 0);
-
-  // A value written via a tainted pointer should not be tainted (however, this is configurable from the KDFSan pass)
-  arr[i] = 34;
-  ASSERT(dfsan_get_label(arr[3]) == 0);
-}
-
-/****************/
-
-static void testbase_custom(void) {
-  printk("    KDFSan: Running custom ABI test... (TODO: add more custom wrappers)\n");
-  // Some custom-wrapped functions are tested within test_string
-}
-
-/****************/
-
-#ifdef CONFIG_X86
-
-static void testbase_asminline(void) {
-  printk("    KDFSan: Running inline asm test...\n");
-
-  int src_a = 34, src_b = 35, tmp = 0, dst = 0;
-  dfsan_label a_label, b_label, ab_label;
-  a_label = dfsan_create_label("a9", 0);
-  b_label = dfsan_create_label("b9", 0);
-  ab_label = dfsan_union(a_label, b_label);
-  dfsan_set_label(a_label, &src_a, sizeof(src_a));
-  dfsan_set_label(b_label, &src_b, sizeof(src_b));
-
-  // Sanity checks
-  ASSERT(a_label != 0 && b_label != 0 && ab_label != 0 && a_label != b_label);
-  ASSERT(dfsan_get_label(src_a) == a_label && dfsan_get_label(src_b) == b_label);
-  ASSERT(dfsan_has_label(ab_label, a_label) && dfsan_has_label(ab_label, b_label));
-
-  // 1 input, 1 output
-  // dst = src_a; dst++
-  tmp = dst = 0;
-  asm ("mov %1, %0\n\t"
-       "add $1, %0"
-       : "+r" (dst)
-       : "r" (src_a));
-  ASSERT(dst == src_a + 1 && src_a == 34 && src_b == 35); // just to make sure asm is correct
-  ASSERT(dfsan_get_label(src_a) == a_label); // input label should remain the same
-  ASSERT(dfsan_get_label(dst) == 0); // output should be untainted
-
-  // 1 input, 2 outputs
-  // tmp = src_a; tmp++; dst = tmp;
-  tmp = dst = 0;
-  asm ("mov %2, %1\n\t"
-       "add $1, %1\n\t"
-       "mov %1, %0"
-       : "=r" (dst), "+r" (tmp)
-       : "r" (src_a));
-  ASSERT(tmp == src_a + 1 && dst == tmp && src_a == 34 && src_b == 35);
-  ASSERT(dfsan_get_label(src_a) == a_label);
-  ASSERT(dfsan_get_label(tmp) == 0 && dfsan_get_label(dst) == 0);
-
-  // 2 inputs, 1 output
-  // dst = src_a; dst += src_b;
-  tmp = dst = 0;
-  asm ("mov %1, %0\n\t"
-       "add %2, %0"
-       : "+r" (dst)
-       : "r" (src_a), "r" (src_b));
-  ASSERT(dst == src_a + src_b && src_a == 34 && src_b == 35);
-  ASSERT(dfsan_get_label(dst) == 0);
-
-  // 2 inputs, 2 outputs
-  // tmp = src_a; tmp += src_b; dst = tmp;
-  tmp = dst = 0;
-  asm volatile("mov %2, %1\n\t"
-       "add %3, %1\n\t"
-       "mov %1, %0"
-       : "=r" (dst), "+r" (tmp)
-       : "r" (src_a), "r" (src_b));
-  ASSERT(tmp == src_a + src_b && dst == tmp && src_a == 34 && src_b == 35);
-  ASSERT(dfsan_get_label(dst) == 0 && dfsan_get_label(tmp) == 0);
-
-  // 1 input, 1 output
-  // even tmp is both the input and output, its taint is washed
-  tmp = src_a; // taint tmp
-  ASSERT(dfsan_get_label(tmp) == a_label);
-  asm ("inc %0" : "+r" (tmp));
-  ASSERT(tmp == src_a + 1 && src_a == 34 && src_b == 35);
-  ASSERT(dfsan_get_label(tmp) == 0);
-}
-
-#else
-
-static void testbase_asminline(void) {
-  printk("    KDFSan: No inline asm test for this architecture. Skipping...\n");
-}
-
-#endif
-
-/****************/
-
-static void testbase_string(void) {
-  printk("    KDFSan: Running string tests...\n");
-
-  uint32_t src = 3, dst;
-  dfsan_label taint = dfsan_create_label("x10", 0);
-  ASSERT(taint != 0);
-  dfsan_set_label(taint, &src, sizeof(src));
-
-  // Clear
-  dst = 4;
-  ASSERT(src != dst);
-  ASSERT(dfsan_get_label(src) == taint);
-  ASSERT(dfsan_get_label(dst) == 0);
-
-  // memcpy test
-  memcpy(&dst, &src, sizeof(dst));
-  ASSERT(dfsan_get_label(src) == taint);
-  ASSERT(dfsan_get_label(dst) == taint);
-  ASSERT(src == dst);
-
-  // Clear
-  dst = 4;
-  ASSERT(src != dst);
-  ASSERT(dfsan_get_label(src) == taint);
-  ASSERT(dfsan_get_label(dst) == 0);
-
-  // __memcpy test
-  __memcpy(&dst, &src, sizeof(dst));
-  ASSERT(dfsan_get_label(src) == taint);
-  ASSERT(dfsan_get_label(dst) == taint);
-  ASSERT(src == dst);
-
-  // Clear
-  dst = 4;
-  ASSERT(src != dst);
-  ASSERT(dfsan_get_label(src) == taint);
-  ASSERT(dfsan_get_label(dst) == 0);
-
-  // memset32 test
-  memset32(&dst, src, 1);
-  ASSERT(dfsan_get_label(src) == taint);
-  ASSERT(dfsan_get_label(dst) == taint);
-  ASSERT(src == (char) dst);
-
-  // Clear
-  dst = 4;
-  ASSERT(src != dst);
-  ASSERT(dfsan_get_label(src) == taint);
-  ASSERT(dfsan_get_label(dst) == 0);
-
-  // memset test
-  memset(&dst, src, sizeof(dst));
-  ASSERT(dfsan_get_label(src) == taint);
-  ASSERT(dfsan_get_label(dst) == taint);
-  ASSERT(src == (char) dst); // dst actually equals ((src) | (src << 8) | (src << 16) | (src << 24)) because memset does 1-byte copies
-
-  // TODO: memmove, strcpy, strncpy, strlen
-}
-
-/****************/
-
-static void testbase_asmfxns_clear_page(void) {
-  printk("    KDFSan: Running asm function test -- clear_page...\n");
-
-  // Init buffer
-  char * kmem = kzalloc(PAGE_SIZE, GFP_KERNEL);
-  clear_mem(kmem, PAGE_SIZE);
-
-  // Init taint
-  char val = 34;
-  dfsan_label taint = dfsan_create_label("x11", 0);
-  dfsan_set_label(taint, &val, sizeof(val));
-
-  // Taint one byte of buffer
-  kmem[77] = val;
-  ASSERT(kmem[77] == val);
-  ASSERT(dfsan_get_label(kmem[76]) == 0);
-  ASSERT(dfsan_get_label(kmem[77]) == taint);
-  ASSERT(dfsan_get_label(kmem[78]) == 0);
-  ASSERT(dfsan_read_label(kmem, PAGE_SIZE) == taint);
-
-  // Clear page
-  clear_page(kmem);
-  ASSERT(kmem[77] == 0); // clear_page works as expected
-  ASSERT(dfsan_get_label(kmem[76]) == 0);
-  ASSERT(dfsan_get_label(kmem[77]) == 0); // now untainted
-  ASSERT(dfsan_get_label(kmem[78]) == 0);
-  ASSERT(dfsan_read_label(kmem, PAGE_SIZE) == 0); // now untainted
-
-  kfree(kmem);
-}
-
-static void testbase_asmfxns(void) {
-  printk("    KDFSan: Running asm function calls test... (TODO: add more functions)\n");
-
-  testbase_asmfxns_clear_page();
-  // TODO: check labels of functions with custom taint handlers for asm
-}
-
-/****************/
-
-static int testbase_stack_shadow_overwrite_stack(int i) {
-  int64_t arr[64] = {0};
-  (void*) arr[0]; 
-  if(i == 0) return 0;
-  return testbase_stack_shadow_overwrite_stack(i-1);
-}
-
-static void testbase_stack_shadow_get_tainted_ptr_from_old_frame(int ** ret) {
-  // array on the stack where element 34 is tainted
-  int arr[64] = {0};
-
-  int * tainted_i = &arr[34];
-
-  dfsan_label lbl = dfsan_create_label("x12", 0);
-  dfsan_set_label(lbl, tainted_i, sizeof(*tainted_i));
-
-  *ret = tainted_i;
-}
-
-static void testbase_stack_shadow(void) {
-  printk("    KDFSan: Running stack shadow test...\n");
-  int * ptr = NULL;
-
-  testbase_stack_shadow_get_tainted_ptr_from_old_frame(&ptr);
-  ASSERT(ptr != NULL);
-  dfsan_label lbl_before = dfsan_read_label(ptr, sizeof(*ptr));
-  ASSERT(lbl_before != 0);
-  ASSERT(dfsan_has_label_with_desc(lbl_before, "x12"));
-
-  testbase_stack_shadow_overwrite_stack(50);
-  dfsan_label label_after = dfsan_read_label(ptr, sizeof(*ptr));
-  ASSERT(label_after == 0);
-  //printk("  ** NOTE: This seems to be a fundamental problem with DFSan: not _all_ writes to the stack (e.g., calls/rets) hit shadow memory -- ASSERT(label_after %d == 0)? **\n", label_after);
-}
-
-/****************/
-
-__no_kdfsan_taint static void testbase_notaint_args(char x) {
-  ASSERT(dfsan_get_label(x) == 0);
-}
-
-__no_kdfsan_taint static void testbase_notaint_load(char * ptr) {
-  ASSERT(dfsan_get_label(*ptr) == 0);
-}
-
-__no_kdfsan_taint static void testbase_notaint_store(char * ptr, dfsan_label taint) {
-  int x = 34;
-  dfsan_set_label(taint, &x, sizeof(x));
-  *ptr = x;
-}
-
-__no_kdfsan_taint static char testbase_notaint_ret(dfsan_label taint) {
-  int x = 34;
-  dfsan_set_label(taint, &x, sizeof(x));
-  return x;
-}
-
-static void testbase_notaint(void) {
-  printk("    KDFSan: Running __no_kdfsan_checks test...\n");
-
-  char tainted_val = 34, ret = 0;
-  char * ptr = &tainted_val;
-  dfsan_label taint = dfsan_create_label("x13", 0);
-  dfsan_set_label(taint, &tainted_val, sizeof(tainted_val));
-
-  testbase_notaint_args(tainted_val);
-
-  ASSERT(dfsan_get_label(*ptr) != 0); // sanity check
-  testbase_notaint_load(ptr);
-
-  ASSERT(dfsan_get_label(*ptr) != 0); // sanity check
-  testbase_notaint_store(ptr, taint);
-  ASSERT(dfsan_get_label(*ptr) == 0);
-
-  ret = testbase_notaint_ret(taint);
-  ASSERT(dfsan_get_label(ret) == 0);
-}
-
-/****************/
-
-void kdfsan_run_base_tests(void) {
-  testbase_init(); // Test only works if run first
-  testbase_shadow();
-  testbase_basic();
-  testbase_label_count();
-  testbase_label_desc();
-  testbase_fn_caller();
-  testbase_ref_caller();
-  testbase_load();
-  testbase_propagate();
-  testbase_memtransfer();
-  testbase_string();
-  testbase_pointers();
-  testbase_custom();
-  testbase_asminline();
-  testbase_asmfxns();
-  testbase_stack_shadow();
-  testbase_notaint();
-  TEST_PANIC_ON(kdf_tests_fail, "KDFSan error: one or more tests failed");
-}
diff --git a/lib/test_kdfsan_policies.c b/lib/test_kdfsan_policies.c
deleted file mode 100644
index 14fd61d4ac81..000000000000
--- a/lib/test_kdfsan_policies.c
+++ /dev/null
@@ -1,464 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#include <linux/kdfsan.h>
-#include <linux/string.h>
-#include <linux/printk.h>
-#include <linux/mman.h>
-#include <linux/slab.h>
-#include <linux/pci.h>
-#include <linux/device.h>
-#include <linux/platform_device.h>
-#include <linux/skbuff.h>
-#include "../mm/kdfsan/kdfsan_policies.h"
-
-/******************************************************************************/
-/* Test helpers */
-/******************************************************************************/
-
-static bool kdf_tests_fail = false;
-
-#define TEST_PANIC_ON(cond, ...) \
-do { \
-  if(cond) { \
-    panic(__VA_ARGS__); \
-  } \
-} while(0)
-
-#define ASSERT(x) \
-do {    if (x) break; \
-        printk(KERN_EMERG "### ASSERTION FAILED %s: %s: %d: %s\n", \
-               __FILE__, __func__, __LINE__, #x); \
-        kdf_tests_fail = true;  \
-} while (0)
-
-/******************************************************************************/
-/* Userspace tests */
-/******************************************************************************/
-
-#ifdef CONFIG_KDFSAN_USERSPACE_POLICIES
-
-/************************************/
-/* Helpers */
-
-static bool check_mem(char * arr, size_t size, char x) {
-  for(int i = 0; i < size; i++) {
-    if(arr[i] != x)
-      return false;
-  }
-  return true;
-}
-
-static void clear_mem(char * arr, size_t size) {
-  memset(arr, 0, size);
-  dfsan_set_label(0, arr, size);
-  ASSERT(check_mem(arr, size, 0));
-  ASSERT(dfsan_read_label(arr, size) == 0);
-}
-
-static bool check_labels(char * arr, size_t size, dfsan_label expected_label) {
-  dfsan_label this_label;
-  for(int i = 0; i < size; i++) {
-    this_label = dfsan_get_label(arr[i]);
-    if(this_label != expected_label) {
-      printk("    KDFSan test ERROR: label of arr[%d] is %d but expected %d; quitting test...\n", i, this_label, expected_label);
-      return false;
-    }
-  }
-  return true;
-}
-
-/************************************/
-/* Tests */
-
-static void testpolicies_getuser_run(char *kmem, char __user *usermem, size_t size, char data, dfsan_label expected_label) {
-  // Test copy_from_user
-  clear_mem(kmem, size);
-  TEST_PANIC_ON(copy_from_user(kmem, usermem, size), "KDFSan test error: copy_from_user failed");
-  ASSERT(check_labels(kmem, size, expected_label));
-  ASSERT(check_mem(kmem, size, data));
-
-  // Test get_user
-  clear_mem(kmem, size);
-  TEST_PANIC_ON(get_user(kmem[0], usermem), "KDFSan test error: get_user failed");
-  ASSERT(check_labels(&kmem[0], 1, expected_label) && check_labels(&kmem[1], size - 1, 0));
-  ASSERT(check_mem(&kmem[0], 1, data) && check_mem(&kmem[1], size - 1, 0));
-
-  // Test strncpy_from_user
-  clear_mem(kmem, size);
-  put_user(0, &usermem[size - 1]); // NULL-terminates string
-  TEST_PANIC_ON(strncpy_from_user(kmem, usermem, size) != size - 1, "KDFSan test error: strncpy_from_user failed"); // returns length of string on success
-  ASSERT(check_labels(kmem, size, expected_label));
-  ASSERT(check_mem(kmem, size - 1, data) && check_mem(&kmem[size - 1], 1, 0));
-
-  // Test strnlen_user
-  clear_mem(kmem, size);
-  put_user(0, &usermem[size - 2]); // NULL-terminates string 1 byte early
-  size_t user_len = strnlen_user(usermem, size); // returns the string length *including* the NULL terminator
-  ASSERT(dfsan_get_label(user_len) == expected_label);
-  ASSERT(user_len == size - 1);
-}
-
-static void testpolicies_getuser(void) {
-  printk("    KDFSan: Setting up user copy tests... (This should only run once task whitelisting is enabled, otherwise getuser taint will not be applied)\n");
-
-  char *kmem;
-  char __user *usermem;
-  unsigned long user_addr;
-  size_t size = 10;
-  char data = 34;
-  dfsan_label attacker_label = dfsan_create_label("test-a11", 0);
-  dfsan_label getuser_label = kdfsan_policies_get_getuser_label();
-  dfsan_label unioned_label = dfsan_union(attacker_label, getuser_label);
-  //printk("    KDFSan getuser test: attacker_label = %d, getuser_label = %d, unioned_label = %d\n", attacker_label, getuser_label, unioned_label);
-
-  // Allocate mem
-  kmem = kzalloc(size, GFP_KERNEL);
-	TEST_PANIC_ON(!kmem, "KDFSan test error: Failed to allocate kernel memory");
-	user_addr = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, 0);
-  TEST_PANIC_ON(user_addr >= (unsigned long)(TASK_SIZE), "KDFSan test error: Failed to allocate user memory");
-	usermem = (char __user *)user_addr;
-
-  // Initialize usermem and check that parameters are untainted
-  printk("    KDFSan: Running user copy tests with untainted user pointer...\n");
-  memset(kmem, data, size);
-  TEST_PANIC_ON(copy_to_user(usermem, kmem, size), "KDFSan test error: copy_to_user failed");
-  ASSERT(dfsan_read_label(&kmem, sizeof(kmem)) == 0);
-  ASSERT(dfsan_read_label(&usermem, sizeof(usermem)) == 0);
-  ASSERT(dfsan_get_label(size) == 0 && dfsan_get_label(data) == 0);
-  testpolicies_getuser_run(kmem, usermem, size, data, getuser_label); // getuser output should only have the getuser label
-
-  // Re-initialize usermem and taint user pointer (tests should function the same regardless of taint)
-  printk("    KDFSan: Running user copy tests with tainted user pointer...\n");
-  memset(kmem, data, size);
-  TEST_PANIC_ON(copy_to_user(usermem, kmem, size), "KDFSan test error: copy_to_user failed");
-  dfsan_set_label(attacker_label, &usermem, sizeof(usermem));
-  ASSERT(dfsan_read_label(&kmem, sizeof(kmem)) == 0);
-  ASSERT(dfsan_read_label(&usermem, sizeof(usermem)) != 0); // usermem pointer is tainted
-  ASSERT(dfsan_get_label(size) == 0 && dfsan_get_label(data) == 0);
-  testpolicies_getuser_run(kmem, usermem, size, data, unioned_label); // getuser output should have both the getuser label and the attacker label
-
-  // Cleanup
-  printk("    KDFSan: Cleaning up user copy tests...\n");
-  vm_munmap(user_addr, size);
-  kfree(kmem);
-}
-
-void kdfsan_run_policies_tests(void) {
-  testpolicies_getuser();
-  TEST_PANIC_ON(kdf_tests_fail, "KDFSan error: one or more tests failed");
-}
-
-#endif
-
-/******************************************************************************/
-/* Double-fetch tests */
-/******************************************************************************/
-
-#ifdef CONFIG_KDFSAN_DOUBLEFETCH_POLICIES
-
-static void __no_opt testpolicies_df_userspace(void) {
-  if (!KDF_DOUBLEFETCH_USER) return;
-
-  printk("    KDFSan: Setting up userspace double-fetch test...\n");
-  unsigned char __user *usermem;
-  unsigned long user_addr;
-  size_t size = 10;
-  unsigned char x, y[0xff], z[2];
-
-  user_addr = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, 0); // Allocate user mem
-  TEST_PANIC_ON(user_addr >= (unsigned long)(TASK_SIZE), "KDFSan test error: Failed to allocate user memory");
-  usermem = (char __user *)user_addr;
-
-  printk("    KDFSan: Running userspace double-fetch test with an initial *GETUSER*. (SHOULD PRINT REPORTS: 1 USER_1F, 2 USER_2F, 1 VULN_STORE)...\n");
-  barrier(); x = 0; z[0] = 0; z[1] = 0; // Just to be safe
-  TEST_PANIC_ON(copy_from_user(&x, &usermem[0], 1), "KDFSan test error: copy_from_user failed"); ASSERT(dfsan_get_label(x) == 0); // Single-fetch is untainted       -- USER_1F (load)
-  TEST_PANIC_ON(get_user(x, &usermem[2]), "KDFSan test error: get_user failed"); ASSERT(dfsan_get_label(x) == 0); // Single-fetch is untainted
-  TEST_PANIC_ON(copy_from_user(z, &usermem[0], 2), "KDFSan test error: copy_from_user failed"); ASSERT(kdfsan_policies_is_df_label(dfsan_get_label(z[0]))); ASSERT(dfsan_get_label(z[1]) == 0); // Double-fetch is tainted (although usermem[1] is not double-fetched) -- USER_2F
-  TEST_PANIC_ON(get_user(x, &usermem[3]), "KDFSan test error: get_user failed"); ASSERT(dfsan_get_label(x) == 0); // Single-fetch is untainted
-  TEST_PANIC_ON(__get_user(x, &size),     "KDFSan test error: __get_user failed"); ASSERT(dfsan_get_label(x) == 0); // Single-fetch FROM KERNELSPACE is untainted
-  TEST_PANIC_ON(__get_user(x, &size),     "KDFSan test error: __get_user failed"); ASSERT(dfsan_get_label(x) == 0); // Double-fetch FROM KERNELSPACE is untainted
-  TEST_PANIC_ON(get_user(x, &usermem[0]), "KDFSan test error: get_user failed"); ASSERT(kdfsan_policies_is_df_label(dfsan_get_label(x))); // N-fetch is tainted      -- USER_2F
-  y[x] = 34; //                                                                                                                                                      -- VULN_STORE
-
-  printk("    KDFSan: Running userspace double-fetch test with an initial *PUTUSER* (put_user). (SHOULD PRINT REPORTS: 1 USER_1F, 1 USER_2F, 1 VULN_COND)...\n");
-  barrier(); x = 0; // Just to be safe
-  TEST_PANIC_ON(put_user(34, &usermem[4]), "KDFSan test error: put_user failed"); // Single-fetch                                                                    -- USER_1F (store)
-  TEST_PANIC_ON(get_user(x, &usermem[4]), "KDFSan test error: get_user failed"); ASSERT(kdfsan_policies_is_df_label(dfsan_get_label(x))); // Double-fetch is tainted -- USER_2F
-  for (int i = 0; i < x; i++) { barrier(); } // Vulnerable branch via a tainted condition.                                                                           -- VULN_COND
-
-  printk("    KDFSan: Running userspace double-fetch test with an initial *PUTUSER* (copy_to_user). (SHOULD PRINT REPORTS: 1 USER_1F, 1 USER_2F)...\n");
-  barrier(); x = 0; // Just to be safe
-  TEST_PANIC_ON(copy_to_user(&usermem[5], &x, 1), "KDFSan test error: copy_to_user failed"); // Single-fetch                                                         -- USER_1F (store)
-  TEST_PANIC_ON(get_user(x, &usermem[5]), "KDFSan test error: get_user failed"); ASSERT(kdfsan_policies_is_df_label(dfsan_get_label(x))); // Double-fetch is tainted -- USER_2F
-
-  printk("    KDFSan: Running userspace double-fetch test with an initial *PUTUSER* (__put_user). (SHOULD PRINT REPORTS: 1 USER_1F, 1 USER_2F)...\n");
-  barrier(); x = 0; // Just to be safe
-  TEST_PANIC_ON(__put_user(34, &usermem[7]), "KDFSan test error: __put_user failed"); // Single-fetch                                                                -- USER_1F (store)
-  TEST_PANIC_ON(get_user(x, &usermem[7]), "KDFSan test error: get_user failed"); ASSERT(kdfsan_policies_is_df_label(dfsan_get_label(x))); // Double-fetch is tainted -- USER_2F
-
-  // Cleanup
-  vm_munmap(user_addr, size);
-}
-
-static char __no_opt helper_load(char * ptr) { return *ptr; }
-static void __no_opt helper_store(char * ptr, char x) { *ptr = x; }
-static void helper_loop(char * ptr) { for (int i = 0; *ptr == 123 || i < 4; i++) { barrier(); } } // NOTE: This function should not be optimized, because otherwise the loop branch is not a backward branch, and then we don't identify it as a VULN_COND
-static void __no_opt testpolicies_df_dma_coherent(void) {
-  if (!KDF_DOUBLEFETCH_DMA_COHERENT) return;
-
-  struct pci_dev * pdev = NULL;
-  char * buf = NULL;
-  dma_addr_t dma_handle;
-  size_t size = 20;
-  unsigned char x, y[0xff];
-
-  printk("    KDFSan: Setting up coherent DMA test...\n");
-  pdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL); // Get any available device struct
-  ASSERT(pdev != NULL);
-  buf = dma_alloc_coherent(&(pdev)->dev, size, &dma_handle, GFP_DMA); // Allocate on behalf of the device
-  ASSERT(buf != NULL);
-  printk("    KDFSan: Set up coherent DMA buffer with dev_drv=%s, dev_name=%s\n", dev_driver_string(&(pdev)->dev), pci_name(pdev));
-
-  printk("    KDFSan: Running coherent DMA test with an initial *STORE*. (SHOULD PRINT REPORTS: 1 DMA_1F, 3 DMA_2F, 2 VULN_COND, 1 DMA_1F, 1 DMA_2F, 1 VULN_COND, (Domain change), 1 DMA_2F, 1 VULN_COND)...\n");
-  barrier(); x = 0; // Just to be safe
-  helper_store(&buf[0], 34); // Single-fetch                                                      -- DMA_1F (store)
-  x = buf[1]; ASSERT(dfsan_get_label(x) == 0); // Single-fetch is untainted
-  __builtin_memmove(&x, &buf[0], sizeof(x)); ASSERT(kdfsan_policies_is_df_label(dfsan_get_label(x))); // DMA_2F
-  __memcpy(&x, &buf[0], sizeof(x)); ASSERT(kdfsan_policies_is_df_label(dfsan_get_label(x))); //   -- DMA_2F
-  x = buf[2]; ASSERT(dfsan_get_label(x) == 0); // Single-fetch is untainted
-  x = helper_load(&buf[0]); ASSERT(kdfsan_policies_is_df_label(dfsan_get_label(x))); // N-fetch is tainted -- DMA_2F
-  for (int i = 0; i < x; i++) { barrier(); } // Vulnerable branch via a tainted condition.        -- VULN_COND
-  BUG_ON(x == 11111111); //                                                                       -- VULN_COND
-  //if (x == 22222222) BUG(); //                                                                    -- VULN_COND
-  //if (x == 33333333) panic("Here's a panic!\n"); //                                               -- VULN_COND
-  helper_loop(&buf[3]); //                                                                        -- DMA_1F:LOAD, DMA_2F:LOAD, VULN_COND
-  kdfsan_domain_exit(); printk("    KDFSan: ---- (Domain change) ----\n"); kdfsan_domain_enter(); // Contrived domain change to test report clearing
-  for (int i = 0; i < x; i++) { barrier(); } // x is tainted, but its DMA_2F report was cleared => no VULN_COND
-  x = buf[0]; ASSERT(kdfsan_policies_is_df_label(dfsan_get_label(x))); // Preceeding DMA_1F (store) persists thru domain change -- DMA_2F
-  for (int i = 0; i < x; i++) { barrier(); } //                                                   -- VULN_COND
-
-  printk("    KDFSan: Running coherent DMA test with an initial *LOAD*. (SHOULD PRINT REPORTS: 1 DMA_1F, 1 DMA_2F, 1 VULN_STORE, (Domain change), 1 DMA_1F, 1 DMA_2F, 1 VULN_STORE)...\n");
-  barrier(); x = 0; // Just to be safe
-  x = buf[4]; ASSERT(dfsan_get_label(x) == 0); // Single-fetch is untainted                         -- DMA_1F (load)
-  for (int i = 0; i < 4; i++) {	// First set of reports should print; the other sets have duplicates
-    memcpy(&x, &buf[4], sizeof(x)); ASSERT(kdfsan_policies_is_df_label(dfsan_get_label(x))); //     -- DMA_2F
-    y[x] = 34; //                                                                                   -- VULN_STORE
-  }
-  ASSERT(kdfsan_policies_is_df_label(dfsan_get_label(x))); if (x == 12345678) { barrier(); } ASSERT(kdfsan_policies_is_df_label(dfsan_get_label(x))); // Forward branch condition *does not* invalidate double-fetch taint
-  kdfsan_domain_exit(); printk("    KDFSan: ---- (Domain change) ----\n"); kdfsan_domain_enter(); // Contrived domain change to test report clearing
-  y[x] = 34; // x is tainted, but its DMA_2F report was cleared => no VULN_STORE
-  x += buf[4]; ASSERT(dfsan_get_label(x) != 0 && !kdfsan_policies_is_df_label(dfsan_get_label(x))); // Single-fetch is tainted, but with an *invalid* double-fetch label -- DMA_1F (load)
-  x += buf[4]; ASSERT(kdfsan_policies_is_df_label(dfsan_get_label(x))); // Double-fetch is tainted  -- DMA_2F: prev_reports should include only the immediately preceeding DMA_1F
-  y[x] = 34; //                                                                                     -- VULN_STORE: prev_reports should include only the immediately preceeding DMA_2F
-
-  printk("    KDFSan: Running coherent DMA test with pointers written. (SHOULD PRINT REPORTS: 4 DMA_1F)...\n");
-  u64 * dma_ptr = (u64*)(&buf[10]);
-  const u64 * local_ptr = (u64*)&size;
-  memset(y, 0, sizeof(y)); memcpy(&y[2], &local_ptr, sizeof(u64*)); // y[2]--y[9] has a pointer
-  *dma_ptr = (u64)local_ptr;                           // DMA_1F (store)
-  memcpy(dma_ptr, &local_ptr, sizeof(u64));            // DMA_1F (store)
-  __memcpy(dma_ptr, &y[0], 10);                        // DMA_1F (store)
-  __memcpy(dma_ptr, &y[3], 10);                        // None -- doesn't include the part of the pointer in y[2]
-  __memcpy(dma_ptr, &y[0], 9);                         // None -- doesn't include the part of the pointer in y[9]
-  __builtin_memmove(dma_ptr, &local_ptr, sizeof(u64)); // DMA_1F (store)
-
-  // Cleanup
-  printk("    KDFSan: Cleaning up coherent DMA test...\n");
-  dma_free_coherent(&(pdev)->dev, size, buf, dma_handle);
-  pci_dev_put(pdev);
-
-  // Cleanup sanity checks
-  x = buf[0]; ASSERT(dfsan_get_label(x) == 0); // buf is no longer a DMA region, so this shouldn't generate a report. (Yes, this is a use-after-free...)
-  x = buf[0]; ASSERT(dfsan_get_label(x) == 0); // buf is no longer a DMA region, so this shouldn't generate a report. (Yes, this is a use-after-free...)
-  ASSERT(dfsan_read_label(buf, size) == 0); // buf should be untainted
-}
-
-static int match_any_device(struct device *dev, const void *data) { return 1; } // Always match
-static struct device *get_any_device(void) { return bus_find_device(&platform_bus_type, NULL, NULL, match_any_device); }
-static void __no_opt testpolicies_df_vulns_dmapool(void) {
-  if (!KDF_DOUBLEFETCH_DMA_COHERENT) return;
-
-  struct device *dev;
-  struct dma_pool *pool;
-  char *buf1, *buf2;
-  dma_addr_t handle1, handle2;
-
-  printk("    KDFSan: Setting up DMA pool test...\n");
-  dev = get_any_device();
-  ASSERT(dev != NULL);
-  pool = dma_pool_create("my-test-pool", dev, 1024, 64, 0);
-  buf1 = dma_pool_zalloc(pool, GFP_KERNEL, &handle1);
-  buf2 = dma_pool_zalloc(pool, GFP_KERNEL, &handle2);
-
-  ASSERT(!kdfsan_policies_is_df_label(dfsan_get_label((long)buf2))); // Assert fails if DMA pool *is* vulnerable
-  buf2[20] = 0x34; //					-- VULN_STORE if DMA pool is vulnerable (buf2 tainted because of the DMA_1F/2F in dma_pool_zalloc()...)
-
-  printk("    KDFSan: Cleaning up DMA pool test...\n");
-  dma_pool_free(pool, buf1, handle1);
-  dma_pool_free(pool, buf2, handle2);
-  dma_pool_destroy(pool);
-  put_device(dev);
-}
-
-static int match_e100_device(struct device *dev, const void *data) {
-    if (to_pci_dev(dev) && dev->driver && !strcmp(dev->driver->name, "e100")) return 1;
-    return 0;
-}
-static struct device *get_e100_device(void) { return bus_find_device(&pci_bus_type, NULL, NULL, match_e100_device); }
-static void __no_opt testpolicies_df_vulns_swiotlb(void) {
-  if (!KDF_DOUBLEFETCH_DMA_COHERENT) return;
-
-  struct device *dev;
-  dma_addr_t handle_coherent, handle_streaming;
-  char *buf_coherent;
-  size_t size = 64;
-
-  // Get a handle to the E100 dev, because it exhibits the vuln.
-  printk("    KDFSan: Setting up swiotlb test...\n");
-  dev = get_e100_device();
-  if (!dev) { ASSERT(false); return; }
-  printk("Device info: driver=%s, name=%s, bus_id=%s\n", dev_driver_string(dev), dev_name(dev), dev_bus_name(dev));
-
-  // Setup coherent DMA region
-  buf_coherent = dma_alloc_coherent(dev, size, &handle_coherent, GFP_DMA);
-  ASSERT(buf_coherent != NULL);
-
-  // Get an sk_buff (because it causes dma_map_single() to give us a swiotlb buffer)
-  struct sk_buff *skb;
-  if (!(skb = netdev_alloc_skb(NULL, 1500))) {
-    ASSERT(false);
-    return;
-  }
-  skb_put(skb, 1500);
-  memset(skb->data, 0xFF, 1500);
-
-  // Map the sk_buff into streaming DMA
-  handle_streaming = dma_map_single(dev, skb->data, size, DMA_TO_DEVICE);
-  ASSERT(!dma_mapping_error(dev, handle_streaming));
-
-  // Cover TOITOU vuln.
-  *(dma_addr_t*)buf_coherent = handle_streaming;  // DMA_1F:STORE -- Initialize buf_coherent with the streaming region's DMA handle
-  dma_addr_t dma_arg = *(dma_addr_t*)buf_coherent;// DMA_2F:LOAD
-  dma_unmap_single(dev, dma_arg, size, DMA_TO_DEVICE); // --> VULN_COND
-
-  printk("    KDFSan: Cleaning up swiotlb test...\n");
-  dev_kfree_skb(skb);
-  dma_free_coherent(dev, size, buf_coherent, handle_coherent);
-  put_device(dev);
-}
-
-static void testpolicies_df_vulns(void) {
-  // Let's not run these tests by default. E.g., because the dmapool test is designed to fail an assertion if the vuln. is unmitigated.
-  if (0) testpolicies_df_vulns_dmapool();
-  if (0) testpolicies_df_vulns_swiotlb();
-}
-
-static void __no_opt testpolicies_df_dma_streaming() {
-  if (!KDF_DOUBLEFETCH_DMA_STREAMING) return;
-
-  struct pci_dev * pdev;
-  dma_addr_t dma_handle;
-  char * buf = NULL;
-  size_t size = 10;
-  char x;
-
-  printk("    KDFSan: Setting up streaming DMA test...\n");
-  pdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL); // Get any available device struct
-  ASSERT(pdev != NULL);
-  buf = kzalloc(size, GFP_DMA);
-  ASSERT(buf != NULL);
-  dma_handle = dma_map_single(&(pdev)->dev, buf, size, DMA_FROM_DEVICE);
-  ASSERT(!dma_mapping_error(&(pdev)->dev, dma_handle));
-  printk("    KDFSan: Set up streaming DMA buffer with dev_drv=%s, dev_name=%s\n", dev_driver_string(&(pdev)->dev), pci_name(pdev));
-
-  printk("    KDFSan: Running streaming DMA test. (SHOULD PRINT REPORTS: 4 DMA_INV)...\n");
-  x = buf[0]; // DMA_INV
-  __builtin_memmove(&x, &buf[0], sizeof(x)); // DMA_INV
-  ASSERT(dfsan_get_label(x) == 0);
-  dma_sync_single_for_cpu(&(pdev)->dev, dma_handle, size, DMA_FROM_DEVICE);
-  x = buf[0]; // (Valid access)
-  ASSERT(dfsan_get_label(x) == 0);
-  dma_sync_single_for_device(&(pdev)->dev, dma_handle, size, DMA_FROM_DEVICE);
-  for (int i = 0; i < 10; i++) x = buf[0]; // DMA_INV (should only print 1 report; the other 9 are duplicates)
-  memcpy(&x, &buf[0], sizeof(x)); // DMA_INV
-  ASSERT(dfsan_get_label(x) == 0);
-
-  // Cleanup
-  printk("    KDFSan: Cleaning up streaming DMA test...\n");
-  dma_unmap_single(&(pdev)->dev, dma_handle, size, DMA_FROM_DEVICE);
-  pci_dev_put(pdev);
-
-  // Cleanup sanity checks
-  x = buf[0]; ASSERT(dfsan_get_label(x) == 0); // buf is no longer a DMA region, so this shouldn't generate a report. (Yes, this is a use-after-free...)
-  ASSERT(dfsan_read_label(buf, size) == 0); // buf should be untainted
-  kfree(buf);
-}
-
-static void __no_opt testpolicies_df_mmio() {
-  if (!KDF_DOUBLEFETCH_MMIO) return;
-
-  void __iomem * iomem;
-  char x = 0, y = 0;
-
-  printk("    KDFSan: Setting up MMIO test...\n");
-  TEST_PANIC_ON(request_mem_region(0xA1234, 0x34, "fake-kdfsan-test-driver1") == NULL, "KDFSan test error: request_mem_region() failed");
-  iomem = ioremap(0xA1234, 0x34);
-  TEST_PANIC_ON(iomem == NULL, "KDFSan test error: ioremap() failed");
-
-  printk("    KDFSan: Running MMIO test. (SHOULD PRINT REPORTS: 1 MMIO_1F, 4 MMIO_2F)...\n");
-  writeb(34, iomem);  // MMIO_1F (STORE)
-  x = *(char*)iomem;  // MMIO_2F
-  x = ioread8(iomem); // MMIO_2F
-  x = readb(iomem);   // MMIO_2F
-  memcpy_fromio(&x, iomem, 1); // MMIO_2F
-
-  ASSERT(kdfsan_policies_is_df_label(dfsan_get_label(x)));
-  ASSERT(dfsan_get_label(y) == 0);
-  y = x & 0xf; // 'And' operation clears label
-  ASSERT(kdfsan_policies_is_df_label(dfsan_get_label(x)));
-  ASSERT(dfsan_get_label(y) == 0);
-
-  // Cleanup
-  iounmap(iomem);
-  release_mem_region(0xA1234, 0x34);
-}
-
-static void __no_opt testpolicies_df_pmio() {
-  if (!KDF_DOUBLEFETCH_PMIO) return;
-
-  int x;
-
-  printk("    KDFSan: Setting up PMIO test...\n");
-  TEST_PANIC_ON(request_region(1234, 34, "fake-kdfsan-test-driver2") == NULL, "KDFSan test error: request_region() failed");
-
-  printk("    KDFSan: Running PMIO test. (SHOULD PRINT REPORTS: 1 PMIO_1F, 3 PMIO_2F, 1 PMIO_1F, 1 PMIO_2F, 1 VULN_COND)...\n");
-  outb(34, 1234);                                                                                                 // PMIO_1F (STORE)
-  x = inb(1234); ASSERT(kdfsan_policies_is_df_label(dfsan_get_label(x)));                                         // PMIO_2F
-  x = inb(1237); ASSERT(dfsan_get_label(x) == 0);                                                                 // PMIO_1F (LOAD)
-  insb(1234, &x, 1); ASSERT(kdfsan_policies_is_df_label(dfsan_get_label(x)));                                     // PMIO_2F
-  x = ioread8((const void __iomem *)(0x10000UL | 1234)); ASSERT(kdfsan_policies_is_df_label(dfsan_get_label(x))); // PMIO_2F... 0x10000UL shenanigans based on PIO_OFFSET in iomap.c
-  x += inb(1237); ASSERT(kdfsan_policies_is_df_label(dfsan_get_label(x)));                                        // PMIO_2F
-  for (int i = 0; i < x; i++) { barrier(); }                                                                      // VULN_COND: prev_reports should include the two preceeding PMIO_2F reports
-
-  // Cleanup
-  release_region(1234, 34);
-}
-
-static void __no_opt clear_stack_shadow() {
-  char x[2048] = {0}; // Assuming we don't need to go deeper than 2048 bytes...
-  dfsan_set_label(0, &x, sizeof(x));
-}
-
-void kdfsan_run_policies_tests(void) {
-  printk("    KDFSan: Running double-fetch tests...\n");
-  testpolicies_df_userspace();
-  testpolicies_df_dma_coherent();
-  testpolicies_df_vulns();
-  testpolicies_df_dma_streaming();
-  testpolicies_df_mmio();
-  testpolicies_df_pmio();
-  TEST_PANIC_ON(kdf_tests_fail, "KDFSan error: one or more tests failed");
-  clear_stack_shadow();
-}
-
-#endif
\ No newline at end of file
diff --git a/mm/Makefile b/mm/Makefile
index b5a779fdf27b..678530a07326 100644
--- a/mm/Makefile
+++ b/mm/Makefile
@@ -32,11 +32,6 @@ KCOV_INSTRUMENT_mmzone.o := n
 KCOV_INSTRUMENT_vmstat.o := n
 KCOV_INSTRUMENT_failslab.o := n
 
-KDFSAN_CLEARTAINT_memory.o := y
-KDFSAN_CLEARTAINT_page_alloc.o := y
-KDFSAN_CLEARTAINT_slab.o := y
-KDFSAN_CLEARTAINT_slub.o := y
-
 CFLAGS_init-mm.o += $(call cc-disable-warning, override-init)
 CFLAGS_init-mm.o += $(call cc-disable-warning, initializer-overrides)
 
@@ -93,7 +88,6 @@ obj-$(CONFIG_SLUB) += slub.o
 obj-$(CONFIG_KASAN)	+= kasan/
 obj-$(CONFIG_KFENCE) += kfence/
 obj-$(CONFIG_KMSAN)	+= kmsan/
-obj-$(CONFIG_KDFSAN)   += kdfsan/
 obj-$(CONFIG_FAILSLAB) += failslab.o
 obj-$(CONFIG_FAIL_PAGE_ALLOC) += fail_page_alloc.o
 obj-$(CONFIG_MEMTEST)		+= memtest.o
diff --git a/mm/dmapool.c b/mm/dmapool.c
index f0bfc6c490f4..a151a21e571b 100644
--- a/mm/dmapool.c
+++ b/mm/dmapool.c
@@ -36,7 +36,7 @@
 #include <linux/types.h>
 #include <linux/wait.h>
 
-#ifdef CONFIG_SLUB_DEBUG_ON
+#if defined(CONFIG_DEBUG_SLAB) || defined(CONFIG_SLUB_DEBUG_ON)
 #define DMAPOOL_DEBUG 1
 #endif
 
diff --git a/mm/kdfsan/Makefile b/mm/kdfsan/Makefile
deleted file mode 100644
index 3902ff91c83a..000000000000
--- a/mm/kdfsan/Makefile
+++ /dev/null
@@ -1,40 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-y := kdfsan_custom.o kdfsan_init.o kdfsan_interface.o kdfsan_internal.o kdfsan_mm.o kdfsan_shadow.o kdfsan_policies.o kdfsan_util.o kdfsan_whitelist.o
-
-KASAN_SANITIZE := n
-KMSAN_SANITIZE := n
-KDFSAN_SANITIZE := n
-KCOV_INSTRUMENT := n
-UBSAN_SANITIZE := n
-
-# Disable instrumentation of KDFSAN runtime with other tools.
-CC_FLAGS_KDFSAN_RUNTIME := -fno-stack-protector
-CC_FLAGS_KDFSAN_RUNTIME += $(call cc-option,-fno-conserve-stack)
-CC_FLAGS_KDFSAN_RUNTIME += -DDISABLE_BRANCH_PROFILING
-
-# Disable ftrace to avoid recursion.
-CFLAGS_REMOVE_kdfsan_custom.o = $(CC_FLAGS_FTRACE)
-CFLAGS_REMOVE_kdfsan_init.o = $(CC_FLAGS_FTRACE)
-CFLAGS_REMOVE_kdfsan_interface.o = $(CC_FLAGS_FTRACE)
-CFLAGS_REMOVE_kdfsan_internal.o = $(CC_FLAGS_FTRACE)
-CFLAGS_REMOVE_kdfsan_mm.o = $(CC_FLAGS_FTRACE)
-CFLAGS_REMOVE_kdfsan_policies.o = $(CC_FLAGS_FTRACE)
-CFLAGS_REMOVE_kdfsan_shadow.o = $(CC_FLAGS_FTRACE)
-CFLAGS_REMOVE_kdfsan_util.o = $(CC_FLAGS_FTRACE)
-CFLAGS_REMOVE_kdfsan_whitelist.o = $(CC_FLAGS_FTRACE)
-
-CFLAGS_kdfsan_custom.o := $(CC_FLAGS_KDFSAN_RUNTIME)
-CFLAGS_kdfsan_init.o := $(CC_FLAGS_KDFSAN_RUNTIME)
-CFLAGS_kdfsan_interface.o := $(CC_FLAGS_KDFSAN_RUNTIME)
-CFLAGS_kdfsan_internal.o := $(CC_FLAGS_KDFSAN_RUNTIME)
-CFLAGS_kdfsan_mm.o := $(CC_FLAGS_KDFSAN_RUNTIME)
-CFLAGS_kdfsan_policies.o := $(CC_FLAGS_KDFSAN_RUNTIME)
-CFLAGS_kdfsan_shadow.o := $(CC_FLAGS_KDFSAN_RUNTIME)
-CFLAGS_kdfsan_util.o := $(CC_FLAGS_KDFSAN_RUNTIME)
-CFLAGS_kdfsan_whitelist.o := $(CC_FLAGS_KDFSAN_RUNTIME)
-
-# TODO: Remove these
-CFLAGS_REMOVE_kdfsan_internal.o += -Werror
-CFLAGS_REMOVE_kdfsan_shadow.o += -Werror
-CFLAGS_REMOVE_kdfsan_interface.o += -Werror
-CFLAGS_REMOVE_kdfsan_policies.o += -Werror
diff --git a/mm/kdfsan/kdfsan_abilist_arm64.txt b/mm/kdfsan/kdfsan_abilist_arm64.txt
deleted file mode 100644
index 37d2a054ac26..000000000000
--- a/mm/kdfsan/kdfsan_abilist_arm64.txt
+++ /dev/null
@@ -1,781 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-
-# Fixes 'symbol not found' vmlinux.lds errors
-fun:kvm_get_kimage_voffset=uninstrumented
-fun:kvm_get_kimage_voffset=discard
-fun:kvm_compute_final_ctr_el0=uninstrumented
-fun:kvm_compute_final_ctr_el0=discard
-fun:nvhe_hyp_panic_handler=uninstrumented
-fun:nvhe_hyp_panic_handler=discard
-
-# Fixes undefined references *from instrumented code*
-fun:__aes_arm64_decrypt=uninstrumented
-fun:__aes_arm64_decrypt=discard
-fun:__aes_arm64_encrypt=uninstrumented
-fun:__aes_arm64_encrypt=discard
-fun:__aes_ce_decrypt=uninstrumented
-fun:__aes_ce_decrypt=discard
-fun:__aes_ce_encrypt=uninstrumented
-fun:__aes_ce_encrypt=discard
-fun:__aes_ce_invert=uninstrumented
-fun:__aes_ce_invert=discard
-fun:__aes_ce_sub=uninstrumented
-fun:__aes_ce_sub=discard
-fun:__arch_clear_user=uninstrumented
-fun:__arch_clear_user=discard
-fun:__arch_copy_from_user=uninstrumented
-fun:__arch_copy_from_user=discard
-fun:__arch_copy_in_user=uninstrumented
-fun:__arch_copy_in_user=discard
-fun:__arch_copy_to_user=uninstrumented
-fun:__arch_copy_to_user=discard
-fun:__arm64_compat_sys_lookup_dcookie=uninstrumented
-fun:__arm64_compat_sys_lookup_dcookie=discard
-fun:__arm64_sys_bpf=uninstrumented
-fun:__arm64_sys_bpf=discard
-fun:__arm64_sys_landlock_add_rule=uninstrumented
-fun:__arm64_sys_landlock_add_rule=discard
-fun:__arm64_sys_landlock_create_ruleset=uninstrumented
-fun:__arm64_sys_landlock_create_ruleset=discard
-fun:__arm64_sys_landlock_restrict_self=uninstrumented
-fun:__arm64_sys_landlock_restrict_self=discard
-fun:__arm64_sys_lookup_dcookie=uninstrumented
-fun:__arm64_sys_lookup_dcookie=discard
-fun:__arm64_sys_pciconfig_iobase=uninstrumented
-fun:__arm64_sys_pciconfig_iobase=discard
-fun:__arm64_sys_pkey_alloc=uninstrumented
-fun:__arm64_sys_pkey_alloc=discard
-fun:__arm64_sys_pkey_free=uninstrumented
-fun:__arm64_sys_pkey_free=discard
-fun:__arm64_sys_pkey_mprotect=uninstrumented
-fun:__arm64_sys_pkey_mprotect=discard
-fun:__arm64_sys_uselib=uninstrumented
-fun:__arm64_sys_uselib=discard
-fun:__arm64_sys_userfaultfd=uninstrumented
-fun:__arm64_sys_userfaultfd=discard
-fun:__arm_smccc_hvc=uninstrumented
-fun:__arm_smccc_hvc=discard
-fun:__arm_smccc_smc=uninstrumented
-fun:__arm_smccc_smc=discard
-fun:ce_aes_cbc_cts_decrypt=uninstrumented
-fun:ce_aes_cbc_cts_decrypt=discard
-fun:ce_aes_cbc_cts_encrypt=uninstrumented
-fun:ce_aes_cbc_cts_encrypt=discard
-fun:ce_aes_cbc_decrypt=uninstrumented
-fun:ce_aes_cbc_decrypt=discard
-fun:ce_aes_cbc_encrypt=uninstrumented
-fun:ce_aes_cbc_encrypt=discard
-fun:ce_aes_ccm_auth_data=uninstrumented
-fun:ce_aes_ccm_auth_data=discard
-fun:ce_aes_ccm_decrypt=uninstrumented
-fun:ce_aes_ccm_decrypt=discard
-fun:ce_aes_ccm_encrypt=uninstrumented
-fun:ce_aes_ccm_encrypt=discard
-fun:ce_aes_ccm_final=uninstrumented
-fun:ce_aes_ccm_final=discard
-fun:ce_aes_ctr_encrypt=uninstrumented
-fun:ce_aes_ctr_encrypt=discard
-fun:ce_aes_ecb_decrypt=uninstrumented
-fun:ce_aes_ecb_decrypt=discard
-fun:ce_aes_ecb_encrypt=uninstrumented
-fun:ce_aes_ecb_encrypt=discard
-fun:ce_aes_essiv_cbc_decrypt=uninstrumented
-fun:ce_aes_essiv_cbc_decrypt=discard
-fun:ce_aes_essiv_cbc_encrypt=uninstrumented
-fun:ce_aes_essiv_cbc_encrypt=discard
-fun:ce_aes_mac_update=uninstrumented
-fun:ce_aes_mac_update=discard
-fun:ce_aes_xts_decrypt=uninstrumented
-fun:ce_aes_xts_decrypt=discard
-fun:ce_aes_xts_encrypt=uninstrumented
-fun:ce_aes_xts_encrypt=discard
-fun:__clean_dcache_area_pou=uninstrumented
-fun:__clean_dcache_area_pou=discard
-fun:clear_page_orig=uninstrumented
-fun:clear_page_orig=discard
-fun:copy_page_orig=uninstrumented
-fun:copy_page_orig=discard
-fun:cpu_logical_map=uninstrumented
-fun:cpu_logical_map=discard
-fun:_cpu_resume=uninstrumented
-fun:_cpu_resume=discard
-fun:cpu_resume=uninstrumented
-fun:cpu_resume=discard
-fun:__cpu_soft_restart=uninstrumented
-fun:__cpu_soft_restart=discard
-fun:__cpu_suspend_enter=uninstrumented
-fun:__cpu_suspend_enter=discard
-fun:cpu_switch_to=uninstrumented
-fun:cpu_switch_to=discard
-fun:create_pgd_mapping=uninstrumented
-fun:create_pgd_mapping=discard
-fun:__dma_flush_area=uninstrumented
-fun:__dma_flush_area=discard
-fun:__dma_map_area=uninstrumented
-fun:__dma_map_area=discard
-fun:__dma_unmap_area=uninstrumented
-fun:__dma_unmap_area=discard
-fun:do_one_initcall=uninstrumented
-fun:do_one_initcall=discard
-fun:__efi_rt_asm_wrapper=uninstrumented
-fun:__efi_rt_asm_wrapper=discard
-fun:__flush_cache_user_range=uninstrumented
-fun:__flush_cache_user_range=discard
-fun:__flush_dcache_area=uninstrumented
-fun:__flush_dcache_area=discard
-fun:__flush_icache_range=uninstrumented
-fun:__flush_icache_range=discard
-fun:fpsimd_load_state=uninstrumented
-fun:fpsimd_load_state=discard
-fun:__fpsimd_restore_state=uninstrumented
-fun:__fpsimd_restore_state=discard
-fun:__fpsimd_save_state=uninstrumented
-fun:__fpsimd_save_state=discard
-fun:fpsimd_save_state=uninstrumented
-fun:fpsimd_save_state=discard
-fun:get_early_fdt_ptr=uninstrumented
-fun:get_early_fdt_ptr=discard
-fun:__guest_enter=uninstrumented
-fun:__guest_enter=discard
-fun:HYPERVISOR_console_io=uninstrumented
-fun:HYPERVISOR_console_io=discard
-fun:HYPERVISOR_dm_op=uninstrumented
-fun:HYPERVISOR_dm_op=discard
-fun:HYPERVISOR_event_channel_op=uninstrumented
-fun:HYPERVISOR_event_channel_op=discard
-fun:HYPERVISOR_grant_table_op=uninstrumented
-fun:HYPERVISOR_grant_table_op=discard
-fun:HYPERVISOR_hvm_op=uninstrumented
-fun:HYPERVISOR_hvm_op=discard
-fun:HYPERVISOR_memory_op=uninstrumented
-fun:HYPERVISOR_memory_op=discard
-fun:HYPERVISOR_multicall=uninstrumented
-fun:HYPERVISOR_multicall=discard
-fun:HYPERVISOR_physdev_op=uninstrumented
-fun:HYPERVISOR_physdev_op=discard
-fun:HYPERVISOR_platform_op_raw=uninstrumented
-fun:HYPERVISOR_platform_op_raw=discard
-fun:HYPERVISOR_sched_op=uninstrumented
-fun:HYPERVISOR_sched_op=discard
-fun:HYPERVISOR_tmem_op=uninstrumented
-fun:HYPERVISOR_tmem_op=discard
-fun:HYPERVISOR_vcpu_op=uninstrumented
-fun:HYPERVISOR_vcpu_op=discard
-fun:HYPERVISOR_vm_assist=uninstrumented
-fun:HYPERVISOR_vm_assist=discard
-fun:HYPERVISOR_xen_version=uninstrumented
-fun:HYPERVISOR_xen_version=discard
-fun:__hyp_reset_vectors=uninstrumented
-fun:__hyp_reset_vectors=discard
-fun:__hyp_set_vectors=uninstrumented
-fun:__hyp_set_vectors=discard
-fun:idmap_cpu_replace_ttbr1=uninstrumented
-fun:idmap_cpu_replace_ttbr1=discard
-fun:idmap_kpti_install_ng_mappings=uninstrumented
-fun:idmap_kpti_install_ng_mappings=discard
-fun:invalidate_icache_range=uninstrumented
-fun:invalidate_icache_range=discard
-fun:kcov_common_handle=uninstrumented
-fun:kcov_common_handle=discard
-fun:kcov_remote_start=uninstrumented
-fun:kcov_remote_start=discard
-fun:kcov_remote_stop=uninstrumented
-fun:kcov_remote_stop=discard
-fun:kcov_task_exit=uninstrumented
-fun:kcov_task_exit=discard
-fun:kcov_task_init=uninstrumented
-fun:kcov_task_init=discard
-fun:mark_linear_text_alias_ro=uninstrumented
-fun:mark_linear_text_alias_ro=discard
-fun:memblock_add=uninstrumented
-fun:memblock_add=discard
-fun:memblock_alloc_exact_nid_raw=uninstrumented
-fun:memblock_alloc_exact_nid_raw=discard
-fun:memblock_alloc_range_nid=uninstrumented
-fun:memblock_alloc_range_nid=discard
-fun:memblock_alloc_try_nid=uninstrumented
-fun:memblock_alloc_try_nid=discard
-fun:memblock_alloc_try_nid_raw=uninstrumented
-fun:memblock_alloc_try_nid_raw=discard
-fun:memblock_dump_all=uninstrumented
-fun:memblock_dump_all=discard
-fun:memblock_end_of_DRAM=uninstrumented
-fun:memblock_end_of_DRAM=discard
-fun:memblock_find_in_range=uninstrumented
-fun:memblock_find_in_range=discard
-fun:memblock_free=uninstrumented
-fun:memblock_free=discard
-fun:__memblock_free_late=uninstrumented
-fun:__memblock_free_late=discard
-fun:memblock_is_map_memory=uninstrumented
-fun:memblock_is_map_memory=discard
-fun:memblock_is_region_memory=uninstrumented
-fun:memblock_is_region_memory=discard
-fun:memblock_is_region_reserved=uninstrumented
-fun:memblock_is_region_reserved=discard
-fun:memblock_mark_hotplug=uninstrumented
-fun:memblock_mark_hotplug=discard
-fun:memblock_mark_nomap=uninstrumented
-fun:memblock_mark_nomap=discard
-fun:memblock_phys_alloc_range=uninstrumented
-fun:memblock_phys_alloc_range=discard
-fun:memblock_phys_alloc_try_nid=uninstrumented
-fun:memblock_phys_alloc_try_nid=discard
-fun:memblock_remove=uninstrumented
-fun:memblock_remove=discard
-fun:memblock_reserve=uninstrumented
-fun:memblock_reserve=discard
-fun:memblock_search_pfn_nid=uninstrumented
-fun:memblock_search_pfn_nid=discard
-fun:memblock_set_node=uninstrumented
-fun:memblock_set_node=discard
-fun:memblock_start_of_DRAM=uninstrumented
-fun:memblock_start_of_DRAM=discard
-fun:__next_mem_pfn_range=uninstrumented
-fun:__next_mem_pfn_range=discard
-fun:__next_mem_range=uninstrumented
-fun:__next_mem_range=discard
-fun:__next_mem_range_rev=uninstrumented
-fun:__next_mem_range_rev=discard
-fun:pfn_valid=uninstrumented
-fun:pfn_valid=discard
-fun:phys_mem_access_prot=uninstrumented
-fun:phys_mem_access_prot=discard
-fun:pmd_clear_huge=uninstrumented
-fun:pmd_clear_huge=discard
-fun:pmd_free_pte_page=uninstrumented
-fun:pmd_free_pte_page=discard
-fun:pmd_set_huge=uninstrumented
-fun:pmd_set_huge=discard
-fun:pmull_gcm_decrypt=uninstrumented
-fun:pmull_gcm_decrypt=discard
-fun:pmull_gcm_encrypt=uninstrumented
-fun:pmull_gcm_encrypt=discard
-fun:pmull_ghash_update_p64=uninstrumented
-fun:pmull_ghash_update_p64=discard
-fun:pmull_ghash_update_p8=uninstrumented
-fun:pmull_ghash_update_p8=discard
-fun:privcmd_call=uninstrumented
-fun:privcmd_call=discard
-fun:pud_clear_huge=uninstrumented
-fun:pud_clear_huge=discard
-fun:pud_free_pmd_page=uninstrumented
-fun:pud_free_pmd_page=discard
-fun:pud_set_huge=uninstrumented
-fun:pud_set_huge=discard
-fun:ret_from_fork=uninstrumented
-fun:ret_from_fork=discard
-fun:__sanitizer_cov_trace_cmp1=uninstrumented
-fun:__sanitizer_cov_trace_cmp1=discard
-fun:__sanitizer_cov_trace_cmp2=uninstrumented
-fun:__sanitizer_cov_trace_cmp2=discard
-fun:__sanitizer_cov_trace_cmp4=uninstrumented
-fun:__sanitizer_cov_trace_cmp4=discard
-fun:__sanitizer_cov_trace_cmp8=uninstrumented
-fun:__sanitizer_cov_trace_cmp8=discard
-fun:__sanitizer_cov_trace_const_cmp1=uninstrumented
-fun:__sanitizer_cov_trace_const_cmp1=discard
-fun:__sanitizer_cov_trace_const_cmp2=uninstrumented
-fun:__sanitizer_cov_trace_const_cmp2=discard
-fun:__sanitizer_cov_trace_const_cmp4=uninstrumented
-fun:__sanitizer_cov_trace_const_cmp4=discard
-fun:__sanitizer_cov_trace_const_cmp8=uninstrumented
-fun:__sanitizer_cov_trace_const_cmp8=discard
-fun:__sanitizer_cov_trace_pc=uninstrumented
-fun:__sanitizer_cov_trace_pc=discard
-fun:__sanitizer_cov_trace_switch=uninstrumented
-fun:__sanitizer_cov_trace_switch=discard
-fun:secondary_entry=uninstrumented
-fun:secondary_entry=discard
-fun:secondary_holding_pen=uninstrumented
-fun:secondary_holding_pen=discard
-fun:__set_fixmap=uninstrumented
-fun:__set_fixmap=discard
-fun:set_swapper_pgd=uninstrumented
-fun:set_swapper_pgd=discard
-fun:sha1_ce_transform=uninstrumented
-fun:sha1_ce_transform=discard
-fun:sha256_block_data_order=uninstrumented
-fun:sha256_block_data_order=discard
-fun:sha256_block_neon=uninstrumented
-fun:sha256_block_neon=discard
-fun:sha2_ce_transform=uninstrumented
-fun:sha2_ce_transform=discard
-fun:sve_flush_live=uninstrumented
-fun:sve_flush_live=discard
-fun:sve_get_vl=uninstrumented
-fun:sve_get_vl=discard
-fun:sve_load_state=uninstrumented
-fun:sve_load_state=discard
-fun:__sve_restore_state=uninstrumented
-fun:__sve_restore_state=discard
-fun:__sve_save_state=uninstrumented
-fun:__sve_save_state=discard
-fun:sve_save_state=uninstrumented
-fun:sve_save_state=discard
-fun:sve_set_vq=uninstrumented
-fun:sve_set_vq=discard
-fun:sys_ni_syscall=uninstrumented
-fun:sys_ni_syscall=discard
-fun:vmemmap_populate=uninstrumented
-fun:vmemmap_populate=discard
-
-# Fixes undefined references *from uninstrumented code*
-fun:acpi_boot_table_init=uninstrumented
-fun:acpi_boot_table_init=discard
-fun:acpi_early_init=uninstrumented
-fun:acpi_early_init=discard
-fun:acpi_iort_dma_get_max_cpu_address=uninstrumented
-fun:acpi_iort_dma_get_max_cpu_address=discard
-fun:acpi_subsystem_init=uninstrumented
-fun:acpi_subsystem_init=discard
-fun:acpi_table_upgrade=uninstrumented
-fun:acpi_table_upgrade=discard
-fun:add_device_randomness=uninstrumented
-fun:add_device_randomness=discard
-fun:__alloc_pages=uninstrumented
-fun:__alloc_pages=discard
-fun:anon_vma_init=uninstrumented
-fun:anon_vma_init=discard
-fun:arch_numa_init=uninstrumented
-fun:arch_numa_init=discard
-fun:arm64_hugetlb_cma_reserve=uninstrumented
-fun:arm64_hugetlb_cma_reserve=discard
-fun:arm64_preempt_schedule_irq=uninstrumented
-fun:arm64_preempt_schedule_irq=discard
-fun:async_synchronize_full=uninstrumented
-fun:async_synchronize_full=discard
-fun:atomic_notifier_chain_register=uninstrumented
-fun:atomic_notifier_chain_register=discard
-fun:bad_mode=uninstrumented
-fun:bad_mode=discard
-fun:boot_cpu_hotplug_init=uninstrumented
-fun:boot_cpu_hotplug_init=discard
-fun:boot_cpu_init=uninstrumented
-fun:boot_cpu_init=discard
-fun:build_all_zonelists=uninstrumented
-fun:build_all_zonelists=discard
-fun:calibrate_delay=uninstrumented
-fun:calibrate_delay=discard
-fun:call_function_init=uninstrumented
-fun:call_function_init=discard
-fun:cgroup_init=uninstrumented
-fun:cgroup_init=discard
-fun:cgroup_init_early=uninstrumented
-fun:cgroup_init_early=discard
-fun:complete=uninstrumented
-fun:complete=discard
-fun:console_init=uninstrumented
-fun:console_init=discard
-fun:cpu_do_switch_mm=uninstrumented
-fun:cpu_do_switch_mm=discard
-fun:cpumask_next=uninstrumented
-fun:cpumask_next=discard
-fun:cpuset_init=uninstrumented
-fun:cpuset_init=discard
-fun:cpuset_init_smp=uninstrumented
-fun:cpuset_init_smp=discard
-fun:cpu_startup_entry=uninstrumented
-fun:cpu_startup_entry=discard
-fun:__crc32c_le_base=uninstrumented
-fun:__crc32c_le_base=discard
-fun:crc32_le_base=uninstrumented
-fun:crc32_le_base=discard
-fun:cred_init=uninstrumented
-fun:cred_init=discard
-fun:debugfs_attr_read=uninstrumented
-fun:debugfs_attr_read=discard
-fun:debugfs_attr_write=uninstrumented
-fun:debugfs_attr_write=discard
-fun:debugfs_create_bool=uninstrumented
-fun:debugfs_create_bool=discard
-fun:debugfs_create_dir=uninstrumented
-fun:debugfs_create_dir=discard
-fun:debugfs_create_file=uninstrumented
-fun:debugfs_create_file=discard
-fun:debugfs_create_file_unsafe=uninstrumented
-fun:debugfs_create_file_unsafe=discard
-fun:debugfs_create_u8=uninstrumented
-fun:debugfs_create_u8=discard
-fun:delayacct_init=uninstrumented
-fun:delayacct_init=discard
-fun:dma_contiguous_reserve=uninstrumented
-fun:dma_contiguous_reserve=discard
-fun:dma_pernuma_cma_reserve=uninstrumented
-fun:dma_pernuma_cma_reserve=discard
-fun:do_el0_irq_bp_hardening=uninstrumented
-fun:do_el0_irq_bp_hardening=discard
-fun:do_notify_resume=uninstrumented
-fun:do_notify_resume=discard
-fun:do_serror=uninstrumented
-fun:do_serror=discard
-fun:do_sysctl_args=uninstrumented
-fun:do_sysctl_args=discard
-fun:driver_init=uninstrumented
-fun:driver_init=discard
-fun:dt_mem_next_cell=uninstrumented
-fun:dt_mem_next_cell=discard
-fun:dump_cpu_features=uninstrumented
-fun:dump_cpu_features=discard
-fun:dump_stack=uninstrumented
-fun:dump_stack=discard
-fun:dump_stack_set_arch_desc=uninstrumented
-fun:dump_stack_set_arch_desc=discard
-fun:early_init_dt_scan=uninstrumented
-fun:early_init_dt_scan=discard
-fun:early_init_fdt_scan_reserved_mem=uninstrumented
-fun:early_init_fdt_scan_reserved_mem=discard
-fun:early_ioremap_init=uninstrumented
-fun:early_ioremap_init=discard
-fun:early_ioremap_reset=uninstrumented
-fun:early_ioremap_reset=discard
-fun:early_irq_init=uninstrumented
-fun:early_irq_init=discard
-fun:early_memtest=uninstrumented
-fun:early_memtest=discard
-fun:early_security_init=uninstrumented
-fun:early_security_init=discard
-fun:efi_handle_corrupted_x18=uninstrumented
-fun:efi_handle_corrupted_x18=discard
-fun:efi_init=uninstrumented
-fun:efi_init=discard
-fun:el0_sync_compat_handler=uninstrumented
-fun:el0_sync_compat_handler=discard
-fun:el0_sync_handler=uninstrumented
-fun:el0_sync_handler=discard
-fun:el1_sync_handler=uninstrumented
-fun:el1_sync_handler=discard
-fun:enter_el1_irq_or_nmi=uninstrumented
-fun:enter_el1_irq_or_nmi=discard
-fun:exit_el1_irq_or_nmi=uninstrumented
-fun:exit_el1_irq_or_nmi=discard
-fun:filp_open=uninstrumented
-fun:filp_open=discard
-fun:find_task_by_pid_ns=uninstrumented
-fun:find_task_by_pid_ns=discard
-fun:first_online_pgdat=uninstrumented
-fun:first_online_pgdat=discard
-fun:fork_init=uninstrumented
-fun:fork_init=discard
-fun:fput=uninstrumented
-fun:fput=discard
-fun:free_area_init=uninstrumented
-fun:free_area_init=discard
-fun:__free_pages=uninstrumented
-fun:__free_pages=discard
-fun:free_pages=uninstrumented
-fun:free_pages=discard
-fun:free_reserved_area=uninstrumented
-fun:free_reserved_area=discard
-fun:get_cpu_ops=uninstrumented
-fun:get_cpu_ops=discard
-fun:__get_free_pages=uninstrumented
-fun:__get_free_pages=discard
-fun:get_option=uninstrumented
-fun:get_option=discard
-fun:get_random_bytes=uninstrumented
-fun:get_random_bytes=discard
-fun:housekeeping_init=uninstrumented
-fun:housekeeping_init=discard
-fun:hrtimers_init=uninstrumented
-fun:hrtimers_init=discard
-fun:hyp_panic=uninstrumented
-fun:hyp_panic=discard
-fun:init_cpu_ops=uninstrumented
-fun:init_cpu_ops=discard
-fun:init_dup=uninstrumented
-fun:init_dup=discard
-fun:init_eaccess=uninstrumented
-fun:init_eaccess=discard
-fun:init_feature_override=uninstrumented
-fun:init_feature_override=discard
-fun:init_IRQ=uninstrumented
-fun:init_IRQ=discard
-fun:init_irq_proc=uninstrumented
-fun:init_irq_proc=discard
-fun:init_mem_debugging_and_hardening=uninstrumented
-fun:init_mem_debugging_and_hardening=discard
-fun:init_mm_internals=uninstrumented
-fun:init_mm_internals=discard
-fun:init_timers=uninstrumented
-fun:init_timers=discard
-fun:integrity_load_keys=uninstrumented
-fun:integrity_load_keys=discard
-fun:kaslr_requires_kpti=uninstrumented
-fun:kaslr_requires_kpti=discard
-fun:kernel_execve=uninstrumented
-fun:kernel_execve=discard
-fun:kernel_thread=uninstrumented
-fun:kernel_thread=discard
-fun:key_init=uninstrumented
-fun:key_init=discard
-fun:kfree=uninstrumented
-fun:kfree=discard
-fun:__kmalloc=uninstrumented
-fun:__kmalloc=discard
-fun:__kmalloc_node=uninstrumented
-fun:__kmalloc_node=discard
-fun:kmalloc_order=uninstrumented
-fun:kmalloc_order=discard
-fun:kmem_cache_alloc=uninstrumented
-fun:kmem_cache_alloc=discard
-fun:kmem_cache_init=uninstrumented
-fun:kmem_cache_init=discard
-fun:kmem_cache_init_late=uninstrumented
-fun:kmem_cache_init_late=discard
-fun:kstrtobool=uninstrumented
-fun:kstrtobool=discard
-fun:kthreadd=uninstrumented
-fun:kthreadd=discard
-fun:ktime_get=uninstrumented
-fun:ktime_get=discard
-fun:kvm_hyp_reserve=uninstrumented
-fun:kvm_hyp_reserve=discard
-fun:kvm_patch_vector_branch=uninstrumented
-fun:kvm_patch_vector_branch=discard
-fun:kvm_unexpected_el2_exception=uninstrumented
-fun:kvm_unexpected_el2_exception=discard
-fun:kvm_update_va_mask=uninstrumented
-fun:kvm_update_va_mask=discard
-fun:memblock_free_pages=uninstrumented
-fun:memblock_free_pages=discard
-fun:memdup_user=uninstrumented
-fun:memdup_user=discard
-fun:mem_init_print_info=uninstrumented
-fun:mem_init_print_info=discard
-fun:memparse=uninstrumented
-fun:memparse=discard
-fun:__mod_lruvec_page_state=uninstrumented
-fun:__mod_lruvec_page_state=discard
-fun:next_online_pgdat=uninstrumented
-fun:next_online_pgdat=discard
-fun:no_llseek=uninstrumented
-fun:no_llseek=discard
-fun:nonseekable_open=uninstrumented
-fun:nonseekable_open=discard
-fun:nsfs_init=uninstrumented
-fun:nsfs_init=discard
-fun:numa_default_policy=uninstrumented
-fun:numa_default_policy=discard
-fun:numa_policy_init=uninstrumented
-fun:numa_policy_init=discard
-fun:of_dma_get_max_cpu_address=uninstrumented
-fun:of_dma_get_max_cpu_address=discard
-fun:of_flat_dt_get_machine_name=uninstrumented
-fun:of_flat_dt_get_machine_name=discard
-fun:of_get_flat_dt_prop=uninstrumented
-fun:of_get_flat_dt_prop=discard
-fun:of_scan_flat_dt=uninstrumented
-fun:of_scan_flat_dt=discard
-fun:page_alloc_init=uninstrumented
-fun:page_alloc_init=discard
-fun:page_alloc_init_late=uninstrumented
-fun:page_alloc_init_late=discard
-fun:pagecache_init=uninstrumented
-fun:pagecache_init=discard
-fun:panic=uninstrumented
-fun:panic=discard
-fun:parameq=uninstrumented
-fun:parameq=discard
-fun:parameqn=uninstrumented
-fun:parameqn=discard
-fun:parse_args=uninstrumented
-fun:parse_args=discard
-fun:parse_crashkernel=uninstrumented
-fun:parse_crashkernel=discard
-fun:perf_event_init=uninstrumented
-fun:perf_event_init=discard
-fun:pid_idr_init=uninstrumented
-fun:pid_idr_init=discard
-fun:preempt_schedule=uninstrumented
-fun:preempt_schedule=discard
-fun:prepare_namespace=uninstrumented
-fun:prepare_namespace=discard
-fun:printk=uninstrumented
-fun:printk=discard
-fun:proc_caches_init=uninstrumented
-fun:proc_caches_init=discard
-fun:proc_root_init=uninstrumented
-fun:proc_root_init=discard
-fun:profile_init=uninstrumented
-fun:profile_init=discard
-fun:psci_acpi_init=uninstrumented
-fun:psci_acpi_init=discard
-fun:psci_dt_init=uninstrumented
-fun:psci_dt_init=discard
-fun:radix_tree_init=uninstrumented
-fun:radix_tree_init=discard
-fun:rand_initialize=uninstrumented
-fun:rand_initialize=discard
-fun:_raw_spin_lock=uninstrumented
-fun:_raw_spin_lock=discard
-fun:_raw_spin_lock_irqsave=uninstrumented
-fun:_raw_spin_lock_irqsave=discard
-fun:_raw_spin_unlock=uninstrumented
-fun:_raw_spin_unlock=discard
-fun:_raw_spin_unlock_irqrestore=uninstrumented
-fun:_raw_spin_unlock_irqrestore=discard
-fun:rcu_barrier=uninstrumented
-fun:rcu_barrier=discard
-fun:rcu_end_inkernel_boot=uninstrumented
-fun:rcu_end_inkernel_boot=discard
-fun:rcu_init=uninstrumented
-fun:rcu_init=discard
-fun:rcu_init_tasks_generic=uninstrumented
-fun:rcu_init_tasks_generic=discard
-fun:__rcu_read_lock=uninstrumented
-fun:__rcu_read_lock=discard
-fun:__rcu_read_unlock=uninstrumented
-fun:__rcu_read_unlock=discard
-fun:rcu_scheduler_starting=uninstrumented
-fun:rcu_scheduler_starting=discard
-fun:__read_sysreg_by_encoding=uninstrumented
-fun:__read_sysreg_by_encoding=discard
-fun:refcount_warn_saturate=uninstrumented
-fun:refcount_warn_saturate=discard
-fun:register_cpu=uninstrumented
-fun:register_cpu=discard
-fun:__register_one_node=uninstrumented
-fun:__register_one_node=discard
-fun:request_resource=uninstrumented
-fun:request_resource=discard
-fun:reserve_bootmem_region=uninstrumented
-fun:reserve_bootmem_region=discard
-fun:reserve_region_with_split=uninstrumented
-fun:reserve_region_with_split=discard
-fun:sched_clock_init=uninstrumented
-fun:sched_clock_init=discard
-fun:sched_init=uninstrumented
-fun:sched_init=discard
-fun:sched_init_smp=uninstrumented
-fun:sched_init_smp=discard
-fun:schedule_preempt_disabled=uninstrumented
-fun:schedule_preempt_disabled=discard
-fun:schedule_tail=uninstrumented
-fun:schedule_tail=discard
-fun:secondary_start_kernel=uninstrumented
-fun:secondary_start_kernel=discard
-fun:security_init=uninstrumented
-fun:security_init=discard
-fun:seq_file_init=uninstrumented
-fun:seq_file_init=discard
-fun:seq_lseek=uninstrumented
-fun:seq_lseek=discard
-fun:seq_printf=uninstrumented
-fun:seq_printf=discard
-fun:seq_read=uninstrumented
-fun:seq_read=discard
-fun:set_cpus_allowed_ptr=uninstrumented
-fun:set_cpus_allowed_ptr=discard
-fun:set_task_stack_end_magic=uninstrumented
-fun:set_task_stack_end_magic=discard
-fun:setup_log_buf=uninstrumented
-fun:setup_log_buf=discard
-fun:setup_nr_cpu_ids=uninstrumented
-fun:setup_nr_cpu_ids=discard
-fun:setup_per_cpu_areas=uninstrumented
-fun:setup_per_cpu_areas=discard
-fun:setup_per_cpu_pageset=uninstrumented
-fun:setup_per_cpu_pageset=discard
-fun:signals_init=uninstrumented
-fun:signals_init=discard
-fun:simple_attr_open=uninstrumented
-fun:simple_attr_open=discard
-fun:simple_attr_release=uninstrumented
-fun:simple_attr_release=discard
-fun:single_open=uninstrumented
-fun:single_open=discard
-fun:single_release=uninstrumented
-fun:single_release=discard
-fun:slab_is_available=uninstrumented
-fun:slab_is_available=discard
-fun:smp_init=uninstrumented
-fun:smp_init=discard
-fun:smp_init_cpus=uninstrumented
-fun:smp_init_cpus=discard
-fun:smp_prepare_boot_cpu=uninstrumented
-fun:smp_prepare_boot_cpu=discard
-fun:smp_prepare_cpus=uninstrumented
-fun:smp_prepare_cpus=discard
-fun:snprintf=uninstrumented
-fun:snprintf=discard
-fun:softirq_init=uninstrumented
-fun:softirq_init=discard
-fun:sort_main_extable=uninstrumented
-fun:sort_main_extable=discard
-fun:sparse_init=uninstrumented
-fun:sparse_init=discard
-fun:spectre_v4_patch_fw_mitigation_conduit=uninstrumented
-fun:spectre_v4_patch_fw_mitigation_conduit=discard
-fun:spectre_v4_patch_fw_mitigation_enable=uninstrumented
-fun:spectre_v4_patch_fw_mitigation_enable=discard
-fun:split_page=uninstrumented
-fun:split_page=discard
-fun:sprint_symbol_no_offset=uninstrumented
-fun:sprint_symbol_no_offset=discard
-fun:__stack_chk_fail=uninstrumented
-fun:__stack_chk_fail=discard
-fun:__sw_hweight64=uninstrumented
-fun:__sw_hweight64=discard
-fun:swiotlb_init=uninstrumented
-fun:swiotlb_init=discard
-fun:taskstats_init_early=uninstrumented
-fun:taskstats_init_early=discard
-fun:tick_init=uninstrumented
-fun:tick_init=discard
-fun:time_init=uninstrumented
-fun:time_init=discard
-fun:timekeeping_init=uninstrumented
-fun:timekeeping_init=discard
-fun:trap_init=uninstrumented
-fun:trap_init=discard
-fun:unflatten_device_tree=uninstrumented
-fun:unflatten_device_tree=discard
-fun:__usermodehelper_set_disable_depth=uninstrumented
-fun:__usermodehelper_set_disable_depth=discard
-fun:uts_ns_init=uninstrumented
-fun:uts_ns_init=discard
-fun:vfree=uninstrumented
-fun:vfree=discard
-fun:vfs_caches_init=uninstrumented
-fun:vfs_caches_init=discard
-fun:vfs_caches_init_early=uninstrumented
-fun:vfs_caches_init_early=discard
-fun:vmalloc=uninstrumented
-fun:vmalloc=discard
-fun:vmalloc_init=uninstrumented
-fun:vmalloc_init=discard
-fun:vmalloc_to_page=uninstrumented
-fun:vmalloc_to_page=discard
-fun:vmalloc_user=uninstrumented
-fun:vmalloc_user=discard
-fun:vm_area_add_early=uninstrumented
-fun:vm_area_add_early=discard
-fun:vmemmap_alloc_block_buf=uninstrumented
-fun:vmemmap_alloc_block_buf=discard
-fun:vmemmap_p4d_populate=uninstrumented
-fun:vmemmap_p4d_populate=discard
-fun:vmemmap_pgd_populate=uninstrumented
-fun:vmemmap_pgd_populate=discard
-fun:vmemmap_populate_basepages=uninstrumented
-fun:vmemmap_populate_basepages=discard
-fun:vmemmap_pud_populate=uninstrumented
-fun:vmemmap_pud_populate=discard
-fun:vmemmap_verify=uninstrumented
-fun:vmemmap_verify=discard
-fun:vm_insert_page=uninstrumented
-fun:vm_insert_page=discard
-fun:vunmap_range=uninstrumented
-fun:vunmap_range=discard
-fun:wait_for_completion=uninstrumented
-fun:wait_for_completion=discard
-fun:wait_for_initramfs=uninstrumented
-fun:wait_for_initramfs=discard
-fun:__warn_printk=uninstrumented
-fun:__warn_printk=discard
-fun:workqueue_init=uninstrumented
-fun:workqueue_init=discard
-fun:workqueue_init_early=uninstrumented
-fun:workqueue_init_early=discard
-fun:xen_early_init=uninstrumented
-fun:xen_early_init=discard
diff --git a/mm/kdfsan/kdfsan_abilist_base.txt b/mm/kdfsan/kdfsan_abilist_base.txt
deleted file mode 100644
index 0c4154fc0db4..000000000000
--- a/mm/kdfsan/kdfsan_abilist_base.txt
+++ /dev/null
@@ -1,138 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-
-# KDFSan interfaces
-fun:dfsan_union=uninstrumented
-fun:dfsan_union=discard
-fun:dfsan_create_label=uninstrumented
-fun:dfsan_create_label=discard
-fun:dfsan_set_label=uninstrumented
-fun:dfsan_set_label=discard
-fun:dfsan_add_label=uninstrumented
-fun:dfsan_add_label=discard
-fun:dfsan_get_label=uninstrumented
-fun:dfsan_get_label=custom
-fun:dfsan_read_label=uninstrumented
-fun:dfsan_read_label=discard
-fun:dfsan_get_label_count=uninstrumented
-fun:dfsan_get_label_count=discard
-fun:dfsan_get_label_info=uninstrumented
-fun:dfsan_get_label_info=discard
-fun:dfsan_has_label=uninstrumented
-fun:dfsan_has_label=discard
-fun:dfsan_has_label_with_desc=uninstrumented
-fun:dfsan_has_label_with_desc=discard
-fun:dfsan_get_label_with_desc=uninstrumented
-fun:dfsan_get_label_with_desc=discard
-fun:__dfsan_mem_transfer_with_rip=uninstrumented
-fun:__dfsan_mem_transfer_with_rip=discard
-fun:__dfsan_mem_transfer=uninstrumented
-fun:__dfsan_mem_transfer=discard
-fun:dfsan_copy_label_info=uninstrumented
-fun:dfsan_copy_label_info=discard
-
-# KDFsan context hooks
-fun:kdfsan_get_context=uninstrumented
-fun:kdfsan_get_context=discard
-fun:kdfsan_task_create=uninstrumented
-fun:kdfsan_task_create=discard
-
-# KDFSan mm hooks
-fun:kdfsan_alloc_page=uninstrumented
-fun:kdfsan_alloc_page=discard
-fun:kdfsan_free_page=uninstrumented
-fun:kdfsan_free_page=discard
-fun:kdfsan_split_page=uninstrumented
-fun:kdfsan_split_page=discard
-fun:kdfsan_copy_page_shadow=uninstrumented
-fun:kdfsan_copy_page_shadow=discard
-fun:kdfsan_init_late=uninstrumented
-fun:kdfsan_init_late=discard
-fun:kdfsan_init_runtime=uninstrumented
-fun:kdfsan_init_runtime=discard
-fun:kdfsan_init_shadow=uninstrumented
-fun:kdfsan_init_shadow=discard
-
-# KDFSan policies interfaces
-fun:kdfsan_syscall_arg=uninstrumented
-fun:kdfsan_syscall_arg=discard
-fun:kdfsan_dma_alloc=uninstrumented
-fun:kdfsan_dma_alloc=discard
-fun:kdfsan_dma_free=uninstrumented
-fun:kdfsan_dma_free=discard
-fun:kdfsan_dma_alloc_sg=uninstrumented
-fun:kdfsan_dma_alloc_sg=discard
-fun:kdfsan_dma_free_sg=uninstrumented
-fun:kdfsan_dma_free_sg=discard
-fun:kdfsan_dma_sync=uninstrumented
-fun:kdfsan_dma_sync=discard
-fun:kdfsan_dma_sync_sg=uninstrumented
-fun:kdfsan_dma_sync_sg=discard
-fun:kdfsan_ioremap=uninstrumented
-fun:kdfsan_ioremap=discard
-fun:kdfsan_iounmap=uninstrumented
-fun:kdfsan_iounmap=discard
-fun:kdfsan_pmio_out=uninstrumented
-fun:kdfsan_pmio_out=discard
-fun:kdfsan_pmio_out_with_rip=uninstrumented
-fun:kdfsan_pmio_out_with_rip=discard
-fun:kdfsan_pmio_in=uninstrumented
-fun:kdfsan_pmio_in=discard
-fun:kdfsan_pmio_in_with_rip=uninstrumented
-fun:kdfsan_pmio_in_with_rip=discard
-fun:kdfsan_bugon=uninstrumented
-fun:kdfsan_bugon=discard
-fun:kdfsan_domain_enter=uninstrumented
-fun:kdfsan_domain_enter=discard
-fun:kdfsan_domain_exit=uninstrumented
-fun:kdfsan_domain_exit=discard
-fun:kdfsan_policies_get_getuser_label=uninstrumented
-fun:kdfsan_policies_get_getuser_label=discard
-fun:kdfsan_policies_is_df_label=uninstrumented
-fun:kdfsan_policies_is_df_label=discard
-
-# KDFSan wrappers
-fun:__dfsw_*=uninstrumented
-fun:__dfsw_*=discard
-
-# KDFSan tests
-fun:kdfsan_run_base_tests=uninstrumented
-fun:kdfsan_run_base_tests=discard
-fun:kdfsan_run_policies_tests=uninstrumented
-fun:kdfsan_run_policies_tests=discard
-
-##############################################################################
-
-# Custom wrappers  (only for calls from instrumented code, because calls from uninstrumented code wouldn't even call the wrappers)
-
-fun:__memcpy=uninstrumented
-fun:__memcpy=custom
-fun:__memcpy_mcsafe=uninstrumented
-fun:__memcpy_mcsafe=custom
-fun:__memmove=uninstrumented
-fun:__memmove=custom
-fun:__memset=uninstrumented
-fun:__memset=custom
-fun:memcpy=uninstrumented
-fun:memcpy=custom
-fun:memset=uninstrumented
-fun:memset=custom
-fun:memset16=uninstrumented
-fun:memset16=custom
-fun:memset32=uninstrumented
-fun:memset32=custom
-fun:memset64=uninstrumented
-fun:memset64=custom
-fun:strcpy=uninstrumented
-fun:strcpy=custom
-fun:strlcat=uninstrumented
-fun:strlcat=custom
-fun:strlcpy=uninstrumented
-fun:strlcpy=custom
-fun:strnchr=uninstrumented
-fun:strnchr=custom
-fun:strreplace=uninstrumented
-fun:strreplace=custom
-fun:strsep=uninstrumented
-fun:strsep=custom
-fun:strstr=uninstrumented
-fun:strstr=custom
diff --git a/mm/kdfsan/kdfsan_abilist_x86.txt b/mm/kdfsan/kdfsan_abilist_x86.txt
deleted file mode 100644
index f6824350d52d..000000000000
--- a/mm/kdfsan/kdfsan_abilist_x86.txt
+++ /dev/null
@@ -1,255 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-
-# Fixes undefined references *from instrumented code*
-fun:arch_cpu_finalize_init=uninstrumented
-fun:arch_cpu_finalize_init=discard
-fun:arch_rethook_trampoline=uninstrumented
-fun:arch_rethook_trampoline=discard
-fun:asm_exc_alignment_check=uninstrumented
-fun:asm_exc_alignment_check=discard
-fun:asm_exc_bounds=uninstrumented
-fun:asm_exc_bounds=discard
-fun:asm_exc_coprocessor_error=uninstrumented
-fun:asm_exc_coprocessor_error=discard
-fun:asm_exc_coproc_segment_overrun=uninstrumented
-fun:asm_exc_coproc_segment_overrun=discard
-fun:asm_exc_debug=uninstrumented
-fun:asm_exc_debug=discard
-fun:asm_exc_device_not_available=uninstrumented
-fun:asm_exc_device_not_available=discard
-fun:asm_exc_divide_error=uninstrumented
-fun:asm_exc_divide_error=discard
-fun:asm_exc_double_fault=uninstrumented
-fun:asm_exc_double_fault=discard
-fun:asm_exc_general_protection=uninstrumented
-fun:asm_exc_general_protection=discard
-fun:asm_exc_int3=uninstrumented
-fun:asm_exc_int3=discard
-fun:asm_exc_invalid_op=uninstrumented
-fun:asm_exc_invalid_op=discard
-fun:asm_exc_invalid_tss=uninstrumented
-fun:asm_exc_invalid_tss=discard
-fun:asm_exc_machine_check=uninstrumented
-fun:asm_exc_machine_check=discard
-fun:asm_exc_nmi=uninstrumented
-fun:asm_exc_nmi=discard
-fun:asm_exc_overflow=uninstrumented
-fun:asm_exc_overflow=discard
-fun:asm_exc_page_fault=uninstrumented
-fun:asm_exc_page_fault=discard
-fun:asm_exc_segment_not_present=uninstrumented
-fun:asm_exc_segment_not_present=discard
-fun:asm_exc_simd_coprocessor_error=uninstrumented
-fun:asm_exc_simd_coprocessor_error=discard
-fun:asm_exc_spurious_interrupt_bug=uninstrumented
-fun:asm_exc_spurious_interrupt_bug=discard
-fun:asm_exc_stack_segment=uninstrumented
-fun:asm_exc_stack_segment=discard
-fun:asm_load_gs_index=uninstrumented
-fun:asm_load_gs_index=discard
-fun:asm_sysvec_apic_timer_interrupt=uninstrumented
-fun:asm_sysvec_apic_timer_interrupt=discard
-fun:asm_sysvec_deferred_error=uninstrumented
-fun:asm_sysvec_deferred_error=discard
-fun:asm_sysvec_error_interrupt=uninstrumented
-fun:asm_sysvec_error_interrupt=discard
-fun:asm_sysvec_irq_work=uninstrumented
-fun:asm_sysvec_irq_work=discard
-fun:asm_sysvec_kvm_posted_intr_ipi=uninstrumented
-fun:asm_sysvec_kvm_posted_intr_ipi=discard
-fun:asm_sysvec_kvm_posted_intr_nested_ipi=uninstrumented
-fun:asm_sysvec_kvm_posted_intr_nested_ipi=discard
-fun:asm_sysvec_kvm_posted_intr_wakeup_ipi=uninstrumented
-fun:asm_sysvec_kvm_posted_intr_wakeup_ipi=discard
-fun:asm_sysvec_spurious_apic_interrupt=uninstrumented
-fun:asm_sysvec_spurious_apic_interrupt=discard
-fun:asm_sysvec_thermal=uninstrumented
-fun:asm_sysvec_thermal=discard
-fun:asm_sysvec_threshold=uninstrumented
-fun:asm_sysvec_threshold=discard
-fun:asm_sysvec_x86_platform_ipi=uninstrumented
-fun:asm_sysvec_x86_platform_ipi=discard
-fun:cea_set_pte=uninstrumented
-fun:cea_set_pte=discard
-fun:cet_disable=uninstrumented
-fun:cet_disable=discard
-fun:check_null_seg_clears_base=uninstrumented
-fun:check_null_seg_clears_base=discard
-fun:clear_page_erms=uninstrumented
-fun:clear_page_erms=discard
-fun:clear_page_orig=uninstrumented
-fun:clear_page_orig=discard
-fun:clear_page_rep=uninstrumented
-fun:clear_page_rep=discard
-fun:copy_mc_enhanced_fast_string=uninstrumented
-fun:copy_mc_enhanced_fast_string=discard
-fun:copy_mc_fragile=uninstrumented
-fun:copy_mc_fragile=discard
-fun:copy_page_orig=uninstrumented
-fun:copy_page_orig=discard
-fun:__copy_user_nocache=uninstrumented
-fun:__copy_user_nocache=discard
-fun:cpu_detect_cache_sizes=uninstrumented
-fun:cpu_detect_cache_sizes=discard
-fun:cpu_init=uninstrumented
-fun:cpu_init=discard
-fun:cpu_init_exception_handling=uninstrumented
-fun:cpu_init_exception_handling=discard
-fun:cr4_read_shadow=uninstrumented
-fun:cr4_read_shadow=discard
-fun:cr4_update_irqsoff=uninstrumented
-fun:cr4_update_irqsoff=discard
-fun:detect_ht_early=uninstrumented
-fun:detect_ht_early=discard
-fun:detect_num_cpu_cores=uninstrumented
-fun:detect_num_cpu_cores=discard
-fun:do_suspend_lowlevel=uninstrumented
-fun:do_suspend_lowlevel=discard
-fun:early_cpu_init=uninstrumented
-fun:early_cpu_init=discard
-fun:__efi64_thunk=uninstrumented
-fun:__efi64_thunk=discard
-fun:__efi_call=uninstrumented
-fun:__efi_call=discard
-fun:__end_entry_SYSENTER_compat=uninstrumented
-fun:__end_entry_SYSENTER_compat=discard
-fun:entry_INT80_compat=uninstrumented
-fun:entry_INT80_compat=discard
-fun:entry_SYSENTER_compat=uninstrumented
-fun:entry_SYSENTER_compat=discard
-fun:get_cpu_cap=uninstrumented
-fun:get_cpu_cap=discard
-fun:get_cpu_entry_area=uninstrumented
-fun:get_cpu_entry_area=discard
-fun:get_llc_id=uninstrumented
-fun:get_llc_id=discard
-fun:int3_magic=uninstrumented
-fun:int3_magic=discard
-fun:int3_selftest_ip=uninstrumented
-fun:int3_selftest_ip=discard
-fun:kcov_common_handle=uninstrumented
-fun:kcov_common_handle=discard
-fun:kcov_remote_start=uninstrumented
-fun:kcov_remote_start=discard
-fun:kcov_remote_stop=uninstrumented
-fun:kcov_remote_stop=discard
-fun:kcov_task_exit=uninstrumented
-fun:kcov_task_exit=discard
-fun:kcov_task_init=uninstrumented
-fun:kcov_task_init=discard
-fun:load_direct_gdt=uninstrumented
-fun:load_direct_gdt=discard
-fun:load_fixmap_gdt=uninstrumented
-fun:load_fixmap_gdt=discard
-fun:local_touch_nmi=uninstrumented
-fun:local_touch_nmi=discard
-fun:maple_tree_init=uninstrumented
-fun:maple_tree_init=discard
-fun:mas_destroy=uninstrumented
-fun:mas_destroy=discard
-fun:mas_empty_area=uninstrumented
-fun:mas_empty_area=discard
-fun:mas_empty_area_rev=uninstrumented
-fun:mas_empty_area_rev=discard
-fun:mas_erase=uninstrumented
-fun:mas_erase=discard
-fun:mas_expected_entries=uninstrumented
-fun:mas_expected_entries=discard
-fun:mas_find=uninstrumented
-fun:mas_find=discard
-fun:mas_is_err=uninstrumented
-fun:mas_is_err=discard
-fun:mas_next=uninstrumented
-fun:mas_next=discard
-fun:mas_next_range=uninstrumented
-fun:mas_next_range=discard
-fun:mas_pause=uninstrumented
-fun:mas_pause=discard
-fun:mas_preallocate=uninstrumented
-fun:mas_preallocate=discard
-fun:mas_prev=uninstrumented
-fun:mas_prev=discard
-fun:mas_store=uninstrumented
-fun:mas_store=discard
-fun:mas_store_gfp=uninstrumented
-fun:mas_store_gfp=discard
-fun:mas_store_prealloc=uninstrumented
-fun:mas_store_prealloc=discard
-fun:mas_walk=uninstrumented
-fun:mas_walk=discard
-fun:__mt_destroy=uninstrumented
-fun:__mt_destroy=discard
-fun:mt_find=uninstrumented
-fun:mt_find=discard
-fun:mtree_load=uninstrumented
-fun:mtree_load=discard
-fun:native_write_cr0=uninstrumented
-fun:native_write_cr0=discard
-fun:native_write_cr4=uninstrumented
-fun:native_write_cr4=discard
-fun:rdmsr_safe_regs=uninstrumented
-fun:rdmsr_safe_regs=discard
-fun:__register_nmi_handler=uninstrumented
-fun:__register_nmi_handler=discard
-fun:relocate_kernel=uninstrumented
-fun:relocate_kernel=discard
-fun:restart_nmi=uninstrumented
-fun:restart_nmi=discard
-fun:restore_image=uninstrumented
-fun:restore_image=discard
-fun:ret_from_fork_asm=uninstrumented
-fun:ret_from_fork_asm=discard
-fun:rewind_stack_and_make_dead=uninstrumented
-fun:rewind_stack_and_make_dead=discard
-fun:__sanitizer_cov_trace_cmp1=uninstrumented
-fun:__sanitizer_cov_trace_cmp1=discard
-fun:__sanitizer_cov_trace_cmp2=uninstrumented
-fun:__sanitizer_cov_trace_cmp2=discard
-fun:__sanitizer_cov_trace_cmp4=uninstrumented
-fun:__sanitizer_cov_trace_cmp4=discard
-fun:__sanitizer_cov_trace_cmp8=uninstrumented
-fun:__sanitizer_cov_trace_cmp8=discard
-fun:__sanitizer_cov_trace_const_cmp1=uninstrumented
-fun:__sanitizer_cov_trace_const_cmp1=discard
-fun:__sanitizer_cov_trace_const_cmp2=uninstrumented
-fun:__sanitizer_cov_trace_const_cmp2=discard
-fun:__sanitizer_cov_trace_const_cmp4=uninstrumented
-fun:__sanitizer_cov_trace_const_cmp4=discard
-fun:__sanitizer_cov_trace_const_cmp8=uninstrumented
-fun:__sanitizer_cov_trace_const_cmp8=discard
-fun:__sanitizer_cov_trace_pc=uninstrumented
-fun:__sanitizer_cov_trace_pc=discard
-fun:__sanitizer_cov_trace_switch=uninstrumented
-fun:__sanitizer_cov_trace_switch=discard
-fun:setup_cpu_entry_areas=uninstrumented
-fun:setup_cpu_entry_areas=discard
-fun:stack_depot_early_init=uninstrumented
-fun:stack_depot_early_init=discard
-fun:stack_depot_fetch=uninstrumented
-fun:stack_depot_fetch=discard
-fun:stack_depot_init=uninstrumented
-fun:stack_depot_init=discard
-fun:stack_depot_print=uninstrumented
-fun:stack_depot_print=discard
-fun:stack_depot_request_early_init=uninstrumented
-fun:stack_depot_request_early_init=discard
-fun:stack_depot_save=uninstrumented
-fun:stack_depot_save=discard
-fun:__static_call_return=uninstrumented
-fun:__static_call_return=discard
-fun:stop_nmi=uninstrumented
-fun:stop_nmi=discard
-fun:__switch_to_asm=uninstrumented
-fun:__switch_to_asm=discard
-fun:swsusp_arch_suspend=uninstrumented
-fun:swsusp_arch_suspend=discard
-fun:syscall_init=uninstrumented
-fun:syscall_init=discard
-fun:wakeup_long64=uninstrumented
-fun:wakeup_long64=discard
-fun:wrmsr_safe_regs=uninstrumented
-fun:wrmsr_safe_regs=discard
-fun:x86_read_arch_cap_msr=uninstrumented
-fun:x86_read_arch_cap_msr=discard
-
-# Fixes undefined references *from uninstrumented code*
diff --git a/mm/kdfsan/kdfsan_custom.c b/mm/kdfsan/kdfsan_custom.c
deleted file mode 100644
index cecdfab3d9d7..000000000000
--- a/mm/kdfsan/kdfsan_custom.c
+++ /dev/null
@@ -1,156 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#include "kdfsan_types.h"
-#include "kdfsan_util.h"
-#include "kdfsan_interface.h"
-
-static void *____dfsw___memcpy(void *dest, const void *src, size_t n, dfsan_label dest_label, dfsan_label src_label, dfsan_label n_label, dfsan_label *ret_label, void * rip) {
-  void * ret_val = __memcpy(dest, src, n);
-  *ret_label = dest_label;
-  dfsan_mem_transfer_with_rip(dest, src, n, dest_label, src_label, n_label, rip);
-  return ret_val;
-}
-void * noinline __dfsw___memcpy(void *dest, const void *src, size_t n, dfsan_label dest_label, dfsan_label src_label, dfsan_label n_label, dfsan_label *ret_label) {
-  return ____dfsw___memcpy(dest, src, n, dest_label, src_label, n_label, ret_label, __builtin_return_address(0));
-}
-void * noinline __dfsw_memcpy(void *dest, const void *src, size_t n, dfsan_label dest_label, dfsan_label src_label, dfsan_label n_label, dfsan_label *ret_label) {
-  return ____dfsw___memcpy(dest, src, n, dest_label, src_label, n_label, ret_label, __builtin_return_address(0));
-}
-
-static void *____dfsw___memset(void *ptr, int val, size_t n, dfsan_label ptr_label, dfsan_label val_label, dfsan_label n_label, dfsan_label *ret_label, void * rip) {
-  void * ret_val = __memset(ptr, val, n);
-  *ret_label = ptr_label;
-  dfsan_store_with_rip(val, ptr, n, val_label, ptr_label, rip);
-  return ret_val;
-}
-void * noinline __dfsw___memset(void *ptr, int val, size_t n, dfsan_label ptr_label, dfsan_label val_label, dfsan_label n_label, dfsan_label *ret_label) {
-  return ____dfsw___memset(ptr, val, n, ptr_label, val_label, n_label, ret_label, __builtin_return_address(0));
-}
-void * noinline __dfsw_memset(void *ptr, int val, size_t n, dfsan_label ptr_label, dfsan_label val_label, dfsan_label n_label, dfsan_label *ret_label) {
-  return ____dfsw___memset(ptr, val, n, ptr_label, val_label, n_label, ret_label, __builtin_return_address(0));
-}
-
-void * noinline __dfsw_memset16(uint16_t *s, uint16_t v, size_t count, dfsan_label s_label, dfsan_label v_label, dfsan_label count_label, dfsan_label *ret_label) {
-  void * ret_val = memset16(s, v, count);
-  *ret_label = s_label;
-  dfsan_store_with_rip(v, s, count * sizeof(uint16_t), v_label, s_label, __builtin_return_address(0));
-  return ret_val;
-}
-
-void * noinline __dfsw_memset32(uint32_t *s, uint32_t v, size_t count, dfsan_label s_label, dfsan_label v_label, dfsan_label count_label, dfsan_label *ret_label) {
-  void * ret_val = memset32(s, v, count);
-  *ret_label = s_label;
-  dfsan_store_with_rip(v, s, count * sizeof(uint32_t), v_label, s_label, __builtin_return_address(0));
-  return ret_val;
-}
-
-void * noinline __dfsw_memset64(uint64_t *s, uint64_t v, size_t count, dfsan_label s_label, dfsan_label v_label, dfsan_label count_label, dfsan_label *ret_label) {
-  void * ret_val = memset64(s, v, count);
-  *ret_label = s_label;
-  dfsan_store_with_rip(v, s, count * sizeof(uint64_t), v_label, s_label, __builtin_return_address(0));
-  return ret_val;
-}
-
-void * noinline __dfsw___memmove(void *dest, const void *src, size_t n, dfsan_label dest_label, dfsan_label src_label, dfsan_label n_label, dfsan_label *ret_label) {
-  void * ret_val = __memmove(dest, src, n);
-  *ret_label = dest_label;
-  dfsan_mem_transfer_with_rip(dest, src, n, dest_label, src_label, n_label, __builtin_return_address(0));
-  return ret_val;
-}
-
-char * noinline __dfsw_strcpy(char *dest, const char *src, dfsan_label dest_label, dfsan_label src_label, dfsan_label *ret_label) {
-  char * ret_val = strcpy(dest, src);
-  *ret_label = dest_label;
-  dfsan_mem_transfer_with_rip(dest, src, kdf_util_strlen(src)+1, dest_label, src_label, 0, __builtin_return_address(0));
-  return ret_val;
-}
-
-size_t noinline __dfsw_strlcat(char *dest, const char *src, size_t count, dfsan_label dest_label, dfsan_label src_label, dfsan_label count_label, dfsan_label *ret_label) {
-  size_t dsize = kdf_util_strlen(dest);
-  size_t len = kdf_util_strlen(src);
-  size_t res = dsize + len;
-  *ret_label = dfsan_union(dest_label, src_label);
-
-  /* This would be a bug */
-  BUG_ON(dsize >= count);
-
-  dest += dsize;
-  count -= dsize;
-  if (len >= count)
-  len = count-1;
-  __memcpy(dest, src, len);
-  dfsan_mem_transfer_with_rip(dest, src, len, dest_label, src_label, count_label, __builtin_return_address(0));
-  dest[len] = 0;
-  dfsan_set_label(0, &dest[len], sizeof(char)); // Not performing store policy for NULL terminator
-  return res;
-}
-
-size_t noinline __dfsw_strlcpy(char *dest, const char *src, size_t size, dfsan_label dest_label, dfsan_label src_label, dfsan_label size_label, dfsan_label *ret_label) {
-  size_t ret = kdf_util_strlen(src);
-  *ret_label = src_label;
-
-  if (size) {
-    size_t len = (ret >= size) ? size - 1 : ret;
-    dfsan_label len_label = (ret >= size) ? size_label : 0;
-    __memcpy(dest, src, len);
-    dfsan_mem_transfer_with_rip(dest, src, len, dest_label, src_label, len_label, __builtin_return_address(0));
-    dest[len] = '\0';
-    dfsan_set_label(0, &dest[len], sizeof(char)); // Not performing store policy for NULL terminator
-  }
-  return ret;
-}
-
-char *__dfsw_strnchr(const char *s, size_t count, int c, dfsan_label s_label, dfsan_label count_label, dfsan_label c_label, dfsan_label *ret_label) {
-  while (count--) {
-    if (*s == (char)c) {
-      *ret_label = dfsan_read_label(s, sizeof(char));
-      return (char *)s;
-    }
-    if (*s++ == '\0') {
-      break;
-    }
-  }
-  *ret_label = 0;
-  return NULL;
-}
-
-char * noinline __dfsw_strreplace(char *s, char old, char new, dfsan_label s_label, dfsan_label old_label, dfsan_label new_label, dfsan_label *ret_label) {
-  for (; *s; ++s) {
-    if (*s == old) {
-      *s = new;
-      dfsan_store_with_rip(new, s, sizeof(char), new_label, s_label, __builtin_return_address(0));
-    }
-  }
-  *ret_label = s_label;
-  return s;
-}
-
-char *__dfsw_strsep(char **s, const char *ct, dfsan_label s_label, dfsan_label ct_label, dfsan_label *ret_label) {
-  char *sbegin = *s;
-  char *end;
-
-  if (sbegin == NULL) {
-    *ret_label = 0;
-    return NULL;
-  }
-
-  end = kdf_util_strpbrk(sbegin, ct);
-  if (end) {
-    *end = '\0';
-    dfsan_set_label(0, end, sizeof(char)); // Not performing store policy for NULL terminator
-    end++;
-  }
-  *s = end;
-  *ret_label = s_label;
-  return sbegin;
-}
-
-char *__dfsw_strstr(const char *s1, const char *s2, dfsan_label s1_label, dfsan_label s2_label, dfsan_label *ret_label) {
-  char * ret_val = strstr(s1, s2);
-  if (ret_val == NULL) {
-    *ret_label = 0;
-  } else {
-    *ret_label = s1_label;
-  }
-  return ret_val;
-}
diff --git a/mm/kdfsan/kdfsan_init.c b/mm/kdfsan/kdfsan_init.c
deleted file mode 100644
index 761c63a992af..000000000000
--- a/mm/kdfsan/kdfsan_init.c
+++ /dev/null
@@ -1,240 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-// Shadow memory initialization based on KMSAN's
-
-#include "kdfsan_types.h"
-#include "kdfsan_internal.h"
-#include "kdfsan_shadow.h"
-#include "kdfsan_policies.h"
-#include "kdfsan_interface.h"
-#include "kdfsan_whitelist.h"
-
-#include <asm/sections.h>
-#include <linux/mm.h>
-#include <linux/memblock.h>
-#include <linux/debugfs.h>
-
-/*********************************************************************/
-/************************** Early-boot shadow init *******************/
-
-#define NUM_FUTURE_RANGES 128
-struct start_end_pair {
-  void *start, *end;
-};
-
-static struct start_end_pair start_end_pairs[NUM_FUTURE_RANGES] __initdata;
-static int future_index __initdata;
-
-/*
- * Record a range of memory for which the metadata pages will be created once
- * the page allocator becomes available.
- */
-static void __init kdf_record_future_shadow_range(void *start, void *end) {
-	u64 nstart = (u64)start, nend = (u64)end, cstart, cend;
-	bool merged = false;
-
-	KDF_PANIC_ON(future_index == NUM_FUTURE_RANGES, "KDFSan init error: check 1 in kdf_record_future_shadow_range failed");
-	KDF_PANIC_ON((nstart >= nend) || !nstart || !nend, "KDFSan init error: check 2 in kdf_record_future_shadow_range failed");
-	nstart = ALIGN_DOWN(nstart, PAGE_SIZE);
-	nend = ALIGN(nend, PAGE_SIZE);
-
-	/*
-	 * Scan the existing ranges to see if any of them overlaps with
-	 * [start, end). In that case, merge the two ranges instead of
-	 * creating a new one.
-	 * The number of ranges is less than 20, so there is no need to organize
-	 * them into a more intelligent data structure.
-	 */
-	for (int i = 0; i < future_index; i++) {
-		cstart = (u64)start_end_pairs[i].start;
-		cend = (u64)start_end_pairs[i].end;
-		if ((cstart < nstart && cend < nstart) ||
-		    (cstart > nend && cend > nend))
-			/* ranges are disjoint - do not merge */
-			continue;
-		start_end_pairs[i].start = (void *)min(nstart, cstart);
-		start_end_pairs[i].end = (void *)max(nend, cend);
-		merged = true;
-		break;
-	}
-	if (merged)
-		return;
-        printk("%s: recording region %px-%px\n", __func__, start, end);
-	start_end_pairs[future_index].start = (void *)nstart;
-	start_end_pairs[future_index].end = (void *)nend;
-	future_index++;
-}
-
-/* Allocate metadata for pages allocated at boot time. */
-static void __init kdf_init_alloc_meta_for_range(void *start, void *end) {
-  u64 addr, size;
-  struct page *page;
-  void *shadow;
-  struct page *shadow_p;
-  printk("%s: Initializing region %px-%px\n",__func__,start,end);
-  // FIXME: Potential bug -- If a range is in the same region as another range, then it will have >1 shadow page allocated for it
-  printk("Initializing shadow for region at %px-%px\n", start, end);
-  start = (void *)ALIGN_DOWN((u64)start, PAGE_SIZE);
-  size = ALIGN((u64)end - (u64)start, PAGE_SIZE);
-  shadow = memblock_alloc(size, PAGE_SIZE);
-  for (addr = 0; addr < size; addr += PAGE_SIZE) {
-    page = kdf_virt_to_page_or_null((char *)start + addr);
-    if (page == NULL) { panic("Cannot get page struct for memory at %px.\n", (char *)start + addr); }
-    shadow_p = kdf_virt_to_page_or_null((char *)shadow + addr);
-    if (shadow_p == NULL) { panic("Cannot get page struct for shadow memory at %px...\n", (char *)shadow + addr); }
-    shadow_p->shadow = NULL;
-    page->shadow = shadow_p;
-  }
-}
-
-/*
- * Initialize the shadow for existing mappings during kernel initialization.
- * These include kernel text/data sections, NODE_DATA and future ranges
- * registered while creating other data (e.g. percpu).
- *
- * Allocations via memblock can be only done before slab is initialized.
- */
-void __init kdfsan_init_shadow(void) {
-	const size_t nd_size = roundup(sizeof(pg_data_t), PAGE_SIZE);
-	phys_addr_t p_start, p_end;
-	u64 loop;
-	int nid;
-
-        printk("KDFSan: Initializing shadow...\n");
-
-        printk("%s: recording all reserved memblock regions...\n",__func__);
-	for_each_reserved_mem_range(loop, &p_start, &p_end)
-		kdf_record_future_shadow_range(phys_to_virt(p_start),
-						 phys_to_virt(p_end));
-
-        printk("%s: recording .data region...\n",__func__);
-	/* Allocate shadow for .data */
-	kdf_record_future_shadow_range(_sdata, _edata);
-
-        printk("%s: recording all online nodes regions...\n",__func__);
-	for_each_online_node(nid)
-		kdf_record_future_shadow_range(
-			NODE_DATA(nid), (char *)NODE_DATA(nid) + nd_size);
-
-        printk("%s: allocating %d ranges...\n",__func__,future_index);
-	for (int i = 0; i < future_index; i++)
-		kdf_init_alloc_meta_for_range(
-			(void *)start_end_pairs[i].start,
-			(void *)start_end_pairs[i].end);
-        printk("KDFSan: Shadow initialized.\n");
-}
-
-/********************************************************************/
-/************************** Kernel parameters ***********************/
-
-// NOTE: Need __read_mostly or else these will land in .bss!
-bool __read_mostly kdf_param_run_tests = false;
-bool __read_mostly kdf_param_early_enable = false;
-bool __read_mostly kdf_param_generic_syscall_label = false;
-kdfsan_whitelist_type_t __read_mostly kdf_param_whitelist = KDFSAN_WHITELIST_TASKNAME;
-
-static int __init kdf_param_run_tests_handler(char *str) { kdf_param_run_tests = simple_strtol(str, NULL, 0); return 1; }
-static int __init kdf_param_early_enable_handler(char *str) { kdf_param_early_enable = simple_strtol(str, NULL, 0); return 1; }
-static int __init kdf_param_generic_syscall_label_handler(char *str) { kdf_param_generic_syscall_label = simple_strtol(str, NULL, 0); return 1; }
-static int __init kdf_param_whitelist_handler(char *str) {
-  KDF_PANIC_ON(strlen(str) != 1, "KDFSan error: kdf_param_whitelist should be a single character");
-  char w = str[0];
-  KDF_PANIC_ON(!kdf_is_a_whitelist_type(w), "KDFSan error: Unsupported kdf_param_whitelist type");
-  kdf_param_whitelist = w;
-  return 1;
-}
-
-__setup("kdf_param_run_tests=", kdf_param_run_tests_handler);
-__setup("kdf_param_early_enable=", kdf_param_early_enable_handler);
-__setup("kdf_param_generic_syscall_label=", kdf_param_generic_syscall_label_handler);
-__setup("kdf_param_whitelist=", kdf_param_whitelist_handler);
-
-/**********************************************************************/
-/************************** Enable and tests **************************/
-
-void kdfsan_run_base_tests(void);
-void kdfsan_run_policies_tests(void);
-
-// Warning: SUPER janky code to get the tests to work with task whitelisting
-#define SET_WHITELIST_TASK() \
-  char _saved_str[TASK_COMM_LEN]; \
-  if (kdf_param_whitelist == KDFSAN_WHITELIST_TASKNAME) { \
-    kdf_util_strlcpy(_saved_str, current->comm, TASK_COMM_LEN); \
-    kdf_util_strlcpy(current->comm, "kdfsan_task", TASK_COMM_LEN); \
-  }
-#define RESET_TASK() \
-  if (kdf_param_whitelist == KDFSAN_WHITELIST_TASKNAME) kdf_util_strlcpy(current->comm, _saved_str, TASK_COMM_LEN);
-
-static void kdfsan_base_tests(void) {
-  if (kdf_param_run_tests) {
-    unsigned long ini = 0, end = 0;
-    printk("KDFSan: Running KDFSan base tests...\n");
-    ini=get_cycles(); kdfsan_run_base_tests(); end=get_cycles();
-    printk("KDFSan: KDFSan base tests complete (%liM cycles elapsed)", (end-ini)/1000000);
-  }
-}
-
-static void kdfsan_policies_tests(void) {
-  if (kdf_param_run_tests) {
-    unsigned long ini = 0, end = 0;
-    SET_WHITELIST_TASK();
-    printk("KDFSan: Running KDFSan policies tests...\n");
-    ini=get_cycles(); kdfsan_run_policies_tests(); end=get_cycles();
-    printk("KDFSan: KDFSan policies tests complete (%liM cycles elapsed)", (end-ini)/1000000);
-    RESET_TASK();
-  }
-}
-
-static void kdfsan_enable(void) {
-  printk("KDFSan: Enabling...\n");
-  kdf_enable();
-}
-
-/********************************************************************/
-/************************** Early-boot runtime init *****************/
-
-void __init kdfsan_init_runtime(void) {
-  printk("KDFSan: Initializing internal data...\n");
-  kdf_internal_task_create(current);
-  kdf_init_internal_data();
-
-  printk("KDFSan: Initializing custom tainting policies...\n");
-  kdf_policies_init();
-
-  printk("KDFSan: Initialization done.\n");
-  kdfsan_domain_enter();
-  if (kdf_param_early_enable) {
-    kdfsan_enable();
-    kdfsan_base_tests();
-    // Not running the policies tests because userspace/drivers/etc. haven't been initialized yet.
-  }
-}
-
-/********************************************************************/
-/************************** Late-boot debugfs init ******************/
-
-static int kdfsan_post_boot(void *data, u64 *val);
-DEFINE_DEBUGFS_ATTRIBUTE(kdfsan_post_boot_fops, kdfsan_post_boot, NULL, "%lld\n");
-
-int __init kdfsan_init_late(void) {
-  printk("KDFSan: Initializing debugfs...\n");
-  struct dentry *kdfsan_dir  = debugfs_create_dir("kdfsan", NULL);
-  debugfs_create_file("post_boot", 0444, kdfsan_dir, NULL, &kdfsan_post_boot_fops);
-  printk("KDFSan: Late initialization done.\n");
-  return 0;
-}
-postcore_initcall(kdfsan_init_late);
-
-/**********************************************************************/
-/************************** Post-boot *********************************/
-
-static int kdfsan_post_boot(void *data, u64 *val) {
-  printk("KDFSan: Post boot...\n");
-  kdf_policies_post_boot();
-  if (!kdf_enabled()) {
-    kdfsan_enable();
-    kdfsan_base_tests();
-    kdfsan_policies_tests();
-  }
-  printk("KDFSan: Post boot done.\n");
-  return 0;
-}
diff --git a/mm/kdfsan/kdfsan_interface.c b/mm/kdfsan/kdfsan_interface.c
deleted file mode 100644
index 7ec1e1e1afc5..000000000000
--- a/mm/kdfsan/kdfsan_interface.c
+++ /dev/null
@@ -1,389 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#include "kdfsan_types.h"
-#include "kdfsan_internal.h"
-#include "kdfsan_mm.h"
-#include "kdfsan_policies.h"
-#include "kdfsan_whitelist.h"
-
-/************************************************************/
-/********************** Interface data **********************/
-
-DEFINE_PER_CPU(struct kdfsan_ctx, kdfsan_percpu_ctx);
-
-// NOTE: Need __read_mostly or else this will land in .bss!
-static bool __read_mostly kdfsan_enabled = false;
-
-/***********************************************************/
-/********* Enter/leave guards for run-time library *********/
-
-void kdf_enable(void) { kdfsan_enabled = true; }
-bool kdf_enabled(void) { return kdfsan_enabled; }
-void kdf_kill(void) { kdfsan_enabled = false; }
-
-struct kdfsan_ctx *kdfsan_get_context(void) {
-  return in_task() ? &current->kdfsan_ctx : raw_cpu_ptr(&kdfsan_percpu_ctx);
-}
-
-static bool kdfsan_in_runtime(void) {
-  if ((hardirq_count() >> HARDIRQ_SHIFT) > 1) return true;
-  if (in_nmi()) return true;
-  return kdfsan_get_context()->kdfsan_in_runtime;
-}
-
-static void kdfsan_enter_runtime(void) {
-  struct kdfsan_ctx *ctx;
-  ctx = kdfsan_get_context();
-  KDFSAN_WARN_ON(ctx->kdfsan_in_runtime < 0);
-  ctx->kdfsan_in_runtime++;
-}
-
-static void kdfsan_leave_runtime(void) {
-  struct kdfsan_ctx *ctx = kdfsan_get_context();
-  KDFSAN_WARN_ON(ctx->kdfsan_in_runtime < 0);
-  ctx->kdfsan_in_runtime--;
-}
-
-/***********************************************************/
-/*************** Interfaces inserted by pass ***************/
-
-dfsan_label noinline __dfsan_read_label(const void *addr, uptr size) {
-  if (size == 0 || !kdfsan_enabled || kdfsan_in_runtime()) return 0;
-  kdfsan_enter_runtime();
-  dfsan_label ret = kdf_read_label(addr,size);
-  KDF_CHECK_LABEL(ret);
-  kdfsan_leave_runtime();
-  return ret;
-}
-
-void noinline __dfsan_set_label(dfsan_label label, void *addr, uptr size) {
-  if (size == 0 || !kdfsan_enabled || kdfsan_in_runtime()) return;
-  kdfsan_enter_runtime();
-  KDF_CHECK_LABEL(label);
-  kdf_set_label(label,addr,size);
-  kdfsan_leave_runtime();
-}
-
-dfsan_label noinline __dfsan_union(dfsan_label l1, dfsan_label l2) {
-  if (l1 == 0) return l2;
-  if (l2 == 0) return l1;
-  if (l1 == l2) return l1;
-  if (!kdfsan_enabled || kdfsan_in_runtime()) return 0;
-  kdfsan_enter_runtime();
-  KDF_CHECK_LABEL(l1); KDF_CHECK_LABEL(l2);
-  dfsan_label ret = kdf_union(l1,l2);
-  KDF_CHECK_LABEL(ret);
-  kdfsan_leave_runtime();
-  return ret;
-}
-
-void noinline __dfsan_vararg_wrapper(const char *fname) {
-  if (!kdfsan_enabled || kdfsan_in_runtime()) return;
-  kdfsan_enter_runtime();
-  printk("KDFSan ERROR: unsupported indirect call to vararg\n");
-  kdfsan_leave_runtime();
-}
-
-/********************************************************************/
-/*************** Callback interfaces inserted by pass ***************/
-
-/* TODO: The KDFSAN pass _might_ need to be picky about which loads/stores to
- * check, similar to how KASAN only instruments "interesting" loads/stores. At
- * least for Kasper (where the KDFSAN pass runs after the KASAN pass), we only
- * inserted load/store callbacks for the accesses which were hooked by KASAN.
- * Otherwise, KDFSAN would instrument too many accesses, and result in a crash.
- */
-
-// NOTE: Performs policies but NOT shadow operation or pointer propagation
-dfsan_label noinline __dfsan_load_callback(void *addr, uptr size, dfsan_label data_label, dfsan_label ptr_label) {
-  if (size == 0 || !kdfsan_enabled || kdfsan_in_runtime()) return 0;
-  if (!KDFSAN_POLICY_LOAD || !kdfsan_is_whitelist_task()) return data_label;
-  kdfsan_enter_runtime();
-  KDF_CHECK_LABEL(data_label); KDF_CHECK_LABEL(ptr_label);
-  dfsan_label ret = kdf_policies_load(addr, size, data_label, ptr_label, __builtin_return_address(0));
-  kdfsan_leave_runtime();
-  return ret;
-}
-
-// NOTE: Performs policies but NOT shadow operation or pointer propagation
-void noinline __dfsan_store_callback(u64 data, void *addr, uptr size, dfsan_label data_label, dfsan_label ptr_label) {
-  if (!KDFSAN_POLICY_STORE || size == 0 || !kdfsan_enabled || kdfsan_in_runtime() || !kdfsan_is_whitelist_task()) return;
-  kdfsan_enter_runtime();
-  KDF_CHECK_LABEL(data_label); KDF_CHECK_LABEL(ptr_label);
-  kdf_policies_store(data, addr, size, data_label, ptr_label, __builtin_return_address(0));
-  kdfsan_leave_runtime();
-}
-// NOTE: Performs policies, shadow operation, and pointer propagation
-void noinline dfsan_store_with_rip(u64 data, void *addr, uptr size, dfsan_label data_label, dfsan_label ptr_label, void * rip) {
-  if (size == 0 || !kdfsan_enabled || kdfsan_in_runtime()) return;
-  kdfsan_enter_runtime();
-  KDF_CHECK_LABEL(data_label); KDF_CHECK_LABEL(ptr_label);
-  if (kdfsan_is_whitelist_task()) kdf_policies_store(data, addr, size, data_label, ptr_label, __builtin_return_address(0)); // 1. Store policy
-  data_label = PROPAGATE_STORE_PTR ? kdf_union(data_label, ptr_label) : data_label;                                         // 2. Store pointer propagation
-  kdf_set_label(data_label, addr, size);                                                                                    // 3. Perform shadow store
-  kdfsan_leave_runtime();
-}
-
-void noinline __dfsan_conditional_fwd_callback(dfsan_label label) {
-  if (!KDFSAN_POLICY_COND_FWD || label == 0 || !kdfsan_enabled || kdfsan_in_runtime() || !kdfsan_is_whitelist_task()) return;
-  kdfsan_enter_runtime();
-  KDF_CHECK_LABEL(label);
-  kdf_policies_cond_fwd(label, __builtin_return_address(0));
-  kdfsan_leave_runtime();
-}
-
-void noinline __dfsan_conditional_bkwd_callback(dfsan_label label) {
-  if (!KDFSAN_POLICY_COND_BKWD || label == 0 || !kdfsan_enabled || kdfsan_in_runtime() || !kdfsan_is_whitelist_task()) return;
-  kdfsan_enter_runtime();
-  KDF_CHECK_LABEL(label);
-  kdf_policies_cond_bkwd(label, __builtin_return_address(0));
-  kdfsan_leave_runtime();
-}
-
-// NOTE: Performs policies, shadow operation, and pointer propagation
-static void dfsan_mem_transfer_internal(void *dest, const void *src, uptr size, dfsan_label dest_label, dfsan_label src_label, dfsan_label size_label, void * rip) {
-  if (size == 0 || !kdfsan_enabled || kdfsan_in_runtime()) return;
-  bool perform_policies = kdfsan_is_whitelist_task();
-  kdfsan_enter_runtime();
-  // NOTE: kdf_memtransfer() performs: (i) the shadow memtransfer; (ii) if perform_policies is set, the associated load/store policies; AND (iii) pointer propagation
-  kdf_memtransfer(dest, src, size, dest_label, src_label, rip, perform_policies);
-  kdfsan_leave_runtime();
-}
-void noinline __dfsan_mem_transfer_callback(void *dest, const void *src, uptr size, dfsan_label dest_label, dfsan_label src_label, dfsan_label size_label) {
-  dfsan_mem_transfer_internal(dest, src, size, dest_label, src_label, size_label, __builtin_return_address(0));
-}
-
-/* Add noinline function attribute if/when this callback does something interesting */
-void __dfsan_cmp_callback(dfsan_label combined_label) { }
-
-/* Add noinline function attribute if/when this callback does something interesting */
-void __dfsan_conditional_callback(dfsan_label label) { }
-
-dfsan_label noinline __dfsan_and_callback(dfsan_label l1, dfsan_label l2) {
-  return 0; // Let's clear taint on 'and' instructions
-}
-
-/***************************************************************/
-/*************** Interfaces not inserted by pass ***************/
-
-void noinline dfsan_add_label(dfsan_label label_src, void *addr, uptr size) {
-  if (size == 0 || label_src == 0 || !kdfsan_enabled || kdfsan_in_runtime()) return;
-  kdfsan_enter_runtime();
-  KDF_CHECK_LABEL(label_src);
-  kdf_add_label(label_src,addr,size);
-  kdfsan_leave_runtime();
-}
-
-// TODO: userdata unused; remove
-dfsan_label noinline dfsan_create_label(const char *desc, void *userdata) {
-  if (!kdfsan_enabled || kdfsan_in_runtime()) return 0;
-  kdfsan_enter_runtime();
-  dfsan_label ret = kdf_create_label(desc);
-  KDF_CHECK_LABEL(ret);
-  kdfsan_leave_runtime();
-  return ret;
-}
-
-int noinline dfsan_has_label(dfsan_label label, dfsan_label elem) {
-  if (label == elem) return true;
-  if (!kdfsan_enabled || kdfsan_in_runtime()) return false;
-  kdfsan_enter_runtime();
-  KDF_CHECK_LABEL(label); KDF_CHECK_LABEL(elem);
-  int ret = kdf_has_label(label,elem);
-  kdfsan_leave_runtime();
-  return ret;
-}
-
-dfsan_label noinline dfsan_has_label_with_desc(dfsan_label label, const char *desc) {
-  if (desc == NULL || !kdfsan_enabled || kdfsan_in_runtime()) return false;
-  kdfsan_enter_runtime();
-  KDF_CHECK_LABEL(label);
-  dfsan_label ret = kdf_has_label_with_desc(label,desc);
-  KDF_CHECK_LABEL(ret);
-  kdfsan_leave_runtime();
-  return ret;
-}
-
-dfsan_label dfsan_get_label_with_desc(const char *desc) {
-  if (desc == NULL || !kdfsan_enabled || kdfsan_in_runtime()) return 0;
-  kdfsan_enter_runtime();
-  dfsan_label ret = kdf_get_label_with_desc(desc);
-  KDF_CHECK_LABEL(ret);
-  kdfsan_leave_runtime();
-  return ret;
-}
-
-size_t dfsan_get_label_descs(dfsan_label label, char descs_arr[][KDF_DESC_LEN], size_t descs_arr_size) {
-  if (label == 0 || descs_arr == NULL || descs_arr_size == 0 || !kdfsan_enabled || kdfsan_in_runtime()) return 0;
-  kdfsan_enter_runtime();
-  KDF_CHECK_LABEL(label);
-  size_t ret = kdf_get_label_descs(label, descs_arr, descs_arr_size);
-  kdfsan_leave_runtime();
-  return ret;
-}
-
-dfsan_label noinline dfsan_get_label_count(void) {
-  if (!kdfsan_enabled || kdfsan_in_runtime()) return 0;
-  kdfsan_enter_runtime();
-  dfsan_label ret = kdf_get_label_count();
-  kdfsan_leave_runtime();
-  return ret;
-}
-
-dfsan_label noinline dfsan_read_label(const void *addr, uptr size) {
-  return __dfsan_read_label(addr, size);
-}
-
-void noinline dfsan_set_label(dfsan_label label, void *addr, uptr size) {
-  __dfsan_set_label(label, addr, size);
-}
-
-dfsan_label noinline dfsan_union(dfsan_label l1, dfsan_label l2) {
-  return __dfsan_union(l1,l2);
-}
-
-dfsan_label noinline __dfsw_dfsan_get_label(long data, dfsan_label data_label, dfsan_label *ret_label) {
-  if (!kdfsan_enabled || kdfsan_in_runtime()) return 0;
-  *ret_label = 0;
-  return data_label;
-}
-
-// TODO: Improve KDFSAN instrumentation coverage so that this can be removed.
-dfsan_label noinline dfsan_get_label(long data) { return 0; }
-
-void noinline __dfsan_mem_transfer(void *dest, const void *src, uptr size, dfsan_label dest_label, dfsan_label src_label, dfsan_label size_label) {
-  dfsan_mem_transfer_internal(dest, src, size, dest_label, src_label, size_label, __builtin_return_address(0));
-}
-void noinline __dfsan_mem_transfer_with_rip(void *dest, const void *src, uptr size, dfsan_label dest_label, dfsan_label src_label, dfsan_label size_label, void * rip) {
-  dfsan_mem_transfer_internal(dest, src, size, dest_label, src_label, size_label, rip);
-}
-
-/************************************************************/
-/*************** Memory management interfaces ***************/
-
-int noinline kdfsan_alloc_page(struct page *page, unsigned int order, gfp_t orig_flags, int node) {
-  int ret = kdf_alloc_page(page, order, orig_flags, node);
-  return ret;
-}
-
-void noinline kdfsan_free_page(struct page *page, unsigned int order) {
-  kdf_free_page(page, order);
-}
-
-void noinline kdfsan_split_page(struct page *page, unsigned int order) {
-  kdf_split_page(page, order);
-}
-
-void noinline kdfsan_copy_page_shadow(struct page *dst, struct page *src) {
-  kdf_copy_page_shadow(dst, src);
-}
-
-/********************************************************/
-/*************** Miscellaneous interfaces ***************/
-
-void noinline dfsan_copy_label_info(dfsan_label label, char * dest, size_t count) {
-  if (!kdfsan_enabled || kdfsan_in_runtime()) return;
-  kdfsan_enter_runtime();
-  KDF_CHECK_LABEL(label);
-  kdf_copy_label_info(label, dest, count);
-  kdfsan_leave_runtime();
-}
-
-void noinline kdfsan_syscall_arg(void * arg, size_t s, int arg_num) {
-  if (!KDFSAN_POLICY_SYSCALL_ARG || !kdfsan_enabled || kdfsan_in_runtime() || !kdfsan_is_whitelist_task()) return;
-  kdfsan_enter_runtime();
-  kdf_policies_syscall_arg(arg, s, arg_num);
-  kdfsan_leave_runtime();
-}
-
-void kdfsan_dma_alloc(struct device *dev, dma_addr_t bus_addr, void * cpu_addr, size_t s, bool is_streaming_dma) {
-  kdfsan_enter_runtime();
-  kdf_policies_dma_alloc(dev, bus_addr, cpu_addr, s, is_streaming_dma, __builtin_return_address(0));
-  kdfsan_leave_runtime();
-}
-void kdfsan_dma_free(struct device *dev, dma_addr_t bus_addr) {
-  kdfsan_enter_runtime();
-  kdf_policies_dma_free(dev, bus_addr);
-  kdfsan_leave_runtime();
-}
-void kdfsan_dma_alloc_sg(struct device *dev, struct scatterlist *sg, int ents) {
-  kdfsan_enter_runtime();
-  kdf_policies_dma_alloc_sg(dev, sg, ents, __builtin_return_address(0));
-  kdfsan_leave_runtime();
-}
-void kdfsan_dma_free_sg(struct device *dev, struct scatterlist *sg, int nents) {
-  kdfsan_enter_runtime();
-  kdf_policies_dma_free_sg(dev, sg, nents);
-  kdfsan_leave_runtime();
-}
-void kdfsan_dma_sync(struct device *dev, dma_addr_t addr, size_t size, bool is_for_cpu) {
-  kdfsan_enter_runtime();
-  kdf_policies_dma_sync(dev, addr, size, is_for_cpu, __builtin_return_address(0));
-  kdfsan_leave_runtime();
-}
-void kdfsan_dma_sync_sg(struct device *dev, struct scatterlist *sg, int nelems, bool is_for_cpu) {
-  kdfsan_enter_runtime();
-  kdf_policies_dma_sync_sg(dev, sg, nelems, is_for_cpu, __builtin_return_address(0));
-  kdfsan_leave_runtime();
-}
-void kdfsan_ioremap(resource_size_t bus_addr, void __iomem *cpu_addr, size_t size) {
-  kdfsan_enter_runtime();
-  kdf_policies_ioremap(bus_addr, cpu_addr, size, __builtin_return_address(0));
-  kdfsan_leave_runtime();
-}
-void kdfsan_iounmap(void __iomem *cpu_addr) {
-  kdfsan_enter_runtime();
-  kdf_policies_iounmap(cpu_addr);
-  kdfsan_leave_runtime();
-}
-
-void kdfsan_pmio_out_with_rip(void *src, u16 port, size_t size, dfsan_label src_label, dfsan_label port_label, dfsan_label size_label, void * caller_rip) {
-  if (!KDFSAN_POLICY_IO || !kdfsan_enabled || kdfsan_in_runtime() || !kdfsan_is_whitelist_task()) return;
-  kdfsan_enter_runtime();
-  kdf_policies_pmio_out(src, port, size, src_label, port_label, size_label, caller_rip);
-  kdfsan_leave_runtime();
-}
-void kdfsan_pmio_out(void *src, u16 port, size_t size, dfsan_label src_label, dfsan_label port_label, dfsan_label size_label) {
-  kdfsan_pmio_out_with_rip(src, port, size, src_label, port_label, size_label, __builtin_return_address(0));
-}
-
-void kdfsan_pmio_in_with_rip(u16 port, size_t size, void *dest, dfsan_label port_label, dfsan_label size_label, dfsan_label dest_label, void * caller_rip) {
-  if (!KDFSAN_POLICY_IO || !kdfsan_enabled || kdfsan_in_runtime() || !kdfsan_is_whitelist_task()) return;
-  kdfsan_enter_runtime();
-  kdf_policies_pmio_in(port, size, dest, port_label, size_label, dest_label, caller_rip);
-  kdfsan_leave_runtime();
-}
-void kdfsan_pmio_in(u16 port, size_t size, void *dest, dfsan_label port_label, dfsan_label size_label, dfsan_label dest_label) {
-  kdfsan_pmio_in_with_rip(port, size, dest, port_label, size_label, dest_label, __builtin_return_address(0));
-}
-
-void kdfsan_bugon(dfsan_label label) {
-  if (!KDFSAN_POLICY_BUGON || label == 0 || !kdfsan_enabled || kdfsan_in_runtime() || !kdfsan_is_whitelist_task()) return;
-  kdfsan_enter_runtime();
-  KDF_CHECK_LABEL(label);
-  kdf_policies_bugon(label, __builtin_return_address(0));
-  kdfsan_leave_runtime();
-}
-
-void kdfsan_domain_enter(void) {
-  kdfsan_enter_runtime();
-  kdf_policies_domain_enter();
-  kdfsan_leave_runtime();
-}
-
-void kdfsan_domain_exit(void) {
-  kdfsan_enter_runtime();
-  kdf_policies_domain_exit();
-  kdfsan_leave_runtime();
-}
-
-struct kdfsan_context_state *__dfsan_get_context_state(void) {
-  return &kdfsan_get_context()->cstate;
-}
-EXPORT_SYMBOL(__dfsan_get_context_state);
-
-void kdfsan_task_create(struct task_struct *task) {
-  kdfsan_enter_runtime();
-  kdf_internal_task_create(task);
-  kdfsan_leave_runtime();
-}
diff --git a/mm/kdfsan/kdfsan_interface.h b/mm/kdfsan/kdfsan_interface.h
deleted file mode 100644
index 9dccda245622..000000000000
--- a/mm/kdfsan/kdfsan_interface.h
+++ /dev/null
@@ -1,12 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#ifndef KDFSAN_INTERFACE_H
-#define KDFSAN_INTERFACE_H
-
-void kdf_enable(void);
-bool kdf_enabled(void);
-void kdf_kill(void);
-struct kdfsan_ctx *kdfsan_get_context(void);
-void dfsan_store_with_rip(u64 data, void *addr, uptr size, dfsan_label data_label, dfsan_label ptr_label, void * rip);
-
-#endif // KDFSAN_INTERFACE_H
diff --git a/mm/kdfsan/kdfsan_internal.c b/mm/kdfsan/kdfsan_internal.c
deleted file mode 100644
index 1f8c82530bda..000000000000
--- a/mm/kdfsan/kdfsan_internal.c
+++ /dev/null
@@ -1,374 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#include "kdfsan_types.h"
-#include "kdfsan_shadow.h"
-#include "kdfsan_internal.h"
-#include "kdfsan_policies.h"
-
-#define BITVECTOR_SIZE NUM_LABELS >> INTERNAL_LABEL_LOG_BIT_WIDTH
-#define LABEL_SLOT_SIZE 8
-
-typedef struct {
-  u8 b[BITVECTOR_SIZE];
-  char desc[KDF_DESC_LEN];
-} dfsan_label_bitvector;
-
-typedef struct {
-  dfsan_label last_label;
-  /* keep also the current color, so we keep bitvector compact in the presence of many label unions*/
-  dfsan_label last_color; 
-  dfsan_label_bitvector bitvectors[NUM_LABELS];
-} dfsan_label_list;
-static dfsan_label_list* label_list = NULL;
-
-
-spinlock_t dfsan_label_lock;
-
-// These should be active with CONFIG_SMP with nosmp these are not needed
-#define kdf_enter_atomic(flags) spin_lock_irqsave(&dfsan_label_lock, flags)
-#define kdf_exit_atomic(flags)  spin_unlock_irqrestore(&dfsan_label_lock, flags)
-#define kdf_init_atomic() spin_lock_init(&dfsan_label_lock)
-// This should be enough to guarantee atomicity of a 1-2 byte value 
-#define KDF_ATOMIC_READ(value) READ_ONCE(value)
-
-
-#if 0
-// TODO activate this on !CONFIG_SMP
-#define kdf_enter_atomic(flags) 
-#define kdf_exit_atomic(flags)
-#define kdf_init_atomic()
-#define KDF_ATOMIC_READ(value) value
-#endif
-
-// An actual label within label_list (i.e., not just "NUM_LABELS - 1") to be returned when attempting to create a new label when no more labels are available
-static dfsan_label max_label = -1;
-
-/*************************************************************/
-/************************** Helpers **************************/
-
-static dfsan_label search_unique_color(dfsan_label start_label, dfsan_label color_slot, dfsan_label color_position){
-  dfsan_label it;
-  dfsan_label last_label = KDF_ATOMIC_READ(label_list->last_label);
-  for (it = start_label; it <= last_label; it++){
-      u8* b = label_list->bitvectors[it].b;
-      if (b[color_slot] != (1 << color_position)){
-          continue;
-      }
-      bool match = true;
-      for (dfsan_label j =  0; j < BITVECTOR_SIZE; j++){
-          if (j != color_slot && b[j] != 0){
-             match = false;
-             break;
-          }
-      }
-      if (match)
-          return it;
-  }
-
-  KDF_PANIC_ON(true, "search_unique_color error: Unreachable code");
-  return 0;
-}
-
-static void kdf_print_bitvector(dfsan_label lbl) {
-  KDF_CHECK_LABEL(lbl);
-  char str_kdf_print_bitvector[NUM_LABELS + 1] = {0}; // +1 for all labels + NULL terminator
-  dfsan_label last_label = KDF_ATOMIC_READ(label_list->last_label);
-
-  for(dfsan_label i = 0; i <= last_label; i++) {
-    u8 this_byte = label_list->bitvectors[lbl].b[i >> 3];
-    u8 this_bit = (this_byte >> (i % LABEL_SLOT_SIZE)) & 1;
-    str_kdf_print_bitvector[i] = this_bit ? '1' : '0';
-  }
-  printk("label %3d: bitvector=[%s...], desc=\"%s\"\n", lbl, str_kdf_print_bitvector, label_list->bitvectors[lbl].desc);
-}
-
-// Note: If b is NULL then a new label is created with a single unique bit set
-static dfsan_label kdf_create_next_label(u8 *b, const char *desc) {
-  // Check whether we can create a new label
-  if(label_list->last_label + 1 >= NUM_LABELS) {
-    //printk("KDFSan ERROR: out of labels; assigning 'max-label' label\n");
-    return max_label;
-  }
-  
-  //printk("KDFSan: last_label increased to %d",label_list->last_label);
-
-  // The safest way to do it is to lock all accesses to bitvector read/writes
-  // to gurantee all operations are coherent across concurrent thread. However
-  // as reads might be more frequent than label creation, just lock on memory
-  // writes, and only increment next_label after we insert a new label. Then
-  // readers read next_label/next_color atomically. This guarantees that readers
-  // have either the previous or next view on the label bitvectors. In the worst
-  // case scenario we might add the same label multiple times if union creation
-  // is executed concurrently from multiple threads.
-  unsigned long irq_flags;
-
-  kdf_enter_atomic(irq_flags);
-  // Modify the label count after we insert the element so we don't
-  // have inconsistencies with concurent readers.
-  dfsan_label this_label = label_list->last_label + 1;
-  dfsan_label_bitvector * this_bitvector = &label_list->bitvectors[this_label];
-
-  if(b == NULL) {
-    // If bitvector was not supplied, create one with a single unique bit set in label_list
-    dfsan_label this_color = ++label_list->last_color;
-    dfsan_label this_color_slot = this_color >> 3;
-    this_bitvector->b[this_color_slot] = 1 << (this_color % LABEL_SLOT_SIZE);
-
-  }
-  else {
-    // If bitvector was supplied, copy it into label_list
-    dfsan_label this_color = label_list->last_color;
-    dfsan_label this_color_size = (this_color >> 3) + 1;
-    __memcpy(this_bitvector->b, b, this_color_size); // size could probably just be this_label; that'd be slightly faster
-  }
-   
-  /* Now make all readers aware of this new label */
-  label_list->last_label = this_label;
-  kdf_exit_atomic(irq_flags);
-
-  kdf_util_strlcpy(this_bitvector->desc, desc, KDF_DESC_LEN);
-
-  return this_label;
-}
-
-void kdf_init_internal_data(void) {
-  size_t size = sizeof(dfsan_label_list);
-  printk("kdf_alloc_label_list: allocating label_list of size %zu\n", size);
-  label_list = kzalloc(size, GFP_KERNEL);
-
-  kdf_init_atomic();
-
-  // Initialize 0 label: b should already be set to all 0; last_label should already by 0
-  KDF_PANIC_ON(label_list->last_label != 0, "KDFSan error: the last_label should be 0 after label_list is initialized");
-  kdf_util_strlcpy(label_list->bitvectors[0].desc, "no-taint", KDF_DESC_LEN);
-  #ifdef DEBUG_KDF_RT
-  kdf_print_bitvector(0);
-  #endif
-
-  max_label = kdf_create_label("max-label");
-}
-
-/************************************************************************/
-/************************** Interface handlers **************************/
-
-#define MAX_BUF_LEN 4096
-
-static void kdf_memtransfer_buf_init(u8 *dst, size_t buf_count, const u8 *src, size_t src_count) {
-  if (src_count > buf_count || access_ok(src, src_count)) memset(dst, 0, buf_count); // Don't copy from userspace (this causes a crash if performed too early in boot)
-  else memcpy(dst, src, src_count); // Load from kernelspace
-}
-
-static u64 kdf_memtransfer_buf_getval64(const u8 *buf, size_t i, bool FORWARDS, size_t buf_count, size_t src_count) {
-  if (src_count > buf_count) return 0;
-  u64 val64 = 0;
-  size_t this_size = min((size_t)8,src_count-i);
-  const u8 * buf_curr = FORWARDS ? &buf[i] : &buf[src_count-i-this_size];
-  memcpy(&val64, buf_curr, this_size);
-  return val64;
-}
-
-// NOTE: kdf_memtransfer() performs both: (i) the shadow memtransfer, AND (ii) if perform_policies is set, the associated load/store policies
-void kdf_memtransfer(void *dst, const void *src, uptr count, dfsan_label dst_label, dfsan_label src_label, void * rip, bool perform_policies) {
-  u8 buf_copy[MAX_BUF_LEN];
-  const bool FORWARDS = dst <= src;
-  kdf_memtransfer_buf_init(buf_copy, ARRAY_SIZE(buf_copy), src, count);
-  for (size_t i = 0; i < count; i++) {
-    u8       *tmp_dst = FORWARDS ? &dst[i] : &dst[count-i-1];
-    const u8 *tmp_src = FORWARDS ? &src[i] : &src[count-i-1];
-    u64 val64 = kdf_memtransfer_buf_getval64(buf_copy, i, FORWARDS, ARRAY_SIZE(buf_copy), count); // Get the current 8-byte word (even though we apply the policies in 1-byte increments)
-    dfsan_label this_label = kdf_get_shadow(tmp_src);                                                              // 1. Begin memtransfer
-    if (perform_policies) this_label = kdf_policies_load((void*)tmp_src, sizeof(u8), this_label, src_label, rip);  // 2. Load policy
-    this_label = PROPAGATE_LOAD_PTR ? kdf_union(this_label, src_label) : this_label;                               // 3. Load pointer propagation
-    if (perform_policies) kdf_policies_store(val64, tmp_dst, sizeof(u8), this_label, dst_label, rip);              // 4. Store policy
-    this_label = PROPAGATE_STORE_PTR ? kdf_union(this_label, dst_label) : this_label;                              // 5. Store pointer propagation
-    kdf_set_shadow(tmp_dst, this_label);                                                                           // 6. Finish shadow memtransfer
-  }
-}
-
-void kdf_set_label(dfsan_label label, void *addr, uptr size) {
-  for (u8* datap = (u8*) addr; size != 0; --size, ++datap) {
-    dfsan_label this_label = kdf_get_shadow(datap);
-    if (label != this_label) {
-      kdf_set_shadow(datap, label);
-    }
-  }
-}
-
-dfsan_label kdf_union(dfsan_label l1, dfsan_label l2) {
-  u8 b_tmp_kdf_union[BITVECTOR_SIZE];
-
-  // possible fast paths
-  if (l1 == 0) return l2;
-  if (l2 == 0) return l1;
-  if (l1 == l2) return l1;
-
-  //u8 b_tmp[NUM_LABELS] = {0};
-  __memset(b_tmp_kdf_union, 0, BITVECTOR_SIZE);
-
-  KDF_CHECK_LABEL(l1);
-  KDF_CHECK_LABEL(l2);
-
-  // get l1's and l2's bitvectors
-  dfsan_label_bitvector * b1 = &label_list->bitvectors[l1];
-  dfsan_label_bitvector * b2 = &label_list->bitvectors[l2];
-
-  dfsan_label total_labels = KDF_ATOMIC_READ(label_list->last_label);
-  dfsan_label label_color_slot = (KDF_ATOMIC_READ(label_list->last_color) >> 3) + 1;
-
-  // bitwise or the bitvectors up until the current color. After that
-  // all are zeroes.
-  for(int i_bit = 0; i_bit < label_color_slot; i_bit++) {
-    b_tmp_kdf_union[i_bit] = b1->b[i_bit] | b2->b[i_bit];
-    //KDF_PANIC_ON(b_tmp_kdf_union[i_bit] != 0 && b_tmp_kdf_union[i_bit] != 1, "kdf_union error: bitvector values should only be 0 or 1");
-  }
-
-  
-  // check if the resulting bitvector exists
-  // TODO: it might be faster to iterate from last_label to 0, assuming labels are most commonly union'ed with recently created labels
-  for(dfsan_label lbl = 0; lbl <= total_labels; lbl++) {
-    if(kdf_util_memcmp(b_tmp_kdf_union, label_list->bitvectors[lbl].b, label_color_slot) == 0) {
-      // if resulting bitvector exists, return its label
-      return lbl;
-    }
-  }
-
-  // otherwise, if resulting bitvector does not exist, insert it with a new label
-  dfsan_label new_lbl = kdf_create_next_label((u8 *)b_tmp_kdf_union, "created-by-kdf_union");
-  #ifdef DEBUG_KDF_RT
-  kdf_print_bitvector(new_lbl);
-  #endif
-
-  return new_lbl;
-}
-
-dfsan_label kdf_read_label(const void *addr, uptr n) {
-  dfsan_label ret_label = 0;
-  for (u8* datap = (u8*) addr; n != 0; --n, ++datap) {
-    dfsan_label next_label = kdf_get_shadow(datap);
-    if (ret_label != next_label) {
-      ret_label = kdf_union(ret_label, next_label);
-    }
-  }
-  return ret_label;
-}
-
-void kdf_add_label(dfsan_label label_src, void *addr, uptr size) {
-  for (u8* datap = (u8*) addr; size != 0; --size, ++datap) {
-    dfsan_label label_tmp = kdf_get_shadow(datap);
-    if (label_tmp != label_src) {
-      dfsan_label label_dst = kdf_union(label_tmp, label_src);
-      kdf_set_shadow(datap, label_dst);
-    }
-  }
-}
-
-dfsan_label kdf_create_label(const char *desc) {
-  dfsan_label lbl = kdf_create_next_label(NULL, desc);
-  #ifdef DEBUG_KDF_RT
-  kdf_print_bitvector(lbl);
-  #endif
-  return lbl;
-}
-
-int kdf_has_label(dfsan_label haver, dfsan_label havee) {
-  u8 *b_haver = label_list->bitvectors[haver].b;
-  u8 *b_havee = label_list->bitvectors[havee].b;
-  dfsan_label last_color_slot = (KDF_ATOMIC_READ(label_list->last_color)) >> 3;
-  for(int i = 0; i <= last_color_slot; i++) {
-    if((b_havee[i] | b_haver[i]) ^ b_haver[i]) {
-      return false;
-    }
-  }
-  return true;
-}
-
-// If the given label contains a label with the description desc, returns that label, else returns 0
-dfsan_label kdf_has_label_with_desc(dfsan_label label, const char *desc) {
-  // For each label with a matching description
-  for(dfsan_label this_lbl = 0; this_lbl <= label_list->last_label; this_lbl++) {
-    dfsan_label_bitvector *this_bitvector = &label_list->bitvectors[this_lbl];
-    if(kdf_util_strcmp(this_bitvector->desc, desc) == 0) {
-      // Check whether given label contains it, and if so, return
-      if(kdf_has_label(label, this_lbl) == true) {
-        return this_lbl;
-      }
-    }
-  }
-  return 0;
-}
-
-// Return a label with the matching desc. If multiple labels have the given desc, return the lowest matching label. If no label has the given desc, return 0.
-dfsan_label kdf_get_label_with_desc(const char *desc) {
-  for(dfsan_label this_lbl = 0; this_lbl <= label_list->last_label; this_lbl++) {
-    if(kdf_util_strcmp(label_list->bitvectors[this_lbl].desc, desc) == 0) {
-      return this_lbl;
-    }
-  }
-  return 0;
-}
-
-// Returns the number of descs written to descs_arr
-size_t kdf_get_label_descs(dfsan_label label, char descs_arr[][KDF_DESC_LEN], size_t descs_arr_size) {
-  if (label == 0 || descs_arr == NULL || descs_arr_size == 0) return 0;
-  KDF_CHECK_LABEL(label);
-  size_t num_descs = 0;
-
-  u8 *b = label_list->bitvectors[label].b;
-  dfsan_label last_color_slot = KDF_ATOMIC_READ(label_list->last_color) >> 3 ;
-  dfsan_label current_label = 0;
-
-  for(dfsan_label i = 0; i <= last_color_slot; i++) {
-    for (u8 j = 0; j <  LABEL_SLOT_SIZE; j++) {
-      if(b[i] & (1 << j)) {
-       current_label = search_unique_color(current_label, i, j);
-       kdf_util_strlcpy(descs_arr[num_descs], label_list->bitvectors[current_label].desc, KDF_DESC_LEN);
-       num_descs++;
-      }
-    }
-  }
-  return num_descs;
-}
-
-dfsan_label kdf_get_label_count(void) {
-  return label_list->last_label;
-}
-
-/**********************************************************************/
-/****************** Miscellaneous interface handlers ******************/
-
-void kdf_copy_label_info(dfsan_label label, char * dest, size_t count) {
-  dfsan_label current_label = 0;
-  u8 *b = label_list->bitvectors[label].b;
-  bool first_report = true;
-
-  __memset(dest, 0, count);
-  CONCAT_STR("label ", dest, count); CONCAT_NUM(label, 10, dest, count); CONCAT_STR(": {", dest, count);
-
-  dfsan_label last_color_slot = KDF_ATOMIC_READ(label_list->last_color) >> 3 ;
-
-  for(dfsan_label i = 0; i <= last_color_slot; i++) {
-    //KDF_PANIC_ON(b[i] != 0 && b[i] != 1, "kdf_print_label_info error: bitvector values should only be 0 or 1");
-    for (u8 j = 0; j <  LABEL_SLOT_SIZE; j++) {
-      if(b[i] & (1 << j)) {
-       if(!first_report) { CONCAT_STR(", ", dest, count); }
-       current_label = search_unique_color(current_label, i, j);
-       CONCAT_STR("(label: ", dest, count); CONCAT_NUM(current_label, 10, dest, count);
-       CONCAT_STR(", desc: '", dest, count); CONCAT_STR(label_list->bitvectors[current_label].desc, dest, count);
-       CONCAT_STR("')", dest, count);
-       first_report = false;
-      }
-    }
-  }
-  CONCAT_STR("}", dest, count);
-  KDF_PANIC_ON(first_report && label != 0, "kdf_copy_label_info error: a non-zero label should be composed of at least one bit");
-}
-
-void kdf_internal_task_create(struct task_struct *task)
-{
-	struct kdfsan_ctx *ctx = &task->kdfsan_ctx;
-	//struct thread_info *info = current_thread_info();
-
-	__memset(ctx, 0, sizeof(*ctx));
-	ctx->allow_reporting = true;
-	//kdfsan_internal_unpoison_memory(info, sizeof(*info), false);
-}
diff --git a/mm/kdfsan/kdfsan_internal.h b/mm/kdfsan/kdfsan_internal.h
deleted file mode 100644
index 3b600ba0b7cf..000000000000
--- a/mm/kdfsan/kdfsan_internal.h
+++ /dev/null
@@ -1,47 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#ifndef KDFSAN_INTERNAL_H
-#define KDFSAN_INTERNAL_H
-
-#include "kdfsan_types.h"
-#include "kdfsan_whitelist.h"
-#include "kdfsan_interface.h"
-
-void kdf_memtransfer(void *dst, const void *src, uptr count, dfsan_label dst_label, dfsan_label src_label, void * rip, bool perform_policies);
-void kdf_set_label(dfsan_label label, void *addr, uptr size);
-dfsan_label kdf_union(dfsan_label l1, dfsan_label l2);
-dfsan_label kdf_union_read_label(const void *addr, uptr n);
-void kdf_add_label(dfsan_label label_src, void *addr, uptr size);
-dfsan_label kdf_create_label(const char *desc); // userdata decprecated
-int kdf_has_label(dfsan_label label, dfsan_label elem);
-dfsan_label kdf_has_label_with_desc(dfsan_label label, const char *desc);
-dfsan_label kdf_get_label_with_desc(const char *desc);
-size_t kdf_get_label_descs(dfsan_label label, char descs_arr[][KDF_DESC_LEN], size_t descs_arr_size);
-dfsan_label kdf_read_label(const void *addr, uptr size);
-dfsan_label kdf_union(dfsan_label l1, dfsan_label l2);
-void kdf_print_label_info(dfsan_label lbl, const bool line_cont);
-void kdf_copy_label_info(dfsan_label label, char * dest, size_t count);
-void kdf_init_internal_data(void);
-void kdf_internal_task_create(struct task_struct *task);
-
-/*
- * KDFSAN performs a lot of consistency checks that are currently enabled by
- * default. BUG_ON is normally discouraged in the kernel, unless used for
- * debugging, but KMSAN itself is a debugging tool, so it makes little sense to
- * recover if something goes wrong.
- */
-#define KDFSAN_WARN_ON(cond)                                          \
-	({                                                            \
-		const bool __cond = WARN_ON(cond);                    \
-		if (unlikely(__cond)) {                               \
-			kdf_kill();                                   \
-			if (true) {                                   \
-				/* Can't call panic() here because */ \
-				/* of uaccess checks. */              \
-				BUG();                                \
-			}                                             \
-		}                                                     \
-		__cond;                                               \
-	})
-
-#endif // KDFSAN_INTERNAL_H
diff --git a/mm/kdfsan/kdfsan_mm.c b/mm/kdfsan/kdfsan_mm.c
deleted file mode 100644
index c4c324fc2709..000000000000
--- a/mm/kdfsan/kdfsan_mm.c
+++ /dev/null
@@ -1,71 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#include "kdfsan_types.h"
-
-int kdf_alloc_page(struct page *page, unsigned int order, gfp_t orig_flags, int node) {
-  struct page *shadow;
-  int num_pages = 1 << order;
-  int i;
-
-  if (orig_flags & __GFP_NO_KDFSAN_SHADOW) {
-    for (i = 0; i < num_pages; i++) (&page[i])->shadow = NULL;
-    return 0;
-  }
-
-  shadow = alloc_pages_node(node, GFP_ATOMIC | __GFP_ZERO | __GFP_NO_KDFSAN_SHADOW, order);
-  if (shadow == NULL) {
-    for (i = 0; i < num_pages; i++) (&page[i])->shadow = NULL;
-    return -ENOMEM;
-  }
-
-  //printk("kdfsan_alloc_page(page=%px,order=%02d,flags=0x%08x,node=%d): mem=%px; shadow=%px\n",
-  //    page,order,flags,node,page_address(page),page_address(shadow));
-
-  for (i = 0; i < num_pages; i++) {
-    (&page[i])->shadow = &shadow[i];
-    ((&page[i])->shadow)->shadow = NULL;
-  }
-
-  return 0;
-}
-
-void kdf_free_page(struct page *page, unsigned int order) {
-  int num_pages = 1 << order;
-  int i;
-  struct page *shadow;
-
-  // Checking if these pages are shadow pages, and if so, return early
-  if ((&page[0])->shadow == NULL) {
-    for (i = 0; i < num_pages; i++) {
-      KDF_PANIC_ON((&page[i])->shadow != NULL, "KDFSan error: Shadow page is backed by a shadow page");
-    }
-    return;
-  }
-
-  shadow = page->shadow;
-  for (i = 0; i < num_pages; i++) {
-    KDF_PANIC_ON((&page[i])->shadow == NULL, "KDFSan error: Page is not backed by a shadow page");
-    KDF_PANIC_ON(((&page[i])->shadow)->shadow != NULL, "KDFSan error: Current page's shadow page is backed by another shadow page");
-    (&page[i])->shadow = NULL;
-  }
-  /* The shadow pages must be freed after the the references have been cleared.
-   * Otherwise, they can be reallocated while being referenced. */
-  __free_pages(shadow, order);
-}
-
-void kdf_split_page(struct page *page, unsigned int order) {
-  struct page *shadow;
-  if ((&page[0])->shadow == NULL) return;
-  shadow = (&page[0])->shadow;
-  split_page(shadow, order);
-}
-
-void kdf_copy_page_shadow(struct page *dst, struct page *src) {
-  if (src->shadow == NULL) {
-    dst->shadow = NULL;
-    return;
-  }
-  KDF_PANIC_ON(dst->shadow == NULL, "Copying %px (page %px, shadow %px) to %px (page %px, shadow %px)\n",
-      page_address(src), src, src->shadow, page_address(dst), dst, dst->shadow);
-  __memcpy(page_address(dst->shadow), page_address(src->shadow), PAGE_SIZE);
-}
diff --git a/mm/kdfsan/kdfsan_mm.h b/mm/kdfsan/kdfsan_mm.h
deleted file mode 100644
index ff6695710266..000000000000
--- a/mm/kdfsan/kdfsan_mm.h
+++ /dev/null
@@ -1,11 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#ifndef KDFSAN_MM_H
-#define KDFSAN_MM_H
-
-int kdf_alloc_page(struct page *page, unsigned int order, gfp_t orig_flags, int node);
-void kdf_free_page(struct page *page, unsigned int order);
-void kdf_split_page(struct page *page, unsigned int order);
-void kdf_copy_page_shadow(struct page *dst, struct page *src);
-
-#endif // KDFSAN_MM_H
diff --git a/mm/kdfsan/kdfsan_policies.c b/mm/kdfsan/kdfsan_policies.c
deleted file mode 100644
index 2e1868500e28..000000000000
--- a/mm/kdfsan/kdfsan_policies.c
+++ /dev/null
@@ -1,1000 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#include "kdfsan_types.h"
-#include "kdfsan_util.h"
-#include "kdfsan_internal.h"
-#include "kdfsan_interface.h"
-#include "kdfsan_policies.h"
-
-/******************************************************************************/
-/* Userspace policies */
-/******************************************************************************/
-
-#ifdef CONFIG_KDFSAN_USERSPACE_POLICIES
-
-extern bool kdf_param_generic_syscall_label;
-
-static u64 cumulative_arg_count = -1;
-static dfsan_label attacker_syscall_label = -1;
-static dfsan_label attacker_getuser_label = -1;
-
-// For KDFSan tests
-dfsan_label kdfsan_policies_get_getuser_label(void) { return attacker_getuser_label; }
-
-// Taint source: syscall args
-void kdf_policies_syscall_arg(void * arg, size_t s, int arg_num) {
-  if (kdf_param_generic_syscall_label) {
-    kdf_add_label(attacker_syscall_label, arg, s); // Not calling dfsan_add_label because we're in the run-time here
-  } else {
-    u16 syscall_nr = kdf_util_syscall_get_nr();
-
-    u64 arg_val = 0;
-    if(s == 1) { arg_val = (u64)(*(u8*)arg); }
-    else if(s == 2) { arg_val = (u64)(*(u16*)arg); }
-    else if(s == 4) { arg_val = (u64)(*(u32*)arg); }
-    else if(s == 8) { arg_val = (u64)(*(u64*)arg); }
-    else { } // TODO: panic?
-
-    char desc[150] = "";
-    u64 this_cumulative_arg_count = cumulative_arg_count; cumulative_arg_count++;
-    CONCAT_STR("total_arg_nr: ",desc,sizeof(desc)); CONCAT_NUM(this_cumulative_arg_count,10,desc,sizeof(desc));
-    CONCAT_STR(", syscall_nr: ",desc,sizeof(desc)); CONCAT_NUM(syscall_nr,10,desc,sizeof(desc));
-    CONCAT_STR(", syscall_arg_nr: ",desc,sizeof(desc)); CONCAT_NUM(arg_num,10,desc,sizeof(desc));
-    CONCAT_STR(", size: ",desc,sizeof(desc)); CONCAT_NUM(s,10,desc,sizeof(desc));
-    CONCAT_STR(", syscall_arg_val: 0x",desc,sizeof(desc)); CONCAT_NUM(arg_val,16,desc,sizeof(desc));
-
-    dfsan_label label = kdf_create_label(desc); // Not calling dfsan_create_label because we're in the run-time here
-    kdf_add_label(label, arg, s); // Not calling dfsan_add_label because we're in the run-time here
-  }
-}
-
-// Taint source: usercopies
-dfsan_label kdf_policies_load(void *addr, uptr size, dfsan_label data_label, dfsan_label ptr_label, void * rip) {
-  if (access_ok(addr, size)) return attacker_getuser_label;
-  return 0;
-}
-
-void kdf_policies_init(void) {
-  cumulative_arg_count = 0;
-  // Not calling dfsan_create_label because the runtime has not been enabled yet
-  attacker_getuser_label = kdf_create_label("attacker-getuser");
-  if (kdf_param_generic_syscall_label) attacker_syscall_label = kdf_create_label("attacker-syscall-arg");
-}
-
-#endif
-
-/******************************************************************************/
-/* Double-fetch policies */
-/******************************************************************************/
-
-#ifdef CONFIG_KDFSAN_DOUBLEFETCH_POLICIES
-
-/************************************************************/
-/* Data, types, etc. ****************************************/
-
-#define MAX_STR_LEN 4096 // Can probably use a smaller buffer
-
-typedef struct {
-  bool                 is_cpu_accessible;
-  void *               last_sync_rip;
-  depot_stack_handle_t last_sync_bt;
-} kdf_streaming_dma_metadata;
-
-// For tracking DMA and MMIO regions
-typedef struct {
-  u32                          dev_id;
-  u64                          bus_addr;
-  void *                       cpu_addr;
-  size_t                       s;
-  void *                       alloc_rip;
-  depot_stack_handle_t         alloc_bt;
-  bool                         is_dma; // False => is MMIO
-  bool                         is_streaming_dma;
-  kdf_streaming_dma_metadata * steaming_dma_byte; // A kdf_streaming_dma_metadata for every byte in the region
-  struct maple_tree            stores;
-  struct maple_tree            store_ptrs; // Janky way of tracking pointers in the stores tree, so we can just free all of them when freeing the region
-  struct rcu_head              rcu;
-} kdf_region;
-static struct maple_tree regions_tree = MTREE_INIT(regions_tree, MT_FLAGS_USE_RCU);
-
-// For recording fetches
-typedef struct {
-  int                  prev_report_id;
-  char *               first_fetch_str;
-  void *               first_fetch_rip;
-  depot_stack_handle_t first_fetch_bt;
-  kdf_region *         first_fetch_region;
-} kdf_fetch_t;
-
-// For reports
-enum report_type { DMA_INV, DMA_SF, DMA_DF, MMIO_SF, MMIO_DF, PMIO_SF, PMIO_DF, USER_SF, USER_DF, VULN_STORE, VULN_COND };
-enum instr_type { LOAD, STORE, IN, OUT, GETUSER, PUTUSER, COND, BUG };
-#define REPORT_ID_NONE -1
-
-/***************************************************************/
-/* Per-domain report coverage tracking *************************/
-
-static bool kdf_get_report_covered(int report_id) {
-  return kdfsan_get_context()->pstate.reports_covered[report_id];
-}
-
-static void kdf_set_report_coverage(int report_id, bool is_covered) {
-  kdfsan_get_context()->pstate.reports_covered[report_id] = is_covered;
-}
-
-/***************************************************************/
-/* Label-to-report(s) conversion *******************************/
-
-#define MAX_PREV_REPORTS 16 // I can't imagine we have more than 16 double-fetch taint colors unioned together
-
-static bool label_have_reports[NUM_LABELS]                = {false};
-static volatile bool label_locked_reports[NUM_LABELS]     = {false};
-static int label_to_reports[NUM_LABELS][MAX_PREV_REPORTS] = {0}; // label_to_reports[label] --> [report0, report1, ...]
-
-static bool kdf_label_have_reports(dfsan_label label) { return label_have_reports[label]; }
-static size_t kdf_label_get_reports(int * prev_reports, dfsan_label label) {
-  int * saved_prev_reports = label_to_reports[label];
-  size_t num_reports = 0;
-  for (int i = 0; i < MAX_PREV_REPORTS && saved_prev_reports[i] != 0; i++) {
-    prev_reports[i] = saved_prev_reports[i];
-    num_reports++;
-  }
-  return num_reports;
-}
-static void kdf_label_set_reports(int * prev_reports, size_t prev_reports_count, dfsan_label label) {
-  if (label_have_reports[label] || label_locked_reports[label]) return; // Prevent two threads from writing to the same label_to_reports[label] simultaneously
-  label_locked_reports[label] = true;
-  int * saved_prev_reports = label_to_reports[label];
-  for (int i = 0; i < MAX_PREV_REPORTS; i++) {
-    if (i < prev_reports_count) saved_prev_reports[i] = prev_reports[i];
-    else saved_prev_reports[i] = 0;
-  }
-  label_have_reports[label] = true;
-  label_locked_reports[label] = false;
-}
-
-static size_t kdf_label_to_all_prev_reports(int * prev_reports, dfsan_label label) {
-  if (label == 0) return 0;
-
-  // Check whether we've already converted this label to prev_reports
-  if (kdf_label_have_reports(label)) {
-    return kdf_label_get_reports(prev_reports, label);
-  }
-
-  // If not, let's convert this label to prev_reports
-  char descs[MAX_PREV_REPORTS][KDF_DESC_LEN];
-  size_t num_reports = kdf_get_label_descs(label, descs, MAX_PREV_REPORTS);
-  size_t err_count = 0;
-  for (int i = 0; i < num_reports; i++) {
-    // Convert descs[i] string into integer. If for some reason it cannot be converted to an integer, skip it.
-    long this_report_id = REPORT_ID_NONE;
-    int rc = kstrtol(descs[i], 10, &this_report_id);
-    if (rc) {
-      printk("%s:%d: Warning: Could not convert label '%s' to decimal\n", __FILE__, __LINE__, descs[i]);
-      err_count++;
-      num_reports--;
-    }
-    else prev_reports[i-err_count] = this_report_id;
-  }
-
-  // Let's save this label-to-prev_reports conversion
-  kdf_label_set_reports(prev_reports, num_reports, label);
-
-  return num_reports;
-}
-static size_t kdf_label_to_prev_reports(int * prev_reports, dfsan_label label) {
-  if (label == 0) return 0;
-  size_t prev_reports_count = kdf_label_to_all_prev_reports(prev_reports, label);
-  size_t noncovered_count = 0;
-  for (int i = 0; i < prev_reports_count; i++) {
-    if (kdf_get_report_covered(prev_reports[i])) prev_reports[i-noncovered_count] = prev_reports[i];
-    else noncovered_count++;
-  }
-  return prev_reports_count - noncovered_count;
-}
-
-static bool kdf_has_df_label(dfsan_label lbl) {
-  int prev_reports[MAX_PREV_REPORTS];
-  return kdf_label_to_prev_reports(prev_reports, lbl) != 0;
-}
-bool kdfsan_policies_is_df_label(dfsan_label lbl) { return kdf_has_df_label(lbl); }
-
-static void kdf_invalidate_label(dfsan_label label) {
-  if (label == 0) return;
-  int prev_reports[MAX_PREV_REPORTS];
-  size_t prev_reports_count = kdf_label_to_all_prev_reports(prev_reports, label);
-  for (int i = 0; i < prev_reports_count; i++) kdf_set_report_coverage(prev_reports[i], false);
-}
-
-/************************************************************/
-/* Tracking created double-fetch labels *********************/
-
-// NOTE: This only includes *created* DF labels; not *all* (i.e., union'ed) labels
-typedef struct {
-  int report_id;
-  dfsan_label created_label;
-} kdf_report_to_label_t;
-static kdf_report_to_label_t df_labels[NUM_LABELS] = {0}; // df_labels[count] --> (report_id, created_label)
-static atomic_t df_label_count = ATOMIC_INIT(0);
-
-static dfsan_label kdf_get_df_label(int report_id) {
-  // Check if we already have a created_label saved for this report_id. If so, return that.
-  int cnt = atomic_read(&df_label_count);
-  for (int i = 0; i < cnt; i++) {
-    if (df_labels[i].report_id == report_id) return df_labels[i].created_label;
-  }
-
-  // Check if a label with report_id as the desc already exists. If not, create it.
-  char desc[8];
-  sprintf(desc, "%d", report_id); // Use the report_id as the desc.
-  dfsan_label lbl = kdf_get_label_with_desc(desc);
-  if (lbl == 0) lbl = kdf_create_label(desc);
-
-  // Next, add it to df_labels, then return it.
-  int df_label_i = atomic_inc_return(&df_label_count) - 1;
-  df_labels[df_label_i] = (kdf_report_to_label_t){.report_id = report_id, .created_label = lbl};
-  return lbl;
-}
-
-/************************************************************/
-/* Duplicate report filtering *******************************/
-
-typedef struct {
-  volatile bool ready;
-  int report_id;
-  enum report_type rt;
-  enum instr_type it;
-  depot_stack_handle_t bt;
-  void * rip;
-  dfsan_label data_label;
-  dfsan_label ptr_label;
-} kdf_dup_report_t;
-
-// dup_reports does *not* track single-fetch reports. Those are managed by the per-domain 'fetches' tree (via domain_get_prev_fetch()), and are deduplicated based on address (not rt, it, rip, etc.).
-static kdf_dup_report_t dup_reports[MAX_TOTAL_REPORTS] = {{0}};
-static atomic64_t dup_report_count = ATOMIC_INIT(0);
-
-static kdf_dup_report_t kdf_dup_new_report(enum report_type rt, enum instr_type it, depot_stack_handle_t bt, void * rip, dfsan_label data_label, dfsan_label ptr_label) {
-  // To avoid over-reporting, only use data_label and ptr_label if this is a VULN_* rt.
-  return (rt == VULN_STORE || rt == VULN_COND) ?
-         (kdf_dup_report_t){.ready = false, .report_id = REPORT_ID_NONE, .rt = rt, .it = it, .bt = bt, .rip = rip, .data_label = data_label, .ptr_label = ptr_label} :
-         (kdf_dup_report_t){.ready = false, .report_id = REPORT_ID_NONE, .rt = rt, .it = it, .bt = bt, .rip = rip, .data_label = 0, .ptr_label = 0};
-}
-
-static void kdf_dup_insert_report(kdf_dup_report_t dr) {
-  size_t idx = atomic64_inc_return(&dup_report_count) - 1;
-  KDF_PANIC_ON(idx >= MAX_TOTAL_REPORTS, "%s:%d: Error: Max report count (%lu) reached! Any new reports will not be filtered out as duplicates. Consider increasing MAX_TOTAL_REPORTS (or using a dynamically-sized linked list instead of a statically-sized array).\n", __FILE__, __LINE__, MAX_TOTAL_REPORTS);
-  dup_reports[idx] = dr;
-}
-
-static bool kdf_dup_reports_equal(kdf_dup_report_t dr1, kdf_dup_report_t dr2) {
-  return dr1.rt == dr2.rt &&
-         dr1.it == dr2.it &&
-         /*dr1.bt == dr2.bt &&*/
-         dr1.rip == dr2.rip /*&&
-         dr1.data_label == dr2.data_label &&
-         dr1.ptr_label == dr2.ptr_label*/;
-}
-
-// If it's a duplicate, return the dup_report's ID. Else, create this report, and return REPORT_ID_NONE.
-static int kdf_dup_check_insert(enum report_type rt, enum instr_type it, depot_stack_handle_t bt, void * rip, dfsan_label data_label, dfsan_label ptr_label) {
-  // Loop through previous reports, checking each report's (rt, it, bt, data_label, ptr_label).
-  kdf_dup_report_t this_dup_report = kdf_dup_new_report(rt, it, bt, rip, data_label, ptr_label);
-  for (size_t i = 0; i < atomic64_read(&dup_report_count); i++) {
-    if (!dup_reports[i].ready) { i--; continue; } // There's a small chance this report is current being added. In that case, spin until it's finished.
-    if (kdf_dup_reports_equal(this_dup_report, dup_reports[i])) return dup_reports[i].report_id;
-  }
-  // If it's NOT a duplicate: Insert this report into the list of previous reports.
-  kdf_dup_insert_report(this_dup_report);
-  return REPORT_ID_NONE;
-}
-
-static void kdf_dup_add_id(enum report_type rt, enum instr_type it, depot_stack_handle_t bt, void * rip, dfsan_label data_label, dfsan_label ptr_label, int report_id) {
-  // Loop through previous reports, checking each report's (rt, it, bt, data_label, ptr_label).
-  kdf_dup_report_t this_dup_report = kdf_dup_new_report(rt, it, bt, rip, data_label, ptr_label);
-  for (size_t i = 0; i < atomic64_read(&dup_report_count); i++) {
-    // Don't check whether the report is ready. In fact, this report should _not_ yet be ready.
-    if (kdf_dup_reports_equal(this_dup_report, dup_reports[i])) {
-      dup_reports[i].report_id = report_id;
-      dup_reports[i].ready = true;
-      return;
-    }
-  }
-  KDF_PANIC_ON(true, "Error: Could not find dup report from kdf_dup_add_id()\n");
-}
-
-/************************************************************/
-/* Report batching ******************************************/
-
-#define MAX_SAVED_REPORTS 8192
-static bool kdf_printing_is_enabled = false;
-static char* kdf_saved_reports[MAX_SAVED_REPORTS] = {NULL};
-static atomic_t kdf_saved_reports_size = ATOMIC_INIT(0);
-
-static void kdf_report_flush(void) {
-  const int num_reports = atomic_xchg(&kdf_saved_reports_size, 0);
-  int i = 0;
-  while (i < num_reports) {
-    if (i + 8 <= num_reports) {
-      printk("%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n", kdf_saved_reports[i], kdf_saved_reports[i+1], kdf_saved_reports[i+2], kdf_saved_reports[i+3], kdf_saved_reports[i+4], kdf_saved_reports[i+5], kdf_saved_reports[i+6], kdf_saved_reports[i+7]);
-      for (int j = 0; j < 8; j++) {
-        kfree(kdf_saved_reports[i+j]);
-        kdf_saved_reports[i+j] = NULL;
-      }
-      i += 8;
-    }
-    else if (i + 4 <= num_reports) {
-      printk("%s\n%s\n%s\n%s\n", kdf_saved_reports[i], kdf_saved_reports[i+1], kdf_saved_reports[i+2], kdf_saved_reports[i+3]);
-      for (int j = 0; j < 4; j++) {
-        kfree(kdf_saved_reports[i+j]);
-        kdf_saved_reports[i+j] = NULL;
-      }
-      i += 4;
-    }
-    else if (i + 2 <= num_reports) {
-      printk("%s\n%s\n", kdf_saved_reports[i], kdf_saved_reports[i+1]);
-      for (int j = 0; j < 2; j++) {
-        kfree(kdf_saved_reports[i+j]);
-        kdf_saved_reports[i+j] = NULL;
-      }
-      i += 2;
-    }
-    else {
-      printk("%s\n", kdf_saved_reports[i]);
-      kfree(kdf_saved_reports[i]);
-      kdf_saved_reports[i] = NULL;
-      i++;
-    }
-  }
-}
-
-static void kdf_report_enable(void) {
-  kdf_printing_is_enabled = true;
-  kdf_report_flush();
-}
-
-static void kdf_report_save(char * report_str) {
-  if (atomic_read(&kdf_saved_reports_size) >= MAX_SAVED_REPORTS) kdf_report_flush(); // If saved reports buffer is full, flush it and continue
-  int report_num = atomic_inc_return(&kdf_saved_reports_size) - 1;
-  while (kdf_saved_reports[report_num] != NULL) ; // Spin until this slot is ready...
-  kdf_saved_reports[report_num] = report_str;
-}
-
-/************************************************************/
-/* Region logging *******************************************/
-
-static struct maple_tree kdf_aff_regions = MTREE_INIT(kdf_aff_regions, MT_FLAGS_USE_RCU);
-static struct maple_tree kdf_all_regions = MTREE_INIT(kdf_aff_regions, MT_FLAGS_USE_RCU);
-static void kdf_region_str(const kdf_region * region, char * region_str, size_t size);
-
-static void kdf_log_region_internal(kdf_region * region, const char * s) {
-  // Log a dummy report, which logs this region. Code copied (mostly) from kdf_report_print_internal().
-  char region_str[MAX_STR_LEN], * full_report_str;
-  kdf_region_str(region, region_str, ARRAY_SIZE(region_str));
-  full_report_str = kzalloc(MAX_STR_LEN, GFP_KERNEL);
-  sprintf(full_report_str, "KDFSAN REPORT: {\"report_id\": -1, \"prev_reports\": [], \"rip\": \"%s\", \"report_type\": \"%s\", \"instr_type\": \"%s\", \"access\": {\"addr\": 0, \"size\": 0, \"data_label\": 0, \"ptr_label\": 0}, %s\"backtrace\": [\"%s\"], \"fuzzing_run\": \"%lu\"}", s, s, s, region_str, s, kdf_util_get_rand());
-  if (kdf_printing_is_enabled) {
-    printk("%s\n", full_report_str);
-    kfree(full_report_str);
-  }
-  else kdf_report_save(full_report_str);
-}
-
-static void kdf_log_region(kdf_region * region, bool to_print, bool log_as_affected_region) {
-  if (!region) return;
-  struct maple_tree * logged_regions = log_as_affected_region ? &kdf_aff_regions : &kdf_all_regions;
-  if (mtree_load(logged_regions, region->alloc_bt)) return; // If we've logged this region's alloc_backtrace before, return
-  if (to_print) kdf_log_region_internal(region, log_as_affected_region ? "LOG_REGION_AFF" : "LOG_REGION_ALL"); // Log this region
-  mtree_store(logged_regions, region->alloc_bt, (void*)(long)region->alloc_bt, GFP_KERNEL); // Save it to logged_regions (mtree[bt] = bt...)
-}
-
-/************************************************************/
-/* Report printing ******************************************/
-
-#define MAX_TYPE_SIZE 16
-static atomic_t reports_count = ATOMIC_INIT(0); // For reports' IDs
-
-static int kdf_report_next_id(void) { return atomic_inc_return(&reports_count) - 1; }
-
-static void kdf_rt_str(const enum report_type rt, char * str, size_t size) {
-  KDF_PANIC_ON(size < MAX_TYPE_SIZE, "Need a larger string for a report type."); // Should add better size checks
-  if (rt == DMA_INV) strcpy(str, "DMA_INV");
-  else if (rt == DMA_SF) strcpy(str, "DMA_1F");
-  else if (rt == DMA_DF) strcpy(str, "DMA_2F");
-  else if (rt == MMIO_SF) strcpy(str, "MMIO_1F");
-  else if (rt == MMIO_DF) strcpy(str, "MMIO_2F");
-  else if (rt == PMIO_SF) strcpy(str, "PMIO_1F");
-  else if (rt == PMIO_DF) strcpy(str, "PMIO_2F");
-  else if (rt == USER_SF) strcpy(str, "USER_1F");
-  else if (rt == USER_DF) strcpy(str, "USER_2F");
-  else if (rt == VULN_STORE) strcpy(str, "VULN_STORE");
-  else if (rt == VULN_COND) strcpy(str, "VULN_COND");
-  else strcpy(str, "UNKNOWN");
-}
-
-static void kdf_it_str(const enum instr_type it, char * str, size_t size) {
-  KDF_PANIC_ON(size < MAX_TYPE_SIZE, "Need a larger string for a instr type."); // Should add better size checks
-  if (it == LOAD) strcpy(str, "LOAD");
-  else if (it == STORE) strcpy(str, "STORE");
-  else if (it == IN) strcpy(str, "IN");
-  else if (it == OUT) strcpy(str, "OUT");
-  else if (it == GETUSER) strcpy(str, "GETUSER");
-  else if (it == PUTUSER) strcpy(str, "PUTUSER");
-  else if (it == COND) strcpy(str, "COND");
-  else if (it == BUG) strcpy(str, "BUG");
-  else strcpy(str, "UNKNOWN");
-}
-
-static void kdf_region_str(const kdf_region * region, char * region_str, size_t size) {
-  KDF_PANIC_ON(size < MAX_TYPE_SIZE, "Need a larger string for a instr type."); // Should add better size checks
-  if (region) {
-    char bt_str[MAX_STR_LEN];
-    kdf_util_bt_str(bt_str, ARRAY_SIZE(bt_str), region->alloc_bt);
-    sprintf(region_str, "\"region\": {\"dev_id\": %u, \"bus_addr\": %llu, \"cpu_addr\": %llu, \"s\": %lu, \"alloc_rip\": \"%pS\", \"alloc_backtrace\": %s, \"is_dma\": %s, \"is_streaming_dma\": %s}, ", region->dev_id, region->bus_addr, region->cpu_addr, region->s, region->alloc_rip, bt_str, region->is_dma ? "true" : "false", region->is_streaming_dma ? "true" : "false");
-  }
-  else strcpy(region_str, "");
-}
-
-static void kdf_prev_reports_to_str(const int * prev_reports, size_t prev_report_count, char * prev_reports_str) {
-  if (prev_reports == NULL || prev_report_count == 0) { sprintf(prev_reports_str, "[]"); return; }
-  size_t len = sprintf(prev_reports_str, "[");
-  if (prev_report_count > 0) len += sprintf(prev_reports_str+len, "%d", prev_reports[0]);
-  for (int i = 1; i < prev_report_count; i++) len += sprintf(prev_reports_str+len, ", %d", prev_reports[i]);
-  len += sprintf(prev_reports_str+len, "]");
-}
-
-static void kdf_report_print_internal(int report_id, int * prev_reports, size_t prev_report_count, char * partial_report_str, kdf_region * region, depot_stack_handle_t bt_handle, void * rip) {
-  char bt_str[MAX_STR_LEN], prev_reports_str[MAX_STR_LEN], region_str[MAX_STR_LEN], * full_report_str;
-  kdf_util_bt_str(bt_str, ARRAY_SIZE(bt_str), bt_handle);
-  kdf_prev_reports_to_str(prev_reports, prev_report_count, prev_reports_str);
-  kdf_region_str(region, region_str, ARRAY_SIZE(region_str));
-  kdf_log_region(region, false, true);
-  kdf_set_report_coverage(report_id, true);
-
-  full_report_str = kzalloc(MAX_STR_LEN, GFP_KERNEL);
-  sprintf(full_report_str, "KDFSAN REPORT: {\"report_id\": %d, \"prev_reports\": %s, \"rip\": \"%pS\", %s%s\"backtrace\": %s, \"fuzzing_run\": \"%lu\"}", report_id, prev_reports_str, rip, partial_report_str, region_str, bt_str, kdf_util_get_rand());
-
-  if (kdf_printing_is_enabled) {
-    printk("%s\n", full_report_str);
-    kfree(full_report_str);
-  }
-  else kdf_report_save(full_report_str);
-}
-
-static int kdf_report_print_first_fetch(kdf_fetch_t * prev_fetch) {
-  if (prev_fetch && prev_fetch->prev_report_id == REPORT_ID_NONE) {
-    if (prev_fetch->prev_report_id == REPORT_ID_NONE) {
-      // We haven't printed this single-fetch yet
-      KDF_PANIC_ON(prev_fetch->first_fetch_str == NULL || prev_fetch->first_fetch_bt == 0, "Found a fetch with a first_fetch_str=%px, first_fetch_bt=%lu\n", prev_fetch->first_fetch_str, prev_fetch->first_fetch_bt);
-      prev_fetch->prev_report_id = kdf_report_next_id();
-      kdf_report_print_internal(prev_fetch->prev_report_id, NULL, 0, prev_fetch->first_fetch_str, prev_fetch->first_fetch_region, prev_fetch->first_fetch_bt, prev_fetch->first_fetch_rip);
-    } else {
-      // We've already printed this single-fetch
-      kdf_set_report_coverage(prev_fetch->prev_report_id, true);
-    }
-  }
-  return prev_fetch ? prev_fetch->prev_report_id : REPORT_ID_NONE;
-}
-
-static size_t kdf_report_fmt(char * report_str, size_t report_str_size, enum report_type rt, enum instr_type it, const void *addr, uptr size, dfsan_label data_label, dfsan_label ptr_label, kdf_region * region, size_t streaming_dma_access_offset) {
-  char rt_str[MAX_TYPE_SIZE], it_str[MAX_TYPE_SIZE], streaming_dma_str[MAX_STR_LEN];
-  kdf_rt_str(rt, rt_str, ARRAY_SIZE(rt_str));
-  kdf_it_str(it, it_str, ARRAY_SIZE(it_str));
-
-  if (rt == DMA_INV) {
-    char sync_bt_str[MAX_STR_LEN];
-    kdf_util_bt_str(sync_bt_str, ARRAY_SIZE(sync_bt_str), region->steaming_dma_byte[streaming_dma_access_offset].last_sync_bt);
-    snprintf(streaming_dma_str, MAX_STR_LEN, "\"streaming_dma_access\": {\"region_offset\": %lu, \"last_sync_rip\": \"%pS\", \"last_sync_backtrace\": %s}, ", streaming_dma_access_offset, region->steaming_dma_byte[streaming_dma_access_offset].last_sync_rip, sync_bt_str);
-  } else streaming_dma_str[0] = '\0';
-
-  int sz = snprintf(report_str, report_str_size, "\"report_type\": \"%s\", \"instr_type\": \"%s\", \"access\": {\"addr\": %llu, \"size\": %lu, \"data_label\": %d, \"ptr_label\": %d}, %s", rt_str, it_str, addr, size, data_label, ptr_label, streaming_dma_str);
-  KDF_PANIC_ON(sz < 0 || sz > report_str_size, "Need a larger string for a report."); // Should add better size checks
-  return (size_t)sz;
-}
-
-static int kdf_report_print(enum report_type rt, enum instr_type it, const void *addr, uptr size, dfsan_label data_label, dfsan_label ptr_label, void * rip, kdf_region * region, kdf_fetch_t * prev_fetch, size_t streaming_dma_access_offset) {
-  // First, check whether this report is a duplicate.
-  depot_stack_handle_t bt = kdf_util_bt_handle();
-  int dup_report_id = kdf_dup_check_insert(rt, it, bt, rip, data_label, ptr_label);
-  if (dup_report_id != REPORT_ID_NONE) {
-    // This report is a duplicate. Don't print it.
-    kdf_set_report_coverage(dup_report_id, true);
-    kdf_log_region(region, true, true);
-    return dup_report_id;
-  }
-
-  // Next, get the 'previous report(s)'. I.e., for a tainted vulnerable operation, get the preceeding double-fetch(es); for a double-fetch, get the preceeding fetch.
-  int prev_reports[MAX_PREV_REPORTS];
-  size_t prev_report_count = 0;
-  if      (rt == VULN_STORE) prev_report_count = kdf_label_to_prev_reports(prev_reports, ptr_label);
-  else if (rt == VULN_COND)  prev_report_count = kdf_label_to_prev_reports(prev_reports, data_label);
-  else if (rt == DMA_DF || rt == MMIO_DF || rt == PMIO_DF || rt == USER_DF) { prev_reports[0] = kdf_report_print_first_fetch(prev_fetch); prev_report_count++;}
-  else if (rt == DMA_INV) ; // No previous report for DMA_INV reports
-  else if (rt == DMA_SF || rt == MMIO_SF || rt == USER_SF) ; // No previous report for *_SF reports
-  else KDF_PANIC_ON(true, "Error: Called kdf_report_print() with unknown report type (rt = %d)\n", rt);
-
-  // Finally, print this report.
-  char report_str[MAX_STR_LEN];
-  int this_report_id = kdf_report_next_id();
-  kdf_dup_add_id(rt, it, bt, rip, data_label, ptr_label, this_report_id);
-  kdf_report_fmt(report_str, ARRAY_SIZE(report_str), rt, it, addr, size, data_label, ptr_label, region, streaming_dma_access_offset);
-  kdf_report_print_internal(this_report_id, prev_reports, prev_report_count, report_str, region, bt, rip);
-  if (prev_fetch) prev_fetch->prev_report_id = this_report_id;
-  return this_report_id;
-}
-
-/************************************************************/
-/* Per-domain fetch recording *******************************/
-
-static void kdf_fetch_free(kdf_fetch_t * fetch) {
-  if (fetch->first_fetch_region) kfree(fetch->first_fetch_region);
-  kfree(fetch->first_fetch_str);
-  kfree(fetch);
-}
-
-static kdf_fetch_t * kdf_fetch_alloc(enum report_type rt, enum instr_type it, const void *addr, uptr size, dfsan_label data_label, dfsan_label ptr_label, void * rip, kdf_region * region) {
-  char report_str[MAX_STR_LEN];
-  depot_stack_handle_t bt = kdf_util_bt_handle();
-  size_t len = kdf_report_fmt(report_str, ARRAY_SIZE(report_str), rt, it, addr, size, data_label, ptr_label, NULL, 0);
-
-  kdf_fetch_t * fetch = kzalloc(sizeof(kdf_fetch_t), GFP_KERNEL);
-  mtree_store(&kdfsan_get_context()->pstate.fetch_ptrs, (unsigned long)fetch, fetch, GFP_KERNEL); // mtree[ptr] = ptr...
-
-  fetch->prev_report_id = REPORT_ID_NONE;
-  fetch->first_fetch_rip = rip;
-  fetch->first_fetch_bt = bt;
-
-  fetch->first_fetch_str = kzalloc(len+1, GFP_KERNEL);
-  strcpy(fetch->first_fetch_str, report_str);
-
-  if (region) {
-    fetch->first_fetch_region = kzalloc(sizeof(kdf_region), GFP_KERNEL);
-    memcpy(fetch->first_fetch_region,region,sizeof(kdf_region));
-  } else {
-    fetch->first_fetch_region = NULL;
-  }
-
-  return fetch;
-}
-
-static kdf_fetch_t * kdf_fetch_copy_alloc(kdf_fetch_t * fetch, struct maple_tree * ptrs_tree) {
-  kdf_fetch_t * fetch_copy = kzalloc(sizeof(kdf_fetch_t), GFP_KERNEL);
-  mtree_store(ptrs_tree, (unsigned long)fetch_copy, fetch_copy, GFP_KERNEL); // mtree[ptr] = ptr...
-
-  fetch_copy->prev_report_id = fetch->prev_report_id;
-  fetch_copy->first_fetch_rip = fetch->first_fetch_rip;
-  fetch_copy->first_fetch_bt = fetch->first_fetch_bt;
-
-  fetch_copy->first_fetch_str = kzalloc(strlen(fetch->first_fetch_str), GFP_KERNEL);
-  strcpy(fetch_copy->first_fetch_str, fetch->first_fetch_str);
-
-  if (fetch->first_fetch_region) {
-    fetch_copy->first_fetch_region = kzalloc(sizeof(kdf_region), GFP_KERNEL);
-    memcpy(fetch_copy->first_fetch_region, fetch->first_fetch_region, sizeof(kdf_region));
-  } else {
-    fetch_copy->first_fetch_region = NULL;
-  }
-
-  return fetch_copy;
-}
-
-static void kdf_policies_domain_destroy(struct kdfsan_policies_state * pstate) {
-  pstate->initialized = false;
-
-  // Free each pointer in fetch_ptrs
-  struct maple_tree * fetch_ptrs = &kdfsan_get_context()->pstate.fetch_ptrs;
-  void *fetch_ptr = NULL;
-  unsigned long index = 0;
-  mt_for_each(fetch_ptrs, fetch_ptr, index, (unsigned long) ULONG_MAX) kdf_fetch_free(fetch_ptr);
-  mtree_destroy(&pstate->fetch_ptrs);
-
-  mtree_destroy(&pstate->fetches);
-  memset(pstate->reports_covered, false, sizeof(pstate->reports_covered)); // Invalidate all of this domain's reports upon domain exit
-}
-
-static void kdf_policies_domain_init(struct kdfsan_policies_state * pstate) {
-  mt_init(&pstate->fetches);
-  mt_init(&pstate->fetch_ptrs);
-  memset(pstate->reports_covered, false, sizeof(pstate->reports_covered)); // Invalidate all of this domain's reports, just to be safe
-  pstate->initialized = true;
-}
-
-void kdf_policies_domain_enter(void) {
-  struct kdfsan_policies_state * pstate = &kdfsan_get_context()->pstate;
-  if (pstate->initialized) {
-    printk("%s:%d: Warning: Entering a domain, but it seems we haven't exited it yet.\n", __FILE__, __LINE__);
-    dump_stack();
-    kdf_policies_domain_destroy(pstate);
-  }
-  kdf_policies_domain_init(pstate);
-}
-
-void kdf_policies_domain_exit(void) {
-  struct kdfsan_policies_state * pstate = &kdfsan_get_context()->pstate;
-  if (pstate->initialized) kdf_policies_domain_destroy(pstate);
-  else { printk("%s:%d: Warning: Exiting a domain but was not in a domain in the first place.\n", __FILE__, __LINE__); dump_stack(); }
-}
-
-// Returns NULL if there was no previous access, or a pointer to the previous fetch
-static kdf_fetch_t * domain_get_prev_fetch(const void * addr, uptr size, kdf_region * region) {
-  // First, check if there's a matching access in the domain-local "fetches" tree
-  struct kdfsan_policies_state * pstate = &kdfsan_get_context()->pstate;
-  if (pstate->initialized) {
-    for (int i = 0; i < size; i++) {
-      // TODO: Rather than returning the first fetch we come across, return multiple fetches, in case there are different fetches to different bytes of the region
-      kdf_fetch_t * fetch = mtree_load(&pstate->fetches, (unsigned long)addr+i);
-      if (fetch) return fetch;
-    }
-  }
-
-  // Second, check if there's a matching access in the global "stores" tree
-  if (region) {
-    for (int i = 0; i < size; i++) {
-      // TODO: Rather than returning the first fetch we come across, return multiple fetches, in case there are different fetches to different bytes of the region
-      kdf_fetch_t * store = mtree_load(&region->stores, (unsigned long)addr+i);
-      if (store) return store;
-    }
-  }
-
-  return NULL;
-}
-
-static void domain_fetch_addr(const void * addr, uptr size, kdf_fetch_t * fetch, bool is_store, kdf_region * region) {
-  if (!fetch) return; // Print warning?
-  bool is_persistent_access = is_store && region;
-
-  if (!is_persistent_access) {
-    // Save to domain-local "fetches" tree
-    struct kdfsan_policies_state * pstate = &kdfsan_get_context()->pstate;
-    if (!pstate->initialized) return;
-    mtree_store_range(&pstate->fetches, (unsigned long)addr, (unsigned long)addr+size-1, fetch, GFP_KERNEL);
-  } else {
-    // Save to global "stores" tree
-    kdf_fetch_t * store = kdf_fetch_copy_alloc(fetch, &region->store_ptrs);
-    mtree_store_range(&region->stores, (unsigned long)addr, (unsigned long)addr+size-1, store, GFP_KERNEL);
-  }
-}
-
-/************************************************************/
-/* Usercopy hook ********************************************/
-
-static dfsan_label kdf_policies_getuser(const void * src, size_t s, dfsan_label src_ptr_label, void * rip) {
-  if (!KDF_DOUBLEFETCH_USER) return 0;
-  kdf_fetch_t * fetch = domain_get_prev_fetch(src, s, NULL);
-  dfsan_label data_label = 0;
-  if (!fetch) {
-    fetch = kdf_fetch_alloc(USER_SF, GETUSER, src, s, 0, src_ptr_label, rip, NULL);
-  } else {
-    int report_id = kdf_report_print(USER_DF, GETUSER, src, s, 0, src_ptr_label, rip, NULL, fetch, 0);
-    data_label = kdf_get_df_label(report_id);
-  }
-  domain_fetch_addr(src, s, fetch, false, NULL);
-  return data_label;
-}
-
-static void kdf_policies_putuser(void * dst, size_t s, dfsan_label data_label, dfsan_label dst_ptr_label, void * rip) {
-  if (!KDF_DOUBLEFETCH_USER) return;
-  kdf_fetch_t * fetch = domain_get_prev_fetch(dst, s, NULL);
-  if (!fetch) {
-    fetch = kdf_fetch_alloc(USER_SF, PUTUSER, dst, s, data_label, dst_ptr_label, rip, NULL);
-  }
-  domain_fetch_addr(dst, s, fetch, true, NULL);
-}
-
-/************************************************************/
-/* Region helpers **********************************************/
-
-static kdf_region * regions_find_by_cpuaddr(void * cpu_addr) {
-  return mtree_load(&regions_tree, (unsigned long)cpu_addr);
-}
-
-static kdf_region * regions_find_by_dev(struct device *dev, u64 bus_addr) {
-  kdf_region *curr = NULL;
-  MA_STATE(mas, &regions_tree, 0, 0);
-  rcu_read_lock();
-  mas_for_each(&mas, curr, (unsigned long) ULONG_MAX) {
-    if (dev->id == curr->dev_id && bus_addr >= curr->bus_addr && bus_addr < curr->bus_addr + curr->s) {
-	rcu_read_unlock();
-	return curr;
-    }
-  }
-  rcu_read_unlock();
-  return NULL;
-}
-
-/************************************************************/
-/* Load/store hooks *************************************/
-
-static void kdf_access_streaming(void *addr, uptr size, dfsan_label data_label, dfsan_label ptr_label, void * rip, bool is_store, kdf_region * region) {
-  if (!KDF_DOUBLEFETCH_DMA_STREAMING) return;
-  size_t load_offset_begin = addr - region->cpu_addr;
-  for (size_t i = load_offset_begin; i < load_offset_begin + size; i++) {
-    if (i >= region->s) {
-      printk("%s:%d: Warning: Access to region goes out-of-bounds: load_offset=%d, access = {addr=0x%px, size=%lu, data_label=%d, ptr_label=%d}, region = {dev_id=%u, bus_addr=0x%px, cpu_addr=0x%px, s=%lu}\n", __FILE__, __LINE__, i, addr, size, data_label, ptr_label, region->dev_id, region->bus_addr, region->cpu_addr, region->s);
-      break;
-    }
-    if (!region->steaming_dma_byte[i].is_cpu_accessible) {
-	kdf_report_print(DMA_INV, is_store ? STORE : LOAD, addr, size, data_label, ptr_label, rip, region, NULL, i);
-	return;
-    }
-  }
-}
-
-static dfsan_label kdf_access_nonstreaming(void *addr, uptr size, dfsan_label data_label, dfsan_label ptr_label, void * rip, bool is_store, kdf_region * region, bool stores_kernel_virt_ptr) {
-  if (region->is_dma && !KDF_DOUBLEFETCH_DMA_COHERENT) return 0;
-  if (!region->is_dma && !KDF_DOUBLEFETCH_MMIO) return 0;
-
-  if (addr + size > region->cpu_addr + region->s) {
-    printk("%s:%d: Warning: Access to region goes out-of-bounds: access = {addr=0x%px, size=%lu, data_label=%d, ptr_label=%d}, region = {dev_id=%u, bus_addr=0x%px, cpu_addr=0x%px, s=%lu, is_dma=%s}\n", __FILE__, __LINE__, addr, size, data_label, ptr_label, region->dev_id, region->bus_addr, region->cpu_addr, region->s, region->is_dma ? "true" : "false");
-  }
-
-  kdf_fetch_t * fetch = domain_get_prev_fetch(addr, size, region);
-  if (!fetch || stores_kernel_virt_ptr) {
-    fetch = kdf_fetch_alloc(region->is_dma ? DMA_SF : MMIO_SF, is_store ? STORE : LOAD, addr, size, data_label, ptr_label, rip, region);
-    if (stores_kernel_virt_ptr) fetch->prev_report_id = kdf_report_print(region->is_dma ? DMA_SF : MMIO_SF, STORE, addr, size, data_label, ptr_label, rip, region, NULL, 0);
-  }
-  else if (!is_store) {
-      int report_id = kdf_report_print(region->is_dma ? DMA_DF : MMIO_DF, LOAD, addr, size, data_label, ptr_label, rip, region, fetch, 0);
-      data_label = kdf_union(data_label, kdf_get_df_label(report_id));
-  }
-  domain_fetch_addr(addr, size, fetch, is_store, region);
-  return data_label;
-}
-
-dfsan_label kdf_policies_load(void *addr, uptr size, dfsan_label data_label, dfsan_label ptr_label, void * rip) {
-  if ((unsigned long)addr < PAGE_SIZE) {
-    ; // Null-pointer load... Let's stay away...
-  } else if (access_ok(addr, size)) {
-    // Load from userspace
-    data_label = kdf_policies_getuser(addr, size, ptr_label, rip);
-  } else {
-    // Potentially load from DMA/MMIO
-    kdf_region * region = regions_find_by_cpuaddr(addr);
-    if (region == NULL) return data_label;
-    //printk("%s:%d: Loading from region: access = {addr=0x%px, size=%lu, data_label=%d, ptr_label=%d}, region = {dev_id=%u, bus_addr=0x%px, cpu_addr=0x%px, s=%lu}\n", __FILE__, __LINE__, addr, size, data_label, ptr_label, region->dev_id, region->bus_addr, region->cpu_addr, region->s);
-
-    if (region->is_streaming_dma) kdf_access_streaming(addr, size, data_label, ptr_label, rip, false, region);
-    else data_label = kdf_access_nonstreaming(addr, size, data_label, ptr_label, rip, false, region, false);
-  }
-
-  return data_label;
-}
-
-void kdf_policies_store(u64 data, void *addr, uptr size, dfsan_label data_label, dfsan_label ptr_label, void * rip) {
-  if (kdf_has_df_label(ptr_label)) {
-    // If the ptr_label contains the "double-fetch" label: Print report
-    kdf_report_print(VULN_STORE, STORE, addr, size, data_label, ptr_label, rip, NULL, NULL, 0);
-  }
-
-  if ((unsigned long)addr < PAGE_SIZE) {
-    ; // Null-pointer store... Let's stay away...
-  } else if (access_ok(addr, size)) {
-    // Store to userspace
-    kdf_policies_putuser(addr, size, data_label, ptr_label, rip);
-  } else {
-    // Potentially store to DMA/MMIO
-    kdf_region * region = regions_find_by_cpuaddr(addr);
-    if (region == NULL) return;
-    //printk("%s:%d: Storing to region: access = {addr=0x%px, size=%lu, data_label=%d, ptr_label=%d}, region = {dev_id=%u, bus_addr=0x%px, cpu_addr=0x%px, s=%lu}\n", __FILE__, __LINE__, addr, size, data_label, ptr_label, region->dev_id, region->bus_addr, region->cpu_addr, region->s);
-
-    if (region->is_streaming_dma) kdf_access_streaming(addr, size, data_label, ptr_label, rip, true, region);
-    else kdf_access_nonstreaming(addr, size, data_label, ptr_label, rip, true, region, kdf_is_kernel_ptr(data));
-  }
-}
-
-/************************************************************/
-/* Region alloc/free ****************************************/
-
-static void kdf_policies_region_alloc(struct device *dev, u64 bus_addr, void * cpu_addr, size_t s, bool is_dma, bool is_streaming_dma, void * rip) {
-  if (s == 0) return;
-  // Add the region [cpu_addr,cpu_addr+s) to the list of regions
-  kdf_region * region = kzalloc(sizeof(kdf_region), GFP_KERNEL);
-  if (region == NULL) {
-    printk("%s:%d: Error: Could not allocate memory for 'region': dev_drv=%s, dev_name=%s, dev_id=%u, bus_addr=0x%px, cpu_addr=0x%px, s=%lu\n", __FILE__, __LINE__, dev_driver_string(dev), dev_name(dev), dev->id, bus_addr, cpu_addr, s);
-    return;
-  }
-  region->dev_id = dev ? dev->id : 0;
-  region->bus_addr = bus_addr;
-  region->cpu_addr = cpu_addr;
-  region->s = s;
-  region->is_dma = is_dma;
-  region->is_streaming_dma = is_streaming_dma;
-  region->alloc_rip = rip;
-  depot_stack_handle_t bt = kdf_util_bt_handle();
-  region->alloc_bt = bt;
-  if (is_streaming_dma) {
-    kdf_streaming_dma_metadata * steaming_dma_byte = kzalloc(sizeof(kdf_streaming_dma_metadata) * s, GFP_KERNEL);
-    if (steaming_dma_byte == NULL) {
-      printk("%s:%d: Error: Could not allocate memory for 'steaming_dma_byte': dev_drv=%s, dev_name=%s, dev_id=%u, bus_addr=0x%px, cpu_addr=0x%px, s=%lu\n", __FILE__, __LINE__, dev_driver_string(dev), dev_name(dev), dev->id, bus_addr, cpu_addr, s);
-      kfree(region);
-      return;
-    }
-    region->steaming_dma_byte = steaming_dma_byte;
-    for (size_t i = 0; i < s; i++) {
-	region->steaming_dma_byte[i].is_cpu_accessible = false; // Streaming DMA is _not_ CPU accessible when allocated.
-	region->steaming_dma_byte[i].last_sync_rip = rip;
-	region->steaming_dma_byte[i].last_sync_bt = bt;
-    }
-  } else {
-    region->steaming_dma_byte = NULL;
-  }
-  mt_init(&region->stores);
-  mt_init(&region->store_ptrs);
-  mtree_store_range(&regions_tree, (unsigned long)cpu_addr, (unsigned long)cpu_addr+s-1, region, GFP_KERNEL);
-  kdf_log_region(region, true, false);
-}
-
-static void kdf_policies_region_free_node(struct rcu_head *head) {
-  kdf_region * region = container_of(head, kdf_region, rcu);
-  //printk("%s:%d: Freeing resources for region: dev_id=%u, bus_addr=0x%px, cpu_addr=0x%px, s=%lu\n", __FILE__, __LINE__, region->dev_id, region->bus_addr, region->cpu_addr, region->s);
-  kdf_set_label(0, region->cpu_addr, region->s); // Clear taint of region just to be safe (we're not tainting the region anyway)
-  if(region->steaming_dma_byte) kfree(region->steaming_dma_byte); // Only need to free if: region->is_streaming_dma == true
-
-  // Free each pointer in store_ptrs
-  struct maple_tree * store_ptrs = &region->store_ptrs;
-  void *store_ptr = NULL;
-  unsigned long index = 0;
-  mt_for_each(store_ptrs, store_ptr, index, (unsigned long) ULONG_MAX) kdf_fetch_free(store_ptr);
-  mtree_destroy(&region->store_ptrs);
-  mtree_destroy(&region->stores);
-
-  kfree(region);
-}
-
-/************************************************************/
-/* DMA alloc/free/sync hooks ********************************/
-
-void noinline kdf_policies_dma_alloc(struct device *dev, dma_addr_t bus_addr, void * cpu_addr, size_t s, bool is_streaming_dma, void * rip) {
-  //printk("%s:%d: Allocating DMA region: dev_drv=%s, dev_name=%s, dev_id=%u, bus_addr=0x%px, cpu_addr=0x%px, s=%lu, is_streaming_dma=%s\n", __FILE__, __LINE__, dev_driver_string(dev), dev_name(dev), dev->id, bus_addr, cpu_addr, s, is_streaming_dma ? "true" : "false");
-  kdf_policies_region_alloc(dev, bus_addr, cpu_addr, s, true, is_streaming_dma, rip);
-}
-
-void noinline kdf_policies_dma_free(struct device *dev, dma_addr_t bus_addr) {
-  // Delete the DMA range corresponding to (dev, bus_addr) from the list of DMA ranges.
-  //printk("%s:%d: Freeing DMA region... (dev_drv=%s, dev_name=%s, dev_id=%u, bus_addr=0x%px)\n", __FILE__, __LINE__, dev_driver_string(dev), dev_name(dev), dev->id, bus_addr);
-  mtree_lock(&regions_tree);
-  kdf_region * region = regions_find_by_dev(dev, bus_addr);
-  if (region == NULL) {
-    mtree_unlock(&regions_tree);
-    printk("%s:%d: Warning: Attempting to free untracked DMA region: dev_drv=%s, dev_name=%s, dev_id=%u, bus_addr=0x%px\n", __FILE__, __LINE__, dev_driver_string(dev), dev_name(dev), dev->id, bus_addr);
-    return;
-  }
-  //printk("%s:%d: Freeing DMA region: dev_drv=%s, dev_name=%s, dev_id=%u, bus_addr=0x%px, cpu_addr=0x%px, s=%lu\n", __FILE__, __LINE__, dev_driver_string(dev), dev_name(dev), region->dev_id, region->bus_addr, region->cpu_addr, region->s);
-  MA_STATE(mas, &regions_tree, (unsigned long)region->cpu_addr, (unsigned long)region->cpu_addr+region->s-1);
-  void * ret = mas_erase(&mas);
-  mtree_unlock(&regions_tree);
-  if (!ret) printk("%s:%d: Warning: mas_erase() returned NULL when attempting to free DMA region: dev_drv=%s, dev_name=%s, dev_id=%u, bus_addr=0x%px\n", __FILE__, __LINE__, dev_driver_string(dev), dev_name(dev), dev->id, bus_addr);
-  call_rcu(&region->rcu, kdf_policies_region_free_node);
-}
-
-void kdf_policies_dma_alloc_sg(struct device *dev, struct scatterlist *sg, int ents, void * rip) {
-  int i;
-  struct scatterlist *tmpsg;
-  for_each_sg(sg, tmpsg, ents, i) {
-    kdf_policies_dma_alloc(dev, sg_dma_address(tmpsg), sg_virt(tmpsg), sg_dma_len(tmpsg), true, rip);
-  }
-}
-
-void kdf_policies_dma_free_sg(struct device *dev, struct scatterlist *sg, int nents) {
-  int i;
-  struct scatterlist *tmpsg;
-  for_each_sg(sg, tmpsg, nents, i) {
-    if (sg_dma_len(tmpsg) == 0) break; // We don't have the actual number of ents (only the passed in nents), so we'll use this to check for the end of the sglist
-    kdf_policies_dma_free(dev, sg_dma_address(tmpsg));
-  }
-}
-
-void kdf_policies_dma_sync(struct device *dev, dma_addr_t addr, size_t size, bool is_for_cpu, void * rip) {
-  kdf_region * region = regions_find_by_dev(dev, addr);
-  if (region == NULL) {
-    printk("%s:%d: Warning: Attempting to sync untracked DMA region: dev_drv=%s, dev_name=%s, dev_id=%u, bus_addr=0x%px\n", __FILE__, __LINE__, dev_driver_string(dev), dev_name(dev), dev->id, addr);
-    return;
-  }
-  size_t sync_offset_begin = addr - region->bus_addr; // This may be a partial sync
-  depot_stack_handle_t bt = kdf_util_bt_handle();
-  for (size_t i = 0; i < size; i++) {
-    if (sync_offset_begin + i >= region->s) {
-      printk("%s:%d: Warning: DMA sync goes out-of-bounds. Either this is a bug in the driver, or a bug in the way KDFSAN models DMA regions: dev_drv=%s, dev_name=%s, dev_id=%u, bus_addr=0x%px, cpu_addr=0x%px, s=%lu\n", __FILE__, __LINE__, dev_driver_string(dev), dev_name(dev), region->dev_id, region->bus_addr, region->cpu_addr, region->s);
-      return;
-    }
-    region->steaming_dma_byte[sync_offset_begin + i].is_cpu_accessible = is_for_cpu;
-    region->steaming_dma_byte[sync_offset_begin + i].last_sync_rip = rip;
-    region->steaming_dma_byte[sync_offset_begin + i].last_sync_bt = bt;
-  }
-}
-
-void kdf_policies_dma_sync_sg(struct device *dev, struct scatterlist *sg, int nelems, bool is_for_cpu, void * rip) {
-  int i;
-  struct scatterlist *tmpsg;
-  for_each_sg(sg, tmpsg, nelems, i) {
-    if (sg_dma_len(tmpsg) == 0) break; // We don't have the actual number of ents (only the passed in nelems), so we'll use this to check for the end of the sglist
-    kdf_policies_dma_sync(dev, sg_dma_address(tmpsg), sg_dma_len(tmpsg), is_for_cpu, rip);
-  }
-}
-
-/************************************************************/
-/* MMIO map/unmap hooks *************************************/
-
-void kdf_policies_ioremap(resource_size_t bus_addr, void __iomem *cpu_addr, size_t size, void * rip) {
-  if (!KDF_DOUBLEFETCH_MMIO) return;
-  //printk("%s:%d: Allocating MMIO region: bus_addr=0x%px, cpu_addr=0x%px, size=%lu\n", __FILE__, __LINE__, bus_addr, cpu_addr, size);
-  kdf_policies_region_alloc(NULL, bus_addr, cpu_addr, size, false, false, rip);
-}
-
-void kdf_policies_iounmap(void __iomem *cpu_addr) {
-  if (!KDF_DOUBLEFETCH_MMIO) return;
-  //printk("%s:%d: Freeing MMIO region... (cpu_addr=0x%px)\n", __FILE__, __LINE__, cpu_addr);
-  mtree_lock(&regions_tree);
-  kdf_region * region = regions_find_by_cpuaddr(cpu_addr);
-  if (region == NULL) {
-    mtree_unlock(&regions_tree);
-    printk("%s:%d: Warning: Attempting to free untracked MMIO region: cpu_addr=0x%px\n", __FILE__, __LINE__, cpu_addr);
-    return;
-  }
-  //printk("%s:%d: Freeing MMIO region: cpu_addr=0x%px\n", __FILE__, __LINE__, cpu_addr);
-  MA_STATE(mas, &regions_tree, (unsigned long)region->cpu_addr, (unsigned long)region->cpu_addr+region->s-1);
-  void * ret = mas_erase(&mas);
-  mtree_unlock(&regions_tree);
-  if (!ret) printk("%s:%d: Warning: mas_erase() returned NULL when attempting to free MMIO region: cpu_addr=0x%px\n", __FILE__, __LINE__, cpu_addr);
-  call_rcu(&region->rcu, kdf_policies_region_free_node);
-}
-
-
-/************************************************************/
-/* PMIO in/out hooks ****************************************/
-
-// TODO: Add hooks for request_region() and release_region()?
-
-void kdf_policies_pmio_out(void *src, u16 port, size_t size, dfsan_label src_label, dfsan_label port_label, dfsan_label size_label, void * rip) {
-  if (!KDF_DOUBLEFETCH_PMIO) return;
-  kdf_fetch_t * fetch = domain_get_prev_fetch((void*)port, size, NULL);
-  if (!fetch) {
-    fetch = kdf_fetch_alloc(PMIO_SF, OUT, port, size, kdf_read_label(src, size), port_label, rip, NULL);
-  }
-  domain_fetch_addr((void*)port, size, fetch, true, NULL);
-}
-
-void kdf_policies_pmio_in(u16 port, size_t size, void * dest, dfsan_label port_label, dfsan_label size_label, dfsan_label dest_label, void * rip) {
-  if (!KDF_DOUBLEFETCH_PMIO) return;
-  kdf_fetch_t * fetch = domain_get_prev_fetch((void*)port, size, NULL);
-  if (!fetch) {
-    fetch = kdf_fetch_alloc(PMIO_SF, IN, (void*)port, size, 0, port_label, rip, NULL);
-  } else {
-    int report_id = kdf_report_print(PMIO_DF, IN, (void*)port, size, 0, port_label, rip, NULL, fetch, 0);
-    // TODO: Propagate the label of 'port' to the output? (Similar to load pointer propagation?)
-    kdf_add_label(kdf_get_df_label(report_id), dest, size);
-  }
-  domain_fetch_addr((void*)port, size, fetch, false, NULL);
-}
-
-/************************************************************/
-/* Label invalidation hooks *********************************/
-
-#if 0
-void kdf_policies_cond_fwd(dfsan_label label, void * rip) {
-  if (label != 0) kdf_invalidate_label(label);
-}
-#endif
-
-/************************************************************/
-/* Vulnerable condition hooks *******************************/
-
-static void kdf_policies_vuln_cond(dfsan_label label, void * rip, enum instr_type it) {
-  if (!kdf_has_df_label(label)) return;
-  kdf_report_print(VULN_COND, it, NULL, 0, label, 0, rip, NULL, NULL, 0);
-}
-void kdf_policies_cond_bkwd(dfsan_label label, void * rip) { kdf_policies_vuln_cond(label, rip, COND); }
-void kdf_policies_bugon(dfsan_label label, void * rip) { kdf_policies_vuln_cond(label, rip, BUG); }
-
-/************************************************************/
-/* Initialization *******************************************/
-
-void kdf_policies_init(void) {
-  kdf_util_set_rand();
-}
-
-void kdf_policies_post_boot(void) {
-  kdf_report_enable();
-}
-
-#endif
\ No newline at end of file
diff --git a/mm/kdfsan/kdfsan_policies.h b/mm/kdfsan/kdfsan_policies.h
deleted file mode 100644
index bd3ea80152d0..000000000000
--- a/mm/kdfsan/kdfsan_policies.h
+++ /dev/null
@@ -1,128 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#ifndef KDFSAN_POLICIES_H
-#define KDFSAN_POLICIES_H
-
-#include "kdfsan_types.h"
-
-/******************************************************************************/
-
-#if defined(CONFIG_KDFSAN_USERSPACE_POLICIES)
-#define KDFSAN_POLICY_SYSCALL_ARG 1
-#define KDFSAN_POLICY_IO 0
-#define KDFSAN_POLICY_LOAD 1
-#define KDFSAN_POLICY_STORE 0
-#define KDFSAN_POLICY_COND_FWD 0
-#define KDFSAN_POLICY_COND_BKWD 0
-#define KDFSAN_POLICY_AND 0
-#define KDFSAN_POLICY_BUGON 0
-#define KDFSAN_POLICY_PER_DOMAIN 0
-dfsan_label kdfsan_policies_get_getuser_label(void);
-#elif defined(CONFIG_KDFSAN_DOUBLEFETCH_POLICIES)
-#define KDFSAN_POLICY_SYSCALL_ARG 0
-#define KDFSAN_POLICY_IO 1
-#define KDFSAN_POLICY_LOAD 1
-#define KDFSAN_POLICY_STORE 1
-#define KDFSAN_POLICY_COND_FWD 0
-#define KDFSAN_POLICY_COND_BKWD 1
-#define KDFSAN_POLICY_AND 0
-#define KDFSAN_POLICY_BUGON 1
-#define KDFSAN_POLICY_PER_DOMAIN 1
-bool kdfsan_policies_is_df_label(dfsan_label lbl);
-#define KDF_DOUBLEFETCH_DMA_COHERENT 1
-#define KDF_DOUBLEFETCH_DMA_STREAMING 1
-#define KDF_DOUBLEFETCH_MMIO 0
-#define KDF_DOUBLEFETCH_PMIO 0
-#define KDF_DOUBLEFETCH_USER 0
-#else
-#define KDFSAN_POLICY_SYSCALL_ARG 0
-#define KDFSAN_POLICY_IO 0
-#define KDFSAN_POLICY_LOAD 0
-#define KDFSAN_POLICY_STORE 0
-#define KDFSAN_POLICY_COND_FWD 0
-#define KDFSAN_POLICY_COND_BKWD 0
-#define KDFSAN_POLICY_AND 0
-#define KDFSAN_POLICY_BUGON 0
-#define KDFSAN_POLICY_PER_DOMAIN 0
-#endif
-
-/******************************************************************************/
-
-#if KDFSAN_POLICY_SYSCALL_ARG==1
-void kdf_policies_syscall_arg(void * arg, size_t s, int arg_num);
-#else
-static inline void kdf_policies_syscall_arg(void * arg, size_t s, int arg_num) { }
-#endif
-
-#if KDFSAN_POLICY_IO==1
-void kdf_policies_dma_alloc(struct device *dev, dma_addr_t bus_addr, void * cpu_addr, size_t s, bool is_streaming_dma, void * rip);
-void kdf_policies_dma_free(struct device *dev, dma_addr_t bus_addr);
-void kdf_policies_dma_alloc_sg(struct device *dev, struct scatterlist *sg, int ents, void * rip);
-void kdf_policies_dma_free_sg(struct device *dev, struct scatterlist *sg, int nents);
-void kdf_policies_dma_sync(struct device *dev, dma_addr_t addr, size_t size, bool is_for_cpu, void * rip);
-void kdf_policies_dma_sync_sg(struct device *dev, struct scatterlist *sg, int nelems, bool is_for_cpu, void * rip);
-void kdf_policies_ioremap(resource_size_t bus_addr, void __iomem *cpu_addr, size_t size, void * rip);
-void kdf_policies_iounmap(void __iomem *cpu_addr);
-void kdf_policies_pmio_out(void *src, u16 port, size_t size, dfsan_label src_label, dfsan_label port_label, dfsan_label size_label, void * rip);
-void kdf_policies_pmio_in(u16 port, size_t size, void * dest, dfsan_label port_label, dfsan_label size_label, dfsan_label dest_label, void * rip);
-#else
-static inline void kdf_policies_dma_alloc(struct device *dev, dma_addr_t bus_addr, void * cpu_addr, size_t s, bool is_streaming_dma, void * rip) { }
-static inline void kdf_policies_dma_free(struct device *dev, dma_addr_t bus_addr) { }
-static inline void kdf_policies_dma_alloc_sg(struct device *dev, struct scatterlist *sg, int ents, void * rip) { }
-static inline void kdf_policies_dma_free_sg(struct device *dev, struct scatterlist *sg, int nents) { }
-static inline void kdf_policies_dma_sync(struct device *dev, dma_addr_t addr, size_t size, bool is_for_cpu, void * rip) { }
-static inline void kdf_policies_dma_sync_sg(struct device *dev, struct scatterlist *sg, int nelems, bool is_for_cpu, void * rip) { }
-static inline void kdf_policies_ioremap(resource_size_t bus_addr, void __iomem *cpu_addr, size_t size, void * rip) { }
-static inline void kdf_policies_iounmap(void __iomem *cpu_addr) { }
-static inline void kdf_policies_pmio_out(void *src, u16 port, size_t size, dfsan_label src_label, dfsan_label port_label, dfsan_label size_label, void * rip) { }
-static inline void kdf_policies_pmio_in(u16 port, size_t size, void * dest, dfsan_label port_label, dfsan_label size_label, dfsan_label dest_label, void * rip) { }
-#endif
-
-#if KDFSAN_POLICY_LOAD==1
-dfsan_label kdf_policies_load(void *addr, uptr size, dfsan_label data_label, dfsan_label ptr_label, void * rip);
-#else
-static inline dfsan_label kdf_policies_load(void *addr, uptr size, dfsan_label data_label, dfsan_label ptr_label, void * rip) { return data_label; }
-#endif
-
-#if KDFSAN_POLICY_STORE==1
-void kdf_policies_store(u64 data, void *addr, uptr size, dfsan_label data_label, dfsan_label ptr_label, void * rip);
-#else
-static inline void kdf_policies_store(u64 data, void *addr, uptr size, dfsan_label data_label, dfsan_label ptr_label, void * rip) { }
-#endif
-
-#if KDFSAN_POLICY_COND_FWD==1
-void kdf_policies_cond_fwd(dfsan_label label, void * rip);
-#else
-static inline void kdf_policies_cond_fwd(dfsan_label label, void * rip) { }
-#endif
-
-#if KDFSAN_POLICY_COND_BKWD==1
-void kdf_policies_cond_bkwd(dfsan_label label, void * rip);
-#else
-static inline void kdf_policies_cond_bkwd(dfsan_label label, void * rip) { }
-#endif
-
-#if KDFSAN_POLICY_AND==1
-void kdf_policies_and(dfsan_label l1, dfsan_label l2, void * rip);
-#else
-static inline void kdf_policies_and(dfsan_label l1, dfsan_label l2, void * rip) { }
-#endif
-
-#if KDFSAN_POLICY_BUGON==1
-void kdf_policies_bugon(dfsan_label label, void * rip);
-#else
-static inline void kdf_policies_bugon(dfsan_label label, void * rip) { }
-#endif
-
-#if KDFSAN_POLICY_PER_DOMAIN==1
-void kdf_policies_domain_enter(void);
-void kdf_policies_domain_exit(void);
-#else
-static inline void kdf_policies_domain_enter(void) { }
-static inline void kdf_policies_domain_exit(void) { }
-#endif
-
-void kdf_policies_init(void);
-void kdf_policies_post_boot(void);
-
-#endif // KDFSAN_POLICIES_H
diff --git a/mm/kdfsan/kdfsan_shadow.c b/mm/kdfsan/kdfsan_shadow.c
deleted file mode 100644
index a6287e7d24be..000000000000
--- a/mm/kdfsan/kdfsan_shadow.c
+++ /dev/null
@@ -1,126 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-// Shadow memory hooks based on KMSAN's
-
-#include "kdfsan_types.h"
-
-/*************************************************************************/
-/********************** Valid virtual address check **********************/
-
-#if defined(CONFIG_X86)
-
-static inline int kdf_phys_addr_valid(resource_size_t addr) {
-#ifdef CONFIG_PHYS_ADDR_T_64BIT
-  return !(addr >> boot_cpu_data.x86_phys_bits);
-#else
-  return 1;
-#endif
-}
-
-/*
- * Dummy load and store pages to be used when the real metadata is unavailable.
- * There are separate pages for loads and stores, so that every load returns a
- * zero, and every store doesn't affect other loads.
- */
-static char dummy_load_page[PAGE_SIZE] __aligned(PAGE_SIZE);
-static char dummy_store_page[PAGE_SIZE] __aligned(PAGE_SIZE);
-
-static inline bool kdfsan_internal_is_module_addr(void *vaddr)
-{
-	return ((u64)vaddr >= MODULES_VADDR) && ((u64)vaddr < MODULES_END);
-}
-
-static inline bool kdfsan_internal_is_vmalloc_addr(void *addr)
-{
-	return ((u64)addr >= VMALLOC_START) && ((u64)addr < VMALLOC_END);
-}
-
-static bool kdf_virt_addr_valid(void *addr) {
-  unsigned long x = (unsigned long)addr;
-  unsigned long y = x - __START_KERNEL_map;
-
-  if (unlikely(x > y)) {
-    x = y + phys_base;
-    if (y >= KERNEL_IMAGE_SIZE) return false;
-  }
-  else {
-    x = y + (__START_KERNEL_map - PAGE_OFFSET);
-    if ((x > y) || !kdf_phys_addr_valid(x)) return false;
-  }
-
-  return pfn_valid(x >> PAGE_SHIFT);
-}
-
-#elif defined(CONFIG_ARM64)
-
-static bool kdf_virt_addr_valid(void *addr) {
-  return virt_addr_valid(addr);
-}
-
-#endif
-
-struct page *kdf_virt_to_page_or_null(void *vaddr) {
-  if (vaddr < PAGE_OFFSET) return NULL;
-  if (kdf_virt_addr_valid(vaddr)) return virt_to_page(vaddr);
-  if (kdf_virt_addr_valid(__va(__pa(vaddr)))) return virt_to_page(__va(__pa(vaddr)));
-  else return NULL;
-}
-
-/*****************************************************************************/
-/************************** Shadow accessor helpers **************************/
-
-dfsan_label *get_shadow_addr(const u8 *ptr) {
-  uptr addr = (uptr) ptr;
-  struct page *page = NULL;
-  //uptr aligned_addr = 0;
-  uptr shadow_offset = 0;
-  void *shadow_base = NULL;
-  dfsan_label *shadow_addr = NULL;
-
-  if (kdfsan_internal_is_vmalloc_addr((void*)ptr) ||
-	kdfsan_internal_is_module_addr((void*)ptr))
-		return (void *)NULL;
-
-  page = kdf_virt_to_page_or_null((void*)ptr);
-  if (page == NULL) {
-    //printk("get_shadow_addr: NO PAGE EXISTS FOR VADDR %px\n",ptr);
-    return NULL;
-  }
-  if (page->shadow == NULL) {
-    //printk("get_shadow_addr: NO SHADOW EXISTS FOR PAGE AT %px (VADDR: %px)\n",page,ptr);
-    return NULL;
-  }
-
-  shadow_offset = (addr % PAGE_SIZE);
-  shadow_base = page_address(page->shadow);
-  shadow_addr = shadow_base + shadow_offset;
-  return shadow_addr;
-}
-
-static uptr get_internal_label_offset(const u8 *ptr) {
-  return (((uptr) ptr) & INTERNAL_LABEL_ADDR_MASK) * INTERNAL_LABEL_BIT_WIDTH;
-}
-
-/**********************************************************************/
-/************************** Shadow accessors **************************/
-
-dfsan_label kdf_get_shadow(const u8 *ptr) {
-  dfsan_label mem_labels = 0, ret = 0, *sptr = NULL;
-  sptr = get_shadow_addr(ptr);
-  if(sptr == NULL) return 0;
-  mem_labels = *sptr;
-  ret = (dfsan_label) ((mem_labels >> get_internal_label_offset(ptr)) & INTERNAL_LABEL_MASK);
-  //printk("----get_shadow: getting *shadow_of(%p) = *(%p) --> %04x (label in mem)     --> %x (single label)\n",ptr,sptr,mem_labels,ret);
-  KDF_CHECK_LABEL(ret);
-  return ret;
-}
-
-void kdf_set_shadow(const u8 *ptr, dfsan_label label) {
-  KDF_CHECK_LABEL(label);
-  dfsan_label old_labels = 0, new_label = 0, *sptr = NULL;
-  sptr = get_shadow_addr(ptr);
-  if(sptr == NULL) return;
-  old_labels = *sptr;
-  new_label = (old_labels & ~(INTERNAL_LABEL_MASK << get_internal_label_offset(ptr))) | ((label & INTERNAL_LABEL_MASK) << get_internal_label_offset(ptr));
-  //printk("----set_shadow: setting *shadow_of(%p) = *(%p) <-- %04x (new label in mem) <-- %x (single label); was %04x\n",ptr,sptr,new_label,label,old_labels);
-  *sptr = new_label;
-}
diff --git a/mm/kdfsan/kdfsan_shadow.h b/mm/kdfsan/kdfsan_shadow.h
deleted file mode 100644
index 4b65912ca82a..000000000000
--- a/mm/kdfsan/kdfsan_shadow.h
+++ /dev/null
@@ -1,12 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#ifndef KDFSAN_SHADOW_H
-#define KDFSAN_SHADOW_H
-
-#include "kdfsan_types.h"
-
-struct page *kdf_virt_to_page_or_null(void *vaddr);
-dfsan_label kdf_get_shadow(const u8 *ptr);
-void kdf_set_shadow(const u8 *ptr, dfsan_label label);
-
-#endif // KDFSAN_SHADOW_H
diff --git a/mm/kdfsan/kdfsan_types.h b/mm/kdfsan/kdfsan_types.h
deleted file mode 100644
index 84241485af06..000000000000
--- a/mm/kdfsan/kdfsan_types.h
+++ /dev/null
@@ -1,44 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#ifndef KDFSAN_TYPES_H
-#define KDFSAN_TYPES_H
-
-#include <linux/kdfsan.h>
-#include <linux/kdfsan_types.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/gfp.h>
-#include <linux/mm_types.h>
-#include <linux/printk.h>
-#include <linux/slab.h>
-//#include <linux/slab_def.h>
-#include <linux/nmi.h>
-#include <linux/irqflags.h>
-#include <linux/memblock.h>
-#include <linux/uaccess.h>
-#include <linux/list.h>
-#include <linux/device.h>
-#include <linux/scatterlist.h>
-#include <linux/stackdepot.h>
-#include <linux/sched/task_stack.h>
-#include <linux/timekeeping.h>
-#include <linux/time.h>
-#include <linux/timex.h>
-#include <linux/random.h>
-#include <asm/syscall.h>
-#include <asm/processor.h>
-#include "kdfsan_util.h"
-
-dfsan_label kdf_get_label_count(void);
-
-#define KDF_PANIC_ON(cond, ...) \
-do { \
-  if(cond) { \
-    panic(__VA_ARGS__); \
-  } \
-} while(0)
-
-#define KDF_CHECK_LABEL(lbl) KDF_PANIC_ON(lbl > kdf_get_label_count(), \
-    "Found label (%d) greater than max label (%d)", lbl, kdf_get_label_count());
-
-#endif // KDFSAN_TYPES_H
diff --git a/mm/kdfsan/kdfsan_util.c b/mm/kdfsan/kdfsan_util.c
deleted file mode 100644
index c804cbad5a4e..000000000000
--- a/mm/kdfsan/kdfsan_util.c
+++ /dev/null
@@ -1,171 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#include "kdfsan_types.h"
-
-size_t kdf_util_strlen(const char *s) {
-  const char *sc;
-  for (sc = s; *sc != '\0'; ++sc) { ; }
-  return sc - s;
-}
-
-int kdf_util_strncmp(const char *cs, const char *ct, int count) {
-  unsigned char c1, c2;
-  while (count) {
-    c1 = *cs++;
-    c2 = *ct++;
-    if (c1 != c2) {
-      return c1 < c2 ? -1 : 1;
-    }
-    if (!c1) {
-      break;
-    }
-    count--;
-  }
-  return 0;
-}
-
-size_t kdf_util_strlcat(char *dest, const char *src, size_t count) {
-  size_t dsize = kdf_util_strlen(dest);
-  size_t len = kdf_util_strlen(src);
-  size_t res = dsize + len;
-  BUG_ON(dsize >= count); // This would be a bug
-  dest += dsize;
-  count -= dsize;
-  if (len >= count) { len = count-1; }
-  __memcpy(dest, src, len);
-  dest[len] = 0;
-  return res;
-}
-
-static void kdf_util_reverse_str(char str[], int length) {
-  int start = 0;
-  int end = length -1;
-  while (start < end) {
-    char tmp = *(str+end);
-    *(str+end) = *(str+start);
-    *(str+start) = tmp;
-    start++;
-    end--;
-  }
-}
-
-char* kdf_util_itoa(long long num, char* str, int base) {
-  int i = 0;
-  bool is_negative = false;
-  if (num == 0) {
-    str[i++] = '0';
-    str[i] = '\0';
-    return str;
-  }
-  if (num < 0 && base == 10) {
-    is_negative = true;
-    num = -num;
-  }
-  while (num != 0) {
-    int rem = num % base;
-    str[i++] = (rem > 9)? (rem-10) + 'a' : rem + '0';
-    num = num/base;
-  }
-  if (is_negative) { str[i++] = '-'; }
-  str[i] = '\0';
-  kdf_util_reverse_str(str, i);
-  return str;
-}
-
-size_t kdf_util_strlcpy(char *dest, const char *src, size_t size) {
-  size_t ret = kdf_util_strlen(src);
-  if (size) {
-    size_t len = (ret >= size) ? size - 1 : ret;
-    __memcpy(dest, src, len);
-    dest[len] = '\0';
-  }
-  return ret;
-}
-
-int kdf_util_memcmp(const void *cs, const void *ct, size_t count) {
-  const unsigned char *su1, *su2;
-  int res = 0;
-  for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
-  if ((res = *su1 - *su2) != 0)
-    break;
-  return res;
-}
-
-int kdf_util_strcmp(const char *cs, const char *ct) {
-  unsigned char c1, c2;
-  while (1) {
-    c1 = *cs++;
-    c2 = *ct++;
-    if (c1 != c2)
-      return c1 < c2 ? -1 : 1;
-    if (!c1)
-      break;
-  }
-  return 0;
-}
-
-char *kdf_util_strpbrk(const char *cs, const char *ct) {
-  const char *sc1, *sc2;
-
-  for (sc1 = cs; *sc1 != '\0'; ++sc1) {
-    for (sc2 = ct; *sc2 != '\0'; ++sc2) {
-      if (*sc1 == *sc2)
-        return (char *)sc1;
-      }
-    }
-  return NULL;
-}
-
-/* We could add a skipnr arg to kdf_util_bt_handle(), and pass that to arg 3 of stack_trace_save()...
- * However, that'd require maintaining different skipnr values for the store hooks, the load hooks, etc.
- * Moreover, after any changes to the KDFSAN runtime library, we'd have to check whether the skipnr values are still accurate.
- * Instead, let's just use skipnr=0, and fix this (i.e., remove the parts of the callstack in KDFSAN) when post-processing the reports. */
-depot_stack_handle_t kdf_util_bt_handle(void) {
-  unsigned long entries[128];
-  unsigned int num_entries = stack_trace_save(entries, ARRAY_SIZE(entries), 0);
-  return stack_depot_save(entries, num_entries, GFP_KERNEL);
-}
-
-// Returns string length
-size_t kdf_util_bt_str(char * str, size_t size, depot_stack_handle_t bt_handle) {
-  KDF_PANIC_ON(size < 4096, "Need a larger string for a backtrace."); // Should add better size checks
-  unsigned long *entries;
-  size_t len = 0;
-  unsigned int num_entries = stack_depot_fetch(bt_handle, &entries);
-
-  len += sprintf(str+len, "[");
-  if (num_entries > 0) len += sprintf(str+len, "\"%pS\"", entries[0]);
-  for (int i = 1; i < num_entries; i++) len += sprintf(str+len, ", \"%pS\"", entries[i]);
-  len += sprintf(str+len, "]");
-  return len;
-}
-
-noinline unsigned long kdf_util_syscall_get_nr(void) {
-  return syscall_get_nr(current, task_pt_regs(current));
-}
-
-#define TIME_STRING_LEN 64
-static char time_str[TIME_STRING_LEN];
-void kdf_util_set_time_str(void) {
-  struct timespec64 ts;
-  struct tm tm;
-  ktime_get_real_ts64(&ts); // Get the current time
-  time64_to_tm(ts.tv_sec, 0, &tm); // Convert to calendar time
-  snprintf(time_str, TIME_STRING_LEN, "%04ld-%02d-%02d_%02d:%02d:%02d", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
-}
-const char * kdf_util_get_time_str(void) { return time_str; }
-
-static unsigned long random_number;
-void kdf_util_set_rand(void) { get_random_bytes(&random_number, sizeof(random_number)); }
-unsigned long kdf_util_get_rand(void) { return random_number; }
-
-// Specific to x86-64 with 4-level page tables
-bool kdf_is_kernel_ptr(u64 addr) {
-  return (addr >= 0xffff888000000000ULL && addr <= 0xffffc87fffffffffULL)  /* direct map */
-      || (addr >= 0xffffc90000000000ULL && addr <= 0xffffe8ffffffffffULL)  /* vmalloc */
-      || (addr >= 0xffffea0000000000ULL && addr <= 0xffffeaffffffffffULL)  /* virtual map */
-      || (addr >= 0xfffffe0000000000ULL && addr <= 0xfffffeffffffffffULL)  /* cpu_entry_area map */
-      || (addr >= 0xffffff0000000000ULL && addr <= 0xffffff7fffffffffULL)  /* %esp fixup stacks */
-      || (addr >= 0xffffffef00000000ULL && addr <= 0xfffffffeffffffffULL)  /* EFI region map */
-      || (addr >= 0xffffffff80000000ULL && addr <= 0xfffffffffeffffffULL); /* kernel text map, module map */
-}
\ No newline at end of file
diff --git a/mm/kdfsan/kdfsan_util.h b/mm/kdfsan/kdfsan_util.h
deleted file mode 100644
index 4f328913f3c6..000000000000
--- a/mm/kdfsan/kdfsan_util.h
+++ /dev/null
@@ -1,31 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#ifndef KDFSAN_UTIL_H
-#define KDFSAN_UTIL_H
-
-size_t kdf_util_strlen(const char *s);
-int kdf_util_strncmp(const char *cs, const char *ct, int count);
-size_t kdf_util_strlcat(char *dest, const char *src, size_t count);
-char* kdf_util_itoa(long long num, char* str, int base);
-size_t kdf_util_strlcpy(char *dest, const char *src, size_t size);
-int kdf_util_memcmp (const void *cs, const void *ct, size_t count);
-int kdf_util_strcmp(const char *cs, const char *ct);
-char *kdf_util_strpbrk(const char *cs, const char *ct);
-depot_stack_handle_t kdf_util_bt_handle(void);
-size_t kdf_util_bt_str(char * str, size_t size, depot_stack_handle_t bt_handle);
-unsigned long kdf_util_syscall_get_nr(void);
-void kdf_util_set_time_str(void);
-const char * kdf_util_get_time_str(void);
-void kdf_util_set_rand(void);
-unsigned long kdf_util_get_rand(void);
-bool kdf_is_kernel_ptr(u64 addr);
-
-#define CONCAT_STR(SRC,DEST,COUNT) \
-  do { kdf_util_strlcat(DEST, SRC, COUNT); } while(0)
-#define CONCAT_NUM(NUM,BASE,DEST,COUNT) \
-  do { char __tmp_num_str[32]; \
-  __memset(__tmp_num_str,0,32); \
-  kdf_util_itoa(NUM, __tmp_num_str, BASE); \
-  CONCAT_STR(__tmp_num_str,DEST,COUNT); } while(0)
-
-#endif
\ No newline at end of file
diff --git a/mm/kdfsan/kdfsan_whitelist.c b/mm/kdfsan/kdfsan_whitelist.c
deleted file mode 100644
index 9dc68ad55e4c..000000000000
--- a/mm/kdfsan/kdfsan_whitelist.c
+++ /dev/null
@@ -1,40 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#include "kdfsan_types.h"
-#include "kdfsan_whitelist.h"
-#include "kdfsan_util.h"
-
-extern kdfsan_whitelist_type_t kdf_param_whitelist;
-
-bool kdf_is_a_whitelist_type(char w) {
-  switch (w) {
-    case KDFSAN_WHITELIST_DISABLED:
-    case KDFSAN_WHITELIST_TASKNAME:
-    case KDFSAN_WHITELIST_SYSCALLNR:
-      return true;
-    default:
-      return false;
-}
-}
-
-bool kdfsan_is_whitelist_task(void) {
-  if (kdf_param_whitelist == KDFSAN_WHITELIST_DISABLED) {
-    return true;
-  }
-  else if (kdf_param_whitelist == KDFSAN_WHITELIST_TASKNAME) {
-    char *task_name = current->comm;
-    // taskname should either:
-    // (a) be exactly "kdfsan_task" (for kdfsan_tests), or
-    // (b) begin with "syz-executor" (for syzkaller)
-    if (kdf_util_strncmp(task_name, "kdfsan_task", TASK_COMM_LEN) == 0 ||
-        kdf_util_strncmp(task_name, "syz-executor", kdf_util_strlen("syz-executor")) == 0)
-      return true;
-  }
-  else if (kdf_param_whitelist == KDFSAN_WHITELIST_SYSCALLNR) {
-    unsigned long syscall_nr = kdf_util_syscall_get_nr();
-    // syscall number should be in the range [600, 1200)
-    if (syscall_nr >= 600 && syscall_nr < 1200)
-      return true;
-  }
-  return false;
-}
\ No newline at end of file
diff --git a/mm/kdfsan/kdfsan_whitelist.h b/mm/kdfsan/kdfsan_whitelist.h
deleted file mode 100644
index 944dcf164394..000000000000
--- a/mm/kdfsan/kdfsan_whitelist.h
+++ /dev/null
@@ -1,15 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-#ifndef KDFSAN_WHITELIST_H
-#define KDFSAN_WHITELIST_H
-
-typedef enum {
-  KDFSAN_WHITELIST_DISABLED = 'd',
-  KDFSAN_WHITELIST_TASKNAME = 't',
-  KDFSAN_WHITELIST_SYSCALLNR = 's'
-} kdfsan_whitelist_type_t;
-
-bool kdf_is_a_whitelist_type(char w);
-bool kdfsan_is_whitelist_task(void);
-
-#endif
diff --git a/mm/kmsan/instrumentation.c b/mm/kmsan/instrumentation.c
index cc3907a9c33a..a40248039f84 100644
--- a/mm/kmsan/instrumentation.c
+++ b/mm/kmsan/instrumentation.c
@@ -311,6 +311,8 @@ EXPORT_SYMBOL(__msan_unpoison_alloca);
 void __msan_warning(u32 origin);
 void __msan_warning(u32 origin)
 {
+  // Disable warnings so the error printing won't deminish perf when benchmarking.
+  return;
 	if (!kmsan_enabled || kmsan_in_runtime())
 		return;
 	kmsan_enter_runtime();
diff --git a/mm/memory.c b/mm/memory.c
index 49dc4d8eaa78..cdc4d4c1c858 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -78,7 +78,6 @@
 #include <linux/vmalloc.h>
 #include <linux/sched/sysctl.h>
 #include <linux/net_mm.h>
-#include <linux/kdfsan.h>
 
 #include <trace/events/kmem.h>
 
@@ -3105,7 +3104,6 @@ static vm_fault_t wp_page_copy(struct vm_fault *vmf)
 			return ret == -EHWPOISON ? VM_FAULT_HWPOISON : 0;
 		}
 		kmsan_copy_page_meta(&new_folio->page, vmf->page);
-		kdfsan_copy_page_shadow(&new_folio->page, vmf->page);
 	}
 
 	if (mem_cgroup_charge(new_folio, mm, GFP_KERNEL))
diff --git a/mm/mempool.c b/mm/mempool.c
index 4759be0ff9de..734bcf5afbb7 100644
--- a/mm/mempool.c
+++ b/mm/mempool.c
@@ -20,7 +20,7 @@
 #include <linux/writeback.h>
 #include "slab.h"
 
-#ifdef CONFIG_SLUB_DEBUG_ON
+#if defined(CONFIG_DEBUG_SLAB) || defined(CONFIG_SLUB_DEBUG_ON)
 static void poison_error(mempool_t *pool, void *element, size_t size,
 			 size_t byte)
 {
@@ -95,14 +95,14 @@ static void poison_element(mempool_t *pool, void *element)
 		kunmap_atomic(addr);
 	}
 }
-#else /* CONFIG_SLUB_DEBUG_ON */
+#else /* CONFIG_DEBUG_SLAB || CONFIG_SLUB_DEBUG_ON */
 static inline void check_element(mempool_t *pool, void *element)
 {
 }
 static inline void poison_element(mempool_t *pool, void *element)
 {
 }
-#endif /* CONFIG_SLUB_DEBUG_ON */
+#endif /* CONFIG_DEBUG_SLAB || CONFIG_SLUB_DEBUG_ON */
 
 static __always_inline void kasan_poison_element(mempool_t *pool, void *element)
 {
diff --git a/mm/mm_init.c b/mm/mm_init.c
index 2e194e625be7..a1963c3322af 100644
--- a/mm/mm_init.c
+++ b/mm/mm_init.c
@@ -21,7 +21,6 @@
 #include <linux/buffer_head.h>
 #include <linux/kmemleak.h>
 #include <linux/kfence.h>
-#include <linux/kdfsan.h>
 #include <linux/page_ext.h>
 #include <linux/pti.h>
 #include <linux/pgtable.h>
@@ -2782,7 +2781,6 @@ void __init mm_core_init(void)
 	kfence_alloc_pool();
 	report_meminit();
 	kmsan_init_shadow();
-        kdfsan_init_shadow();
 	stack_depot_early_init();
 	mem_init();
 	mem_init_print_info();
@@ -2805,6 +2803,5 @@ void __init mm_core_init(void)
 	/* Should be run after espfix64 is set up. */
 	pti_init();
 	kmsan_init_runtime();
-	kdfsan_init_runtime();
 	mm_cache_init();
 }
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 14f215fe8108..d322bfae8f69 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -1108,7 +1108,6 @@ static __always_inline bool free_pages_prepare(struct page *page,
 
 	trace_mm_page_free(page, order);
 	kmsan_free_page(page, order);
-	kdfsan_free_page(page, order);
 
 	if (unlikely(PageHWPoison(page)) && !order) {
 		/*
@@ -2572,7 +2571,6 @@ void split_page(struct page *page, unsigned int order)
 	VM_BUG_ON_PAGE(PageCompound(page), page);
 	VM_BUG_ON_PAGE(!page_count(page), page);
 
-	kdfsan_split_page(page, order);
 	for (i = 1; i < (1 << order); i++)
 		set_page_refcounted(page + i);
 	split_page_owner(page, 1 << order);
@@ -4501,13 +4499,6 @@ struct page *__alloc_pages(gfp_t gfp, unsigned int order, int preferred_nid,
 	trace_mm_page_alloc(page, order, alloc_gfp, ac.migratetype);
 	kmsan_alloc_page(page, order, alloc_gfp);
 
-	if (page) {
-		if(kdfsan_alloc_page(page, order, alloc_gfp, -1)) {
-			__free_pages(page, order);
-			page = NULL;
-		}
-	}
-
 	return page;
 }
 EXPORT_SYMBOL(__alloc_pages);
diff --git a/scripts/Makefile.kdfsan b/scripts/Makefile.kdfsan
deleted file mode 100644
index d0b5e0b548ad..000000000000
--- a/scripts/Makefile.kdfsan
+++ /dev/null
@@ -1,71 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-
-ifeq ($(ARCH),x86)
-kdf_arch_abilist := -mllvm -dfsan-abilist=mm/kdfsan/kdfsan_abilist_x86.txt
-else ifeq ($(ARCH),arm64)
-kdf_arch_abilist := -mllvm -dfsan-abilist=mm/kdfsan/kdfsan_abilist_arm64.txt
-endif
-
-common_kdfsan_args := -fsanitize=dataflow \
-	-mllvm -dfsan-abilist=mm/kdfsan/kdfsan_abilist_base.txt \
-	-mllvm -dfsan-kernel \
-	-mllvm -dfsan-keep-uninst-defs \
-	-mllvm -dfsan-task-centric-local-storage \
-	$(kdf_arch_abilist)
-
-# Ablation study support. The values are set and matched by the taskfiles.
-ifeq ($(KDFSAN_ABLATION),0_baseline)
-
-# This is just here to see clearly that this is the correct baseline config in the log.
-export CFLAGS_KDFSAN := -DBASELINE_KERNEL_FOR_KDFSAN
-
-else ifeq ($(KDFSAN_ABLATION),1_with_kdfsan)
-
-export CFLAGS_KDFSAN := $(common_kdfsan_args)
-
-else ifeq ($(KDFSAN_ABLATION),2_with_dma_region_tracking)
-
-export CFLAGS_KDFSAN := $(common_kdfsan_args)
-
-else ifeq ($(KDFSAN_ABLATION),3_with_memory_access_monitor_load)
-
-export CFLAGS_KDFSAN := $(common_kdfsan_args) \
-	-mllvm -dfsan-conditional-callbacks \
-	-mllvm -dfsan-event-callbacks-load \
-	-mllvm -dfsan-event-callbacks-mem-transfer
-
-else ifeq ($(KDFSAN_ABLATION),4_with_memory_access_monitor_store)
-
-export CFLAGS_KDFSAN := $(common_kdfsan_args) \
-	-mllvm -dfsan-conditional-callbacks \
-	-mllvm -dfsan-event-callbacks-load \
-	-mllvm -dfsan-event-callbacks-mem-transfer \
-	-mllvm -dfsan-event-callbacks-store
-
-else ifeq ($(KDFSAN_ABLATION),5_with_memory_access_monitor_cmp)
-
-export CFLAGS_KDFSAN := $(common_kdfsan_args) \
-	-mllvm -dfsan-conditional-callbacks \
-	-mllvm -dfsan-event-callbacks-load \
-	-mllvm -dfsan-event-callbacks-store \
-	-mllvm -dfsan-event-callbacks-mem-transfer \
-	-mllvm -dfsan-event-callbacks-cmp
-
-else ifeq ($(KDFSAN_ABLATION),6_with_taint_aka_dmaracer)
-
-# This is the intended default. Set by the Taskfile.yml.
-export CFLAGS_KDFSAN := $(common_kdfsan_args) \
-	-mllvm -dfsan-conditional-callbacks \
-	-mllvm -dfsan-event-callbacks-load \
-	-mllvm -dfsan-event-callbacks-store \
-	-mllvm -dfsan-event-callbacks-mem-transfer \
-	-mllvm -dfsan-event-callbacks-cmp
-
-else ifeq ($(KDFSAN_ABLATION),7_kmsan)
-
-#export CFLAGS_KDFSAN := -DKMSAN_INDICATOR
-$(error kmsan ablation should not enable KDFSan)
-
-else
-$(error Unknown KDFSAN_ABLATION value)
-endif
diff --git a/scripts/Makefile.lib b/scripts/Makefile.lib
index e34c35174bd1..68d0134bdbf9 100644
--- a/scripts/Makefile.lib
+++ b/scripts/Makefile.lib
@@ -172,20 +172,6 @@ _c_flags += $(if $(patsubst n%,, \
 		$(KMSAN_ENABLE_CHECKS_$(basetarget).o)$(KMSAN_ENABLE_CHECKS)y), \
 		, -mllvm -msan-disable-checks=1)
 endif
-ifeq ($(CONFIG_KDFSAN),y)
-# KDFSAN_SANITIZE is y by default
-_c_flags += $(if $(patsubst n%,, \
-		$(KDFSAN_SANITIZE_$(basetarget).o)$(KDFSAN_SANITIZE)y), \
-		$(CFLAGS_KDFSAN))
-# KDFSAN_NO_RUNTIME is n by default
-_c_flags += $(if $(patsubst y%,, \
-		$(KDFSAN_NO_RUNTIME_$(basetarget).o)$(KDFSAN_NO_RUNTIME)n), \
-		,-DKDFSAN_NO_RUNTIME)
-# KDFSAN_CLEARTAINT is n by default
-_c_flags += $(if $(patsubst y%,, \
-		$(KDFSAN_CLEARTAINT_$(basetarget).o)$(KDFSAN_CLEARTAINT)n), \
-		,-DKDFSAN_CLEARTAINT -mllvm -dfsan-clear-taint)
-endif
 
 ifeq ($(CONFIG_UBSAN),y)
 _c_flags += $(if $(patsubst n%,, \
diff --git a/scripts/decode_stacktrace.sh b/scripts/decode_stacktrace.sh
index a01f59d4f66d..564c5632e1a2 100755
--- a/scripts/decode_stacktrace.sh
+++ b/scripts/decode_stacktrace.sh
@@ -136,7 +136,6 @@ parse_symbol() {
 
 	# Strip the symbol name so that we could look it up
 	local name=${symbol%+*}
-	local shortname=${name#"dfs$"}
 
 	# Use 'nm vmlinux' to figure out the base address of said symbol.
 	# It's actually faster to call it every time than to load it
@@ -144,7 +143,7 @@ parse_symbol() {
 	if [[ $aarray_support == true && "${cache[$module,$name]+isset}" == "isset" ]]; then
 		local base_addr=${cache[$module,$name]}
 	else
-		local base_addr=$(nm "$objfile" | grep -i ' t ' | awk "/ *${shortname}\$/ {print \$1}" | head -n1)
+		local base_addr=$(nm "$objfile" 2>/dev/null | awk '$3 == "'$name'" && ($2 == "t" || $2 == "T") {print $1; exit}')
 		if [[ $base_addr == "" ]] ; then
 			# address not found
 			return
diff --git a/scripts/faddr2line b/scripts/faddr2line
index f5792b9a43db..0e73aca4f908 100755
--- a/scripts/faddr2line
+++ b/scripts/faddr2line
@@ -58,21 +58,8 @@ die() {
 	exit 1
 }
 
-UTIL_SUFFIX=""
-if [[ "${LLVM:-}" == "" ]]; then
-	UTIL_PREFIX=${CROSS_COMPILE:-}
-else
-	UTIL_PREFIX=llvm-
-
-	if [[ "${LLVM}" == *"/" ]]; then
-		UTIL_PREFIX=${LLVM}${UTIL_PREFIX}
-	elif [[ "${LLVM}" == "-"* ]]; then
-		UTIL_SUFFIX=${LLVM}
-	fi
-fi
-
-READELF="${UTIL_PREFIX}readelf${UTIL_SUFFIX}"
-ADDR2LINE="${UTIL_PREFIX}addr2line${UTIL_SUFFIX}"
+READELF="${CROSS_COMPILE:-}readelf"
+ADDR2LINE="${CROSS_COMPILE:-}addr2line"
 AWK="awk"
 GREP="grep"
 
@@ -85,17 +72,15 @@ command -v ${ADDR2LINE} >/dev/null 2>&1 || die "${ADDR2LINE} isn't installed"
 # init/main.c!  This only works for vmlinux.  Otherwise it falls back to
 # printing the absolute path.
 find_dir_prefix() {
-	local start_kernel_addr=$(echo "${ELF_SYMS}" | sed 's/\[.*\]//' |
+	local objfile=$1
+
+	local start_kernel_addr=$(${READELF} --symbols --wide $objfile | sed 's/\[.*\]//' |
 		${AWK} '$8 == "start_kernel" {printf "0x%s", $2}')
 	[[ -z $start_kernel_addr ]] && return
 
-	run_addr2line ${start_kernel_addr} ""
-	[[ -z $ADDR2LINE_OUT ]] && return
+	local file_line=$(${ADDR2LINE} -e $objfile $start_kernel_addr)
+	[[ -z $file_line ]] && return
 
-	local file_line=${ADDR2LINE_OUT#* at }
-	if [[ -z $file_line ]] || [[ $file_line = $ADDR2LINE_OUT ]]; then
-		return
-	fi
 	local prefix=${file_line%init/main.c:*}
 	if [[ -z $prefix ]] || [[ $prefix = $file_line ]]; then
 		return
@@ -105,71 +90,6 @@ find_dir_prefix() {
 	return 0
 }
 
-run_readelf() {
-	local objfile=$1
-	local out=$(${READELF} --file-header --section-headers --symbols --wide $objfile)
-
-	# This assumes that readelf first prints the file header, then the section headers, then the symbols.
-	# Note: It seems that GNU readelf does not prefix section headers with the "There are X section headers"
-	# line when multiple options are given, so let's also match with the "Section Headers:" line.
-	ELF_FILEHEADER=$(echo "${out}" | sed -n '/There are [0-9]* section headers, starting at offset\|Section Headers:/q;p')
-	ELF_SECHEADERS=$(echo "${out}" | sed -n '/There are [0-9]* section headers, starting at offset\|Section Headers:/,$p' | sed -n '/Symbol table .* contains [0-9]* entries:/q;p')
-	ELF_SYMS=$(echo "${out}" | sed -n '/Symbol table .* contains [0-9]* entries:/,$p')
-}
-
-check_vmlinux() {
-	# vmlinux uses absolute addresses in the section table rather than
-	# section offsets.
-	IS_VMLINUX=0
-	local file_type=$(echo "${ELF_FILEHEADER}" |
-		${AWK} '$1 == "Type:" { print $2; exit }')
-	if [[ $file_type = "EXEC" ]] || [[ $file_type == "DYN" ]]; then
-		IS_VMLINUX=1
-	fi
-}
-
-init_addr2line() {
-	local objfile=$1
-
-	check_vmlinux
-
-	ADDR2LINE_ARGS="--functions --pretty-print --inlines --addresses --exe=$objfile --output-style=LLVM"
-	if [[ $IS_VMLINUX = 1 ]]; then
-		# If the executable file is vmlinux, we don't pass section names to
-		# addr2line, so we can launch it now as a single long-running process.
-		coproc ADDR2LINE_PROC (${ADDR2LINE} ${ADDR2LINE_ARGS})
-	fi
-}
-
-run_addr2line() {
-	local addr=$1
-	local sec_name=$2
-
-	if [[ $IS_VMLINUX = 1 ]]; then
-		# We send to the addr2line process: (1) the address, then (2) a sentinel
-		# value, i.e., something that can't be interpreted as a valid address
-		# (i.e., ","). This causes addr2line to write out: (1) the answer for
-		# our address, then (2) either "?? ??:0" or "0x0...0: ..." (if
-		# using binutils' addr2line), or "," (if using LLVM's addr2line).
-		echo ${addr} >& "${ADDR2LINE_PROC[1]}"
-		echo "," >& "${ADDR2LINE_PROC[1]}"
-		local first_line
-		read -r first_line <& "${ADDR2LINE_PROC[0]}"
-		ADDR2LINE_OUT=$(echo "${first_line}" | sed 's/^0x[0-9a-fA-F]*: //')
-		while read -r line <& "${ADDR2LINE_PROC[0]}"; do
-			if [[ "$line" == "?? ??:0" ]] || [[ "$line" == "," ]] || [[ $(echo "$line" | ${GREP} "^0x00*: ") ]]; then
-				break
-			fi
-			ADDR2LINE_OUT+=$'\n'$(echo "$line" | sed 's/^0x[0-9a-fA-F]*: //')
-		done
-	else
-		# Run addr2line as a single invocation.
-		local sec_arg
-		[[ -z $sec_name ]] && sec_arg="" || sec_arg="--section=${sec_name}"
-		ADDR2LINE_OUT=$(${ADDR2LINE} ${ADDR2LINE_ARGS} ${sec_arg} ${addr} | sed 's/^0x[0-9a-fA-F]*: //')
-	fi
-}
-
 __faddr2line() {
 	local objfile=$1
 	local func_addr=$2
@@ -180,6 +100,8 @@ __faddr2line() {
 	local func_offset=${func_addr#*+}
 	func_offset=${func_offset%/*}
 	local user_size=
+	local file_type
+	local is_vmlinux=0
 	[[ $func_addr =~ "/" ]] && user_size=${func_addr#*/}
 
 	if [[ -z $sym_name ]] || [[ -z $func_offset ]] || [[ $sym_name = $func_addr ]]; then
@@ -188,6 +110,14 @@ __faddr2line() {
 		return
 	fi
 
+	# vmlinux uses absolute addresses in the section table rather than
+	# section offsets.
+	local file_type=$(${READELF} --file-header $objfile |
+		${AWK} '$1 == "Type:" { print $2; exit }')
+	if [[ $file_type = "EXEC" ]] || [[ $file_type == "DYN" ]]; then
+		is_vmlinux=1
+	fi
+
 	# Go through each of the object's symbols which match the func name.
 	# In rare cases there might be duplicates, in which case we print all
 	# matches.
@@ -200,7 +130,8 @@ __faddr2line() {
 		local sec_name
 
 		# Get the section size:
-		sec_size=$(echo "${ELF_SECHEADERS}" | sed 's/\[ /\[/' |
+		sec_size=$(${READELF} --section-headers --wide $objfile |
+			sed 's/\[ /\[/' |
 			${AWK} -v sec=$sym_sec '$1 == "[" sec "]" { print "0x" $6; exit }')
 
 		if [[ -z $sec_size ]]; then
@@ -210,7 +141,8 @@ __faddr2line() {
 		fi
 
 		# Get the section name:
-		sec_name=$(echo "${ELF_SECHEADERS}" | sed 's/\[ /\[/' |
+		sec_name=$(${READELF} --section-headers --wide $objfile |
+			sed 's/\[ /\[/' |
 			${AWK} -v sec=$sym_sec '$1 == "[" sec "]" { print $2; exit }')
 
 		if [[ -z $sec_name ]]; then
@@ -234,11 +166,6 @@ __faddr2line() {
 			local cur_sym_elf_size=${fields[2]}
 			local cur_sym_name=${fields[7]:-}
 
-			# is_mapping_symbol(cur_sym_name)
-			if [[ ${cur_sym_name} =~ ^(\.L|L0|\$) ]]; then
-				continue
-			fi
-
 			if [[ $cur_sym_addr = $sym_addr ]] &&
 			   [[ $cur_sym_elf_size = $sym_elf_size ]] &&
 			   [[ $cur_sym_name = $sym_name ]]; then
@@ -252,7 +179,7 @@ __faddr2line() {
 				found=2
 				break
 			fi
-		done < <(echo "${ELF_SYMS}" | sed 's/\[.*\]//' | ${AWK} -v sec=$sym_sec '$7 == sec' | sort --key=2 | ${GREP} -A1 --no-group-separator " ${sym_name}$")
+		done < <(${READELF} --symbols --wide $objfile | sed 's/\[.*\]//' | ${AWK} -v sec=$sym_sec '$7 == sec' | sort --key=2)
 
 		if [[ $found = 0 ]]; then
 			warn "can't find symbol: sym_name: $sym_name sym_sec: $sym_sec sym_addr: $sym_addr sym_elf_size: $sym_elf_size"
@@ -304,9 +231,9 @@ __faddr2line() {
 
 		# Pass section address to addr2line and strip absolute paths
 		# from the output:
-		run_addr2line $addr $sec_name
-		for i in {1..32}; do [[ "$ADDR2LINE_OUT" == *":0:"* ]] && run_addr2line 0x$(printf %x $(($addr - $i))) $sec_name; done # If the string ":0:" is in the output, retry with addr-i for i=[1,16]
-		local output=$(echo "${ADDR2LINE_OUT}" | sed "s; $dir_prefix\(\./\)*; ;")
+		local args="--functions --pretty-print --inlines --exe=$objfile"
+		[[ $is_vmlinux = 0 ]] && args="$args --section=$sec_name"
+		local output=$(${ADDR2LINE} $args $addr | sed "s; $dir_prefix\(\./\)*; ;")
 		[[ -z $output ]] && continue
 
 		# Default output (non --list):
@@ -333,7 +260,7 @@ __faddr2line() {
 
 		DONE=1
 
-	done < <(echo "${ELF_SYMS}" | sed 's/\[.*\]//' | ${AWK} -v fn=$sym_name '$8 == fn')
+	done < <(${READELF} --symbols --wide $objfile | sed 's/\[.*\]//' | ${AWK} -v fn=$sym_name '$4 == "FUNC" && $8 == fn')
 }
 
 [[ $# -lt 2 ]] && usage
@@ -346,14 +273,10 @@ LIST=0
 [[ ! -f $objfile ]] && die "can't find objfile $objfile"
 shift
 
-run_readelf $objfile
-
-echo "${ELF_SECHEADERS}" | ${GREP} -q '\.debug_info' || die "CONFIG_DEBUG_INFO not enabled"
-
-init_addr2line $objfile
+${READELF} --section-headers --wide $objfile | ${GREP} -q '\.debug_info' || die "CONFIG_DEBUG_INFO not enabled"
 
 DIR_PREFIX=supercalifragilisticexpialidocious
-find_dir_prefix
+find_dir_prefix $objfile
 
 FIRST=1
 while [[ $# -gt 0 ]]; do
diff --git a/tools/objtool/check.c b/tools/objtool/check.c
index ad57f8a6404e..e308d1ba664e 100644
--- a/tools/objtool/check.c
+++ b/tools/objtool/check.c
@@ -1234,147 +1234,6 @@ static const char *uaccess_safe_builtin[] = {
 	"rep_stos_alternative",
 	"rep_movs_alternative",
 	"__copy_user_nocache",
-	/* KDFSAN */
-	"__dfsan_read_label",
-	"__dfsan_union",
-	"__dfsan_set_label",
-	"__dfsan_store_callback",
-	"__dfsan_load_callback",
-	"__dfsan_cmp_callback",
-	"__dfsan_mem_transfer_callback",
-	/* Repeated but including KDFSAN prefix (there's probably a better way to work around this) */
-	/* KASAN */
-	"dfs$kasan_report",
-	"dfs$kasan_check_range",
-	/* KASAN out-of-line */
-	"dfs$__asan_loadN_noabort",
-	"dfs$__asan_load1_noabort",
-	"dfs$__asan_load2_noabort",
-	"dfs$__asan_load4_noabort",
-	"dfs$__asan_load8_noabort",
-	"dfs$__asan_load16_noabort",
-	"dfs$__asan_storeN_noabort",
-	"dfs$__asan_store1_noabort",
-	"dfs$__asan_store2_noabort",
-	"dfs$__asan_store4_noabort",
-	"dfs$__asan_store8_noabort",
-	"dfs$__asan_store16_noabort",
-	"dfs$__kasan_check_read",
-	"dfs$__kasan_check_write",
-	/* KASAN in-line */
-	"dfs$__asan_report_load_n_noabort",
-	"dfs$__asan_report_load1_noabort",
-	"dfs$__asan_report_load2_noabort",
-	"dfs$__asan_report_load4_noabort",
-	"dfs$__asan_report_load8_noabort",
-	"dfs$__asan_report_load16_noabort",
-	"dfs$__asan_report_store_n_noabort",
-	"dfs$__asan_report_store1_noabort",
-	"dfs$__asan_report_store2_noabort",
-	"dfs$__asan_report_store4_noabort",
-	"dfs$__asan_report_store8_noabort",
-	"dfs$__asan_report_store16_noabort",
-	/* KCSAN */
-	"dfs$__kcsan_check_access",
-	"dfs$kcsan_found_watchpoint",
-	"dfs$kcsan_setup_watchpoint",
-	"dfs$kcsan_check_scoped_accesses",
-	"dfs$kcsan_disable_current",
-	"dfs$kcsan_enable_current_nowarn",
-	/* KCSAN/TSAN */
-	"dfs$__tsan_func_entry",
-	"dfs$__tsan_func_exit",
-	"dfs$__tsan_read_range",
-	"dfs$__tsan_write_range",
-	"dfs$__tsan_read1",
-	"dfs$__tsan_read2",
-	"dfs$__tsan_read4",
-	"dfs$__tsan_read8",
-	"dfs$__tsan_read16",
-	"dfs$__tsan_write1",
-	"dfs$__tsan_write2",
-	"dfs$__tsan_write4",
-	"dfs$__tsan_write8",
-	"dfs$__tsan_write16",
-	"dfs$__tsan_read_write1",
-	"dfs$__tsan_read_write2",
-	"dfs$__tsan_read_write4",
-	"dfs$__tsan_read_write8",
-	"dfs$__tsan_read_write16",
-	"dfs$__tsan_atomic8_load",
-	"dfs$__tsan_atomic16_load",
-	"dfs$__tsan_atomic32_load",
-	"dfs$__tsan_atomic64_load",
-	"dfs$__tsan_atomic8_store",
-	"dfs$__tsan_atomic16_store",
-	"dfs$__tsan_atomic32_store",
-	"dfs$__tsan_atomic64_store",
-	"dfs$__tsan_atomic8_exchange",
-	"dfs$__tsan_atomic16_exchange",
-	"dfs$__tsan_atomic32_exchange",
-	"dfs$__tsan_atomic64_exchange",
-	"dfs$__tsan_atomic8_fetch_add",
-	"dfs$__tsan_atomic16_fetch_add",
-	"dfs$__tsan_atomic32_fetch_add",
-	"dfs$__tsan_atomic64_fetch_add",
-	"dfs$__tsan_atomic8_fetch_sub",
-	"dfs$__tsan_atomic16_fetch_sub",
-	"dfs$__tsan_atomic32_fetch_sub",
-	"dfs$__tsan_atomic64_fetch_sub",
-	"dfs$__tsan_atomic8_fetch_and",
-	"dfs$__tsan_atomic16_fetch_and",
-	"dfs$__tsan_atomic32_fetch_and",
-	"dfs$__tsan_atomic64_fetch_and",
-	"dfs$__tsan_atomic8_fetch_or",
-	"dfs$__tsan_atomic16_fetch_or",
-	"dfs$__tsan_atomic32_fetch_or",
-	"dfs$__tsan_atomic64_fetch_or",
-	"dfs$__tsan_atomic8_fetch_xor",
-	"dfs$__tsan_atomic16_fetch_xor",
-	"dfs$__tsan_atomic32_fetch_xor",
-	"dfs$__tsan_atomic64_fetch_xor",
-	"dfs$__tsan_atomic8_fetch_nand",
-	"dfs$__tsan_atomic16_fetch_nand",
-	"dfs$__tsan_atomic32_fetch_nand",
-	"dfs$__tsan_atomic64_fetch_nand",
-	"dfs$__tsan_atomic8_compare_exchange_strong",
-	"dfs$__tsan_atomic16_compare_exchange_strong",
-	"dfs$__tsan_atomic32_compare_exchange_strong",
-	"dfs$__tsan_atomic64_compare_exchange_strong",
-	"dfs$__tsan_atomic8_compare_exchange_weak",
-	"dfs$__tsan_atomic16_compare_exchange_weak",
-	"dfs$__tsan_atomic32_compare_exchange_weak",
-	"dfs$__tsan_atomic64_compare_exchange_weak",
-	"dfs$__tsan_atomic8_compare_exchange_val",
-	"dfs$__tsan_atomic16_compare_exchange_val",
-	"dfs$__tsan_atomic32_compare_exchange_val",
-	"dfs$__tsan_atomic64_compare_exchange_val",
-	"dfs$__tsan_atomic_thread_fence",
-	"dfs$__tsan_atomic_signal_fence",
-	/* KCOV */
-	"dfs$write_comp_data",
-	"dfs$check_kcov_mode",
-	"dfs$__sanitizer_cov_trace_pc",
-	"dfs$__sanitizer_cov_trace_const_cmp1",
-	"dfs$__sanitizer_cov_trace_const_cmp2",
-	"dfs$__sanitizer_cov_trace_const_cmp4",
-	"dfs$__sanitizer_cov_trace_const_cmp8",
-	"dfs$__sanitizer_cov_trace_cmp1",
-	"dfs$__sanitizer_cov_trace_cmp2",
-	"dfs$__sanitizer_cov_trace_cmp4",
-	"dfs$__sanitizer_cov_trace_cmp8",
-	"dfs$__sanitizer_cov_trace_switch",
-	/* UBSAN */
-	"dfs$ubsan_type_mismatch_common",
-	"dfs$__ubsan_handle_type_mismatch",
-	"dfs$__ubsan_handle_type_mismatch_v1",
-	"dfs$__ubsan_handle_shift_out_of_bounds",
-	/* misc */
-	"dfs$csum_partial_copy_generic",
-	"dfs$copy_mc_fragile",
-	"dfs$copy_mc_fragile_handle_tail",
-	"dfs$copy_mc_enhanced_fast_string",
-	"dfs$ftrace_likely_update", /* CONFIG_TRACE_BRANCH_PROFILING */
 	NULL
 };
 
